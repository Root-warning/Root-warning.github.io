<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="只因不值得">
  <meta name="keywords" content="">
  <title>Python基础之面向对象 - 只因不值得</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/css/main.css" />


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->

  
<link rel="stylesheet" href="/css/custom.css">



<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>只因不值得</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">关于</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/links/">友链</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/img/default.png') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    8.8k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      37 分钟
                  </span>
                

                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p
                class="note note-warning">本文最后更新于：2019 , 八月 19日 星期一, 4:32 下午</p>
            
            <div class="markdown-body">
              <h1 id="0x00-初识类"><a href="#0x00-初识类" class="headerlink" title="0x00 初识类"></a>0x00 初识类</h1><p><code>python中一切皆对象</code></p>
<h2 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h2><pre><code class="python">&#39;&#39;&#39;
class 类名:
    &#39;类的文档&#39;
    类体
&#39;&#39;&#39;

class Data:
    pass</code></pre>
<p>关键字：<code>class</code></p>
<a id="more"></a>



<h2 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h2><p>格式：<code>类名.属性</code></p>
<p>类名的作用：操作属性，查看属性</p>
<pre><code class="python">#（注：这只是示范，实际操作请勿使用中文）
class Data:
    属性 = &#39;a&#39;
print(Data.a)</code></pre>
<h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><p>格式：<code>对象名 = 类名(参数)</code></p>
<p><code>类名()</code>就是实例化，会自动触动<code>__init__</code>函数的运行，可以用类为每个实例定制自己的特征</p>
<pre><code class="python">class Person:
    def __init__(self,*args):
        self.name = args[0]
        self.age = args[1]
        self.heg = args[2]

alex = Person(&#39;Psycho&#39;,0,&#39;???&#39;)
print(alex.name)
----------------------------------
&#39;&#39;&#39;
对象 = 类名()
过程：
    类名() 会创造出一个对象，创建一个self变量
    调用__inti__方法，类名()里面的参数会被这里接收
    执行__init__方法
    返回self
&#39;&#39;&#39;</code></pre>
<h2 id="实例化方法"><a href="#实例化方法" class="headerlink" title="实例化方法"></a>实例化方法</h2><p>格式：<code>类名.方法名(对象名)</code></p>
<pre><code class="python">class Person:
    def __init__(self,*args):
        self.name = args[0]
        self.age = args[1]
        self.heg = args[2]

    def walk(self):
        print(&#39;%s&#39;%self.name)


alex = Person(&#39;Psycho&#39;,0,&#39;???&#39;)
print(alex.name)
Person.walk(alex)</code></pre>
<h2 id="init-方法"><a href="#init-方法" class="headerlink" title="__init__方法"></a><code>__init__</code>方法</h2><p>这个方法一般用于初始化类<br>但是，当实例化一个类的时候，并不是第一个被调用的，第一个被调用的是<code>__new__</code></p>
<blockquote>
<p>Tips：对当前对象的实例的一些初始化，没有返回值</p>
</blockquote>
<p>设置对象的初始属性：<code>self.属性 = 形参</code></p>
<p>在创建对象时，使用<code>类名(属性1，属性2...)</code>进行调用</p>
<pre><code class="python">class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age

info = Person(&#39;alex&#39;,&#39;22&#39;)</code></pre>
<h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><p><strong>init</strong>方法的第一参数永远是self，表示创建类的实例化本身<br>因此，在<strong>init</strong>方法内部，就可以把各种属性绑定到self</p>
<p><code>self.name</code>：表示某类的属性变量</p>
<blockquote>
<p>self.name = name 就是把外部传来的参数name赋值给某类自己的属性变量</p>
</blockquote>
<h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><pre><code class="python">类的属性存储地址：
dir(类名)
类名.__dict__：查出的是一个字典，key为属性名，value为属性值

---------------------
类名.__name__# 类的名字(字符串)
类名.__doc__# 类的文档字符串
类名.__base__# 类的第一个父类
类名.__bases__# 类所有父类构成的元组
类名.__dict__# 类的字典属性
类名.__module__# 类定义所在的模块
类名.__class__# 实例对应的类(仅新式类中)</code></pre>
<h2 id="其他内置方法"><a href="#其他内置方法" class="headerlink" title="其他内置方法"></a>其他内置方法</h2><h3 id="str"><a href="#str" class="headerlink" title="__str__"></a><code>__str__</code></h3><p>如果直接print(object)打印对象，会看到创建出来的对象在内存中的地址<br>当使用print(object)输出对象的时候，只要对象的类中定义了<code>__str__(self)</code>方法，就会打印该方法<code>return</code>的信息描述</p>
<pre><code class="python">class Person:
    def __str__(self):
        return &quot;这是个信息模块&quot;

    def __init__(self,name,age):
        self.name = name
        self.age = age

info = Person(&#39;alex&#39;,&#39;22&#39;)
print(info)</code></pre>
<h3 id="del"><a href="#del" class="headerlink" title="__del__"></a><code>__del__</code></h3><p>析构方法，当对象在内存中被释放时，自动触发执行<br>在删除一个对象之前，进行一些收尾工作</p>
<pre><code class="python">class Person:
    def __str__(self):
        return &quot;这是个信息模块&quot;

    def __init__(self, name, age):
        self.name = name
        self.age = age

    def __del__(self):
        print(&#39;关闭对象&#39;)

info = Person(&#39;alex&#39;, &#39;22&#39;)</code></pre>
<h3 id="repr"><a href="#repr" class="headerlink" title="__repr__"></a><code>__repr__</code></h3><p>返回一个可以用来表示对象的可打印字符串<br><code>__repr__</code>是<code>__str__</code>的备胎，但<code>__str__</code>不能做<code>__repr__</code>的备胎<br>如果<code>__str__</code>方法有，那么它返回的必定一个字符串</p>
<pre><code class="python">class A:

    def __init__(self,name,age):
        self.name = name
        self.age = age

    def __repr__(self):
        return str(self.__dict__)

    # def __str__(self):
    #     return &#39;%s,%s&#39;%(self.name,self.age)

a = A(&#39;xxx&#39;,20)
print(a)</code></pre>
<blockquote>
<p> Ps：%r，repr()都是走<code>__repr__</code></p>
</blockquote>
<p>与<code>__str__</code>的区别：</p>
<ol>
<li><code>__str__()</code>：返回用户看到的字符串</li>
<li><code>__repr__()</code>：返回程序开发者看到的字符串</li>
</ol>
<blockquote>
<p>内置的方法有很多，不一定全部都在object中</p>
</blockquote>
<h3 id="call"><a href="#call" class="headerlink" title="__call__"></a><code>__call__</code></h3><p>一个对象后面加括号，触发执行</p>
<pre><code class="python">class A:
    def __init__(self,name):
        pass

    def __call__(self):
        print(&#39;执行此处&#39;)
a = A(&#39;alex&#39;)</code></pre>
<h3 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a><code>__getattr__</code></h3><p>定义当用户试图获取一个不存在的属性时的行为，适用于对普通拼写错误的获取和重定向，对获取一些不建议的属性时给出警告或者处理一个AttributeError，只有当调用不存在的属性的时候才会被返回</p>
<pre><code class="pyhton">class Student(object):  
    def__getattr__(self, attrname):  
        ifattrname ==&quot;age&quot;:  
            return40  
        else:  
            raiseAttributeError, attrname  

x =Student()  
print(x.age)       #40  
print(x.name)      #error text omitted.....AttributeError, name  </code></pre>
<h3 id="setattr"><a href="#setattr" class="headerlink" title="__setattr__"></a><code>__setattr__</code></h3><p>是一个封装的解决方案，无论属性是否存在，它都允许你定义对属性的赋值行为，以为这你可以对属性的值进行个性定制，实现<code>__setattr__</code>时要避免”无限递归”错误</p>
<p>当试图对象的item特性赋值的时候将会被调用</p>
<pre><code class="python"># -*- coding:utf-8 -*-
class Student:
    def __getattr__(self, item):
        return item + &#39; is not exits&#39;

    def __setattr__(self, key, value):
        self.__dict__[key] = value

    def __getitem__(self, item):
        return self.__dict__[item]

    def __setitem__(self, key, value):
        self.__dict__[key] = value


s = Student()
print(s.name)  # 调用__getattr__方法 输出&#39;name is not exits&#39;
s.age = 1  # 调用__setattr__ 方法
print(s.age)  # 输出 1
print(s[&#39;age&#39;])  # 调用 __getitem__方法 输出1
s[&#39;name&#39;] = &#39;tom&#39;  # 调用 __setitem__ 方法
print(s[&#39;name&#39;])  # 调用 __getitem__ 方法 输出 &#39;tom&#39;</code></pre>
<h3 id="delattr"><a href="#delattr" class="headerlink" title="__delattr__"></a><code>__delattr__</code></h3><p>与<code>__setattr__</code>相同，删除一个属性</p>
<pre><code class="python">class A(object):
    def __delattr__(self, *args, **kwargs):  
        print &#39;call func del attr&#39;  
        return object.__delattr__(self, *args, **kwargs)  </code></pre>
<h3 id="getattribute"><a href="#getattribute" class="headerlink" title="__getattribute__"></a><code>__getattribute__</code></h3><p>定义了你的属性被访问时的行为，在支持<code>__getattribute__</code>的python版本，调用<code>__getattr__</code>前必定会调用<code>__getattribute__</code>，不要尝试实现<code>__getattribute__</code></p>
<p>容易出bug</p>
<pre><code class="python">class Tree(object):
    def __init__(self,name):
        self.name = name
        self.cate = &quot;plant&quot;
    def __getattribute__(self,obj):
        print(&quot;哈哈&quot;)
        return object.__getattribute__(self,obj)
aa = Tree(&quot;大树&quot;)
print(aa.name)</code></pre>
<h3 id="item系列"><a href="#item系列" class="headerlink" title="item系列"></a>item系列</h3><h4 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__"></a><code>__getitem__</code></h4><p>当访问不存在的属性时会调用该方法</p>
<blockquote>
<p>可以让对象实现迭代功能，以及p[key]取值</p>
</blockquote>
<pre><code class="pyton"># data[&#39;key&#39;]取值
class DataTest:
    def __init__(self, name,id):
        self.name = name
        self.id = id

    def __getitem__(self, item):
        return self.__dict__[item]

data = DataTest(&#39;alex&#39;,&#39;1&#39;)
print(data[&#39;name&#39;])

# 实现迭代功能
class DataTest:
    def __init__(self, name,id):
        self.name = name
        self.id = id

    def __getitem__(self, item):
        return self.name[item]

data = DataTest([&#39;alex&#39;,&#39;lie&#39;,&#39;psycho&#39;],&#39;1&#39;)
for i in data:
    print(i)</code></pre>
<h4 id="setitem"><a href="#setitem" class="headerlink" title="__setitem__"></a><code>__setitem__</code></h4><p>每当属性被赋值的时候都会调用该方法，因此不能在该方法内（self.name = value）赋值，否则会死循环！</p>
<pre><code class="python">class DataTest:
    def __init__(self, name,id):
        self.name = name
        self.id = id

    def __getitem__(self, item):
        return self.__dict__[item]

    def __setitem__(self, key, value):
        self.__dict__[key]=value

data = DataTest([&#39;alex&#39;,&#39;lie&#39;,&#39;psycho&#39;],&#39;1&#39;)
data[&#39;alex&#39;] = &#39;女&#39;
print(data[&#39;alex&#39;])</code></pre>
<h4 id="delitem"><a href="#delitem" class="headerlink" title="__delitem__"></a><code>__delitem__</code></h4><p>当删除属性时调用该方法</p>
<pre><code class="python">lass DataTest:
    def __init__(self, name,id):
        self.name = name
        self.id = id

    def __getitem__(self, item):
        return self.__dict__[item]

    def __setitem__(self, key, value):
        self.__dict__[key]=value

    def __delitem__(self, key):
        del self.__dict__[key]

data = DataTest([&#39;alex&#39;,&#39;lie&#39;,&#39;psycho&#39;],&#39;1&#39;)
data[&#39;alex&#39;] = &#39;女&#39;
print(&#39;删除前：%s&#39;%data.__dict__)
del data[&#39;alex&#39;]
print(&#39;删除后：%s&#39;%data.__dict__)</code></pre>
<h4 id="new"><a href="#new" class="headerlink" title="__new__"></a><code>__new__</code></h4><p>构造方法：创建一个对象（只负责创建）</p>
<pre><code class="python">class DataTest:

    __instance = False

    def __init__(self, name,id):
        self.name = name
        self.id = id

    def __new__(cls, *args, **kwargs):
        if cls.__instance:
            return cls.__instance
        cls.__instance = object.__new__(cls)
        return cls.__instance

data = DataTest(&#39;alex&#39;,&#39;1&#39;)
nas = DataTest(&#39;nice&#39;,&#39;2&#39;)
print(data)
print(nas)</code></pre>
<h4 id="eq"><a href="#eq" class="headerlink" title="__eq__"></a><code>__eq__</code></h4><p>当判断两个对象是否相等时，触发</p>
<pre><code class="python">class DataTest:

    def __init__(self, name,id):
        self.name = name
        self.id = id

    def __eq__(self, other):
        if self.__dict__ == other.__dict__:
            return True
        else:
            return False

data = DataTest(&#39;alex&#39;,&#39;1&#39;)
nas = DataTest(&#39;nice&#39;,&#39;2&#39;)
print(data == nas)</code></pre>
<h4 id="len"><a href="#len" class="headerlink" title="__len__"></a><code>__len__</code></h4><p><code>返回元素的个数</code><br>如果一个类表现得像一个list，要获取有多少个元素，就得用len()函数，要让len()函数正常工作，类必须提供一个特殊方法len()</p>
<pre><code class="python">class DataTest:

    __instance = False

    def __init__(self, name,id):
        self.name = name
        self.id = id

    def __len__(self):
        return len(self.name)

data = DataTest([&#39;alex&#39;,&#39;nice&#39;],&#39;1&#39;)
print(len(data.name))</code></pre>
<h4 id="hash"><a href="#hash" class="headerlink" title="__hash__"></a><code>__hash__</code></h4><p>如果定义可变对象的类实现了<code>__eq__</code>放阿飞，就不要再实现<code>__hash__</code>方法，否则这个对象的hash值发生变化会导致被放在错误的哈希中</p>
<pre><code class="python">class DataTest:
    def __init__(self):
        self.name = &#39;alex&#39;
        self.id = &#39;2&#39;

    def __hash__(self):
        return hash(str(self.name)+str(self.id))

a = DataTest()
print(hash(a))</code></pre>
<h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><ul>
<li><code>继承</code>：实现代码重用</li>
<li><code>多态</code>：不同的对象调用相同方法，产生不同的执行结果</li>
<li><code>封装</code>：根据职责将属性和方法封装到一个抽象的类中</li>
</ul>
<h1 id="0x02-继承"><a href="#0x02-继承" class="headerlink" title="0x02 继承"></a>0x02 继承</h1><p>继承是一种创新类的方式，实现代码的重用，相同的代码不需要重复的编写</p>
<p><code>继承的传递性</code>：<code>子类</code>拥有<code>父类</code>的所有<code>方法</code>和<code>属性</code>及<code>父类的的父类</code>中<code>封装的所有属性和方法</code></p>
<blockquote>
<p>Ps：继承父类的时候，前提条件必须有那个类的存在！</p>
<p>Ps：如果在自己的类中有该方法，先用自己的，没有再从父类中寻找</p>
</blockquote>
<p><strong>1. 继承分为：</strong></p>
<ul>
<li>单继承</li>
<li>多继承</li>
</ul>
<p><strong>2. 通过继承创建的新类：</strong></p>
<ul>
<li>子类</li>
<li>派生类</li>
</ul>
<p><strong>3. 被继承的类：</strong></p>
<ul>
<li>基类</li>
<li>父类</li>
<li>超类</li>
</ul>
<p><strong>查看继承：</strong><code>__bases__</code></p>
<h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>继承的语法：</p>
<pre><code class="python">class 类名(父类名):
        pass</code></pre>
<p>子类<code>拥有</code>父类的<code>所有方法</code>和<code>属性</code></p>
<pre><code class="python">class Arm:
    def __init__(self,name,aggr,hp):
        self.name = name
        self.aggr = aggr
        self.hp = hp

class Person(Arm):
    pass

class Dog(Arm):
    pass

jin = Dog(&#39;jin&#39;,500,20)
print(jin.name)</code></pre>
<h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>子类可以拥有多个父类，并且具有所有父类的属性和方法</p>
<pre><code class="python">class 类名(父类1,父类2...):
    pass</code></pre>
<blockquote>
<p>多继承中，我们子类的对象调用一个方法，默认是就近原则 经典类中 深度优先 新式类中 广度优先 2.7 新式类和经典类共存，新式类要继承object python3 只有新式类</p>
</blockquote>
<pre><code class="python">class ParentClass1: #定义父类
    pass

class ParentClass2: #定义父类
    pass

class SubClass1(ParentClass1): #单继承，基类是ParentClass1，派生类是SubClass
    pass

class SubClass2(ParentClass1,ParentClass2): #python支持多继承，用逗号分隔开多个继承的类
    pass</code></pre>
<blockquote>
<p>Ps：父类之间存在同名的属性或方法，应该尽量避免使用多继承，容易产生混淆</p>
</blockquote>
<h2 id="重用性"><a href="#重用性" class="headerlink" title="重用性"></a>重用性</h2><p>在程序开发的过程中，定义了一个A类与一个B类，但是这两个类的大部分内容都相同 我们可以通过继承的方式，让B类继承A的所有属性，实现代码重用</p>
<pre><code class="python">class Arm:
    def __init__(self,name,aggr,hp):
        self.name = name
        self.aggr = aggr
        self.hp = hp

class Dog(Arm):
    pass

jin = Dog(&#39;jin&#39;,500,20)
print(jin.name)</code></pre>
<h2 id="方法的重写与派生"><a href="#方法的重写与派生" class="headerlink" title="方法的重写与派生"></a>方法的重写与派生</h2><p>当父类的方法实现不能满足子类的需求时，可以对方法进行<code>重写</code></p>
<p>重写父类的方法有两种情况：</p>
<ol>
<li>覆盖父类方法</li>
<li>对父类方法进行扩展</li>
</ol>
<h3 id="覆盖父类"><a href="#覆盖父类" class="headerlink" title="覆盖父类"></a>覆盖父类</h3><p>具体的实现方式，就相当于在子类中定义了一个和父类同名的方法并且实现</p>
<p>重写之后，在运行时，只会调用子类中重写的方法，而不再会调用父类封装的方法</p>
<pre><code class="python">class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

    def ack(self):
        print(&#39;wu&#39;)


class name(Person):

    def ack(self):
        print(&#39;%s ackti&#39;%self.name)

info = name(&#39;alex&#39;,20)
info.ack()
print(info.age)</code></pre>
<h3 id="重写父类方法（扩展）"><a href="#重写父类方法（扩展）" class="headerlink" title="重写父类方法（扩展）"></a>重写父类方法（扩展）</h3><p>在子类执行父类的方法也可以直接用<code>super()</code>方法</p>
<blockquote>
<p>super本质：不是单纯找父类，而是根据调用者的节点位置的广度优先顺序来的</p>
</blockquote>
<p>格式：<code>super().父类方法</code></p>
<pre><code class="python">class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age

class Arm(Person):
    def __init__(self,name,age,kind):
        super().__init__(name,age)
        self.kind = kind

sex = Arm(&#39;alex&#39;,20,50)
print(sex.kind)</code></pre>
<h3 id="派生属性"><a href="#派生属性" class="headerlink" title="派生属性"></a>派生属性</h3><p><code>派生属性/方法</code>：父类中没有的属性或方法，在子类中出现的</p>
<p><code>一旦重新定义了自己的属性且父类重名，那么调用新的属性时，就以自己为准</code></p>
<pre><code class="python">class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age

class Arm(Person):
    def __init__(self,name,age,kind):
        Person.__init__(self,name,age)
        self.kind = kind

sex = Arm(&#39;alex&#39;,50,20)
print(sex.kind)</code></pre>
<p>只要是子类的对象调用，子类中有的名字一定用子类的，子类中没有才找父类的</p>
<p>如果父类也没有 报错</p>
<p>如果父类 子类都有，用子类的，<code>如果还想用父类的，需要单独调用父类的，需要自己传self参数</code></p>
<pre><code class="python">class Arm:
    def __init__(self,name,aggr,hp):
        self.name = name
        self.aggr = aggr
        self.hp = hp

    def eat(self):
        print(&#39;吃药回血&#39;)
        self.hp += 100

class Dog(Arm):
    def __init__(self,name,aggr,hp,kind):
        Arm.__init__(self,name,aggr,hp)
        self.kind = kind

    def eat(self):
        Arm.eat(self)
        self.Thear = 2

    def bite(self,person):
        person.hp -= self.aggr


class Person(Arm):
    def __init__(self,name,aggr,hp,sex):
        Arm.__init__(self,name,aggr,hp)
        self.sex = sex
        self.money = 0

    def attack(self,dog):
        dog.hp -= self.aggr

    def get_weapon(self,weapon):
        if self.money &gt;= weapon.price:
            self.money -= weapon.price
            self.weapon = weapon
            self.aggr += weapon.aggr
        else:
            print(&quot;余额不足，请充值&quot;)

jin = Dog(&#39;jin&#39;,500,20,10)
jin.eat()</code></pre>
<h2 id="MRO（方法搜索顺序）"><a href="#MRO（方法搜索顺序）" class="headerlink" title="MRO（方法搜索顺序）"></a>MRO（方法搜索顺序）</h2><p>python针对类提供的一个内置属性，可以查看方法的搜索顺序</p>
<p>主要用于在多继承时判断，方法，属性的调用路径</p>
<p>从左到右的顺序查找，在当前类中找到方法就执行，不再搜索</p>
<p>没有找到，继续查找下一个类</p>
<p>最终没找到，报错</p>
<pre><code class="python">class Person:
    def __init__(self,name,age):
        self.name = name
        self.age = age

class Arm(Person):
    def __init__(self,name,age,kind):
        super().__init__(name,age)
        self.kind = kind

print(Arm.__mro__)</code></pre>
<h1 id="0x03-封装"><a href="#0x03-封装" class="headerlink" title="0x03 封装"></a>0x03 封装</h1><p>广义上的面向对象封装：代码的保护，面向对象的思想本身就是一种，只让自己的对象能调用自己类中的方法</p>
<p>狭义封装：面向对象的三大特性之一，属性和方法都隐藏起来</p>
<p>封装的三种方式：</p>
<ul>
<li>public（对外公开，不封装）</li>
<li>protected（对外不公开，对子类公开）</li>
<li>private（对谁都公开）</li>
</ul>
<p>python中一切皆对象</p>
<p>类是一个特殊的对象 – 类对象，使用一个类可以创建出很多歌对象实例</p>
<p>处了封装实例的属性和方法外，类对象还可以拥有自己的属性和方法</p>
<h2 id="类属性-1"><a href="#类属性-1" class="headerlink" title="类属性"></a>类属性</h2><p>给类对象中定义的属性</p>
<p>通常用来记录与这个类相关的特征</p>
<p>类属性不会用于记录具体对象的特征</p>
<p>调用：<code>类名.</code>的方式</p>
<pre><code class="python"># 计算人数
class Person:
    count = 0

    def __init__(self, name):
        self.name = name
        Person.count += 1

name1 = Person(&#39;alex&#39;)
print(Person.count)</code></pre>
<p><strong>属性的获取机制</strong>：向上查找机制</p>
<ol>
<li>首先在对象内部查找对象属性</li>
<li>没有找到就会向上寻找类属性</li>
</ol>
<p><strong>访问类属性有两种方式：</strong></p>
<ol>
<li><code>类名.类属性</code></li>
<li><code>对象.类属性</code>（不推荐）</li>
</ol>
<blockquote>
<p>Ps：如果使用<code>对象.类属性 = 值</code>赋值语句，只会给对象添加一个属性，而不会影响到类属性的值</p>
</blockquote>
<h2 id="私有方法和属性"><a href="#私有方法和属性" class="headerlink" title="私有方法和属性"></a>私有方法和属性</h2><p>私有属性和方法是对象的隐私，不对外公开，外界及子类都不能直接访问</p>
<p>通常用于做一些内部的事情</p>
<ul>
<li>对象的私有属性</li>
<li>类中的私有方法</li>
<li>类中静态私有属性</li>
</ul>
<p>定义私有属性与方法：<code>__</code>属性或方法</p>
<p>只要在类的内部使用私有属性，就会自动带上<code>__类名</code></p>
<blockquote>
<p>Ps：所有的私有，都不能在类的外部使用</p>
</blockquote>
<p>在外部调用的方法：<code>对象._类名__属性</code>（不推荐使用，仅供了解）</p>
<pre><code class="python">class Person:

    __manger = &#39;admin&#39; # 静态私有属性


    def __init__(self,username,passwod):
        self.username = username
        self.__password = passwod # 私有属性

    def __mange(self): # 私有方法
        print(&quot;管理员登录&quot;)

    def login(self):
        if self.__password != self.username:
            return (&quot;请输入正确的账号密码&quot;)
        else:
            if self.username == self.__manger:
                return self.__mange()
            else:
                return (&quot;登录成功&quot;)

username = &#39;admin&#39;
password = &#39;admin&#39;

win = Person(username,password)
login = win.login()
print(login)</code></pre>
<h2 id="property"><a href="#property" class="headerlink" title="property"></a>property</h2><p>内部装饰器，在面向对象中使用</p>
<p>把方法<code>伪装成属性</code>：<code>@property</code></p>
<blockquote>
<p>Ps：装饰器中不能跟任何参数</p>
</blockquote>
<pre><code class="python">class Person:
    def __init__(self,name):
        self.name = name

    @property
    def work(self):
        return &#39;111&#39;

x = Person(&#39;admin&#39;)
print(x.work)</code></pre>
<p>修改<code>@property</code>伪装的方法</p>
<blockquote>
<p>Ps：现有<code>@property</code>再有<code>@方法名.setter</code>，再创建一个一样的方法</p>
</blockquote>
<p><code>@方法名.setter</code>：把被装饰的方法变成属性来赋值</p>
<pre><code class="python"># 例子1
class Person:
    def __init__(self, name):
        self.__name = name

    @property
    def name(self):
        return self.__name

    @name.setter
    def name(self, new_name):
        self.__name = new_name


tiger = Person(&#39;nice&#39;)
print(tiger.name)

tiger.name = &#39;fuck&#39;
print(tiger.name)

###################################################

# 例子2
class Person:
    def __init__(self, name):
        self.__name = name

    @property
    def name(self):
        return self.__name

    @name.deleter
    def name(self):
        del self.__name


tiger = Person(&#39;nice&#39;)
print(tiger.name)

del tiger.name
print(tiger.name)

# deleter和del互相关联了</code></pre>
<h2 id="classmethod"><a href="#classmethod" class="headerlink" title="classmethod"></a>classmethod</h2><p><code>method</code>：方法</p>
<p><code>classmethod</code>：类方法</p>
<blockquote>
<p>Ps：把一个方法，变成一个类中的方法，这个方法就直接可以被类调用，不需要依托任何对象</p>
</blockquote>
<p>当这个方法的操作只涉及静态属性的时候，就应该使用<code>classmethod</code>来装饰这个方法</p>
<p>对应的方法不需要实例化，不用self参数，当<code>第一个参数需要是表示自身类的cls参数</code>，可以来调用类的属性和方法及实例化对象等</p>
<p>调用：<code>类名.方法</code>，也可以通过cls访问类的属性和其他的类方法</p>
<pre><code class="python">@classmethod
def 类方法名(cls):
    pass</code></pre>
<pre><code class="python"># 例子
class Person:
    __discount = 0.8

    def __init__(self,price):
        self.__price = price

    @property
    def price(self):
        return self.__price * Person.__discount

    @classmethod
    def price_discount(cls,new_discount):
        cls.__discount = new_discount


apple = Person(5)
print(apple.price)

Person.price_discount(1)
print(apple.price)</code></pre>
<h2 id="staticmethod"><a href="#staticmethod" class="headerlink" title="staticmethod"></a>staticmethod</h2><p><code>staticmethod</code>：静态方法</p>
<p>在完全面向对象的程序中，如果一个函数，即和对象没有关系，也和类没有关系，就将一个函数变成一个静态方法</p>
<p>调用：<code>类名.方法</code></p>
<pre><code class="python">@staticmethod
def 静态方法名():
    pass</code></pre>
<pre><code class="python">class Login:
    def __init__(self,username,password):
        self.__username = username
        self.__password = password

    def login(self):
        pass

    @staticmethod
    def get_input():
        user = input(&#39;username：&#39;)
        pwd = input(&#39;password：&#39;)
        Login(user,pwd)

Login.get_input()</code></pre>
<blockquote>
<p>Ps：类方法和静态方法 都是类调用的<br>对象可以调用类方法和静态方法，一般情况下，推荐用类名调用<br>类方法 有一个默认参数 cls代表这个类</p>
</blockquote>
<h1 id="0x04-多态"><a href="#0x04-多态" class="headerlink" title="0x04 多态"></a>0x04 多态</h1><p>python天生支持多态，多态指的是同一种事物的多种状态</p>
<p>多态不同的子类对象调用相同的父类方法，产生不同的执行结果</p>
<ul>
<li>增加代码的灵活度</li>
<li>以继承和重写父类方法为前提</li>
<li>是调用方法的技巧，不会影响到类的内部设计</li>
</ul>
<h1 id="0x05-组合"><a href="#0x05-组合" class="headerlink" title="0x05 组合"></a>0x05 组合</h1><p>一个对象的属性值是另一个类的对象</p>
<p>在一个类中以另外一个类的对象作为数据属性，成为类的组合</p>
<pre><code class="python"># 例子1
class Date:
    def __init__(self,year,mon,day):
        self.year=year
        self.mon=mon
        self.day=day

    def birth_info(self):
        print(&quot;The birth is %s-%s-%s&quot;%(self.year,self.mon,self.day))

class People:
    def __init__(self,name,age,year,mon,day):
        self.name=name
        self.age=age
        self.birth=Date(year,mon,day)

    def walk(self):
        print(&quot;%s is walking&quot;%self.name)

class Teacher(People):
    def __init__(self,name,age,year,mon,day,course):
        People.__init__(self,name,age,year,mon,day)
        self.course=course

    def teach(self):
        print(&quot;%s is teaching&quot;%self.name)

class Student(People):
    def __init__(self,name,age,year,mon,day,group):
        People.__init__(self,name,age,year,mon,day)
        self.group=group

    def study(self):
        print(&quot;%s is studying&quot;%self.name)
t1=Teacher(&quot;alex&quot;,28,1989,9,2,&quot;python&quot;)
s1=Student(&quot;jack&quot;,22,1995,2,8,&quot;group2&quot;)
print(t1.birth.birth_info())</code></pre>
<pre><code class="python"># 例子2
class BirthDate:
    def __init__(self,year,month,day):
        self.year=year
        self.month=month
        self.day=day

class Couse:
    def __init__(self,name,price,period):
        self.name=name
        self.price=price
        self.period=period

class Teacher:
    def __init__(self,name,gender,birth,course):
        self.name=name 
        self.gender=gender
        self.birth=birth
        self.course=course
    def teach(self): 
        print(&#39;teaching&#39;)

p1=Teacher(&#39;egon&#39;,&#39;male&#39;, 
            BirthDate(&#39;1995&#39;,&#39;1&#39;,&#39;27&#39;), 
            Couse(&#39;python&#39;,&#39;28000&#39;,&#39;4 months&#39;)
           ) 

print(p1.birth.year,p1.birth.month,p1.birth.day) 

print(p1.course.name,p1.course.price,p1.course.period)
&#39;&#39;&#39; 
运行结果: 
1 27 
python 28000 4 months 
&#39;&#39;&#39;</code></pre>
<h1 id="0x06-单例设计模式"><a href="#0x06-单例设计模式" class="headerlink" title="0x06 单例设计模式"></a>0x06 单例设计模式</h1><p>设计模式：前任工作的总结和<code>提炼</code>，为了可重用代码，让代码更容易被人理解</p>
<p>单列设计模式：机制：当你第一次实例化这个类的时候，就创建一个实例化的对象，当你之后再实例化，就用之前创建的对象，把原来的重复的属性覆盖，而不同的属性则继承下来</p>
<h2 id="重写-new-方法"><a href="#重写-new-方法" class="headerlink" title="重写__new__方法"></a>重写<code>__new__</code>方法</h2><p>利用<code>__new__</code>方法</p>
<p>使用<strong>类名()</strong>创建对象时，Python解释器首先会调用<code>__new__</code>方法为对象<strong>分配空间</strong></p>
<p>主要作用：</p>
<ol>
<li>在内存中为对象分配空间</li>
<li>返回对象的引用</li>
</ol>
<p>Python的解释器获得对象的引用后，将引用作为<strong>第一个参数</strong>，传递给<code>__init__</code>方法</p>
<blockquote>
<p> 重写<code>__new__</code>方法的代码非常固定</p>
<p> 一定要<code>return super().__new__(cls)</code></p>
<p> 否则Python解释器得不到分配了空间的对象引用，就会调用对象的初始化方法</p>
<p> 在调用时需要主动传递<code>cls</code>参数（静态方法）</p>
</blockquote>
<p><code>*</code>：多参数元组形式</p>
<p><code>**</code>：多参数字典形式</p>
<pre><code class="python"># 例子1
class Person:
    def __new__(cls, *args, **kwargs):
        print(&#39;test&#39;)
        instance = super().__new__(cls)
        return instance

    def __init__(self, name):
        self.name = name

name1 = Person(&#39;alex&#39;)</code></pre>
<pre><code class="python"># 例子2
class DataTest:
    __instance = False

    def __init__(self, name,id):
        self.name = name
        self.id = id

    def __new__(cls, *args, **kwargs):
        # 判断属性是否赋值
        if cls.__instance:
            return cls.__instance
        cls.__instance = object.__new__(cls)
        return cls.__instance

data = DataTest(&#39;alex&#39;,&#39;1&#39;)
nas = DataTest(&#39;nice&#39;,&#39;2&#39;)
print(data)
print(nas)</code></pre>
<h2 id="初始化方法执行一次"><a href="#初始化方法执行一次" class="headerlink" title="初始化方法执行一次"></a>初始化方法执行一次</h2><p>让初始化方法只执行一次：</p>
<ol>
<li>标记是否执行过初始化方法</li>
<li>在<code>__init__</code>进行判断</li>
<li>然后修改标记</li>
</ol>
<pre><code class="python">class Person:
    info = False
    __instance = False

    def __new__(cls, *args, **kwargs):
        # 判断属性是否赋值
        if cls.__instance:
            return cls.__instance
        cls.__instance = object.__new__(cls)
        return cls.__instance

    def __init__(self, name):
        if Person.info:
            return
        self.name = name
        Person.info = True

name1 = Person(&#39;alex&#39;)
print(name1)
name2 = Person(&#39;alex2&#39;)
print(name2)</code></pre>
<h1 id="0x07-异常"><a href="#0x07-异常" class="headerlink" title="0x07 异常"></a>0x07 异常</h1><h2 id="异常和错误的概念"><a href="#异常和错误的概念" class="headerlink" title="异常和错误的概念"></a>异常和错误的概念</h2><p><code>错误：</code>语法错误，逻辑错误</p>
<p><code>异常</code>：程序运行时发生的错误信号 程序一旦发生错误，就从错误的位置停下来，不在继续执行后面的内容</p>
<blockquote>
<p>Ps：抛出异常的一瞬间，程序并不会立即终止，而是会把异常传递给函数/方法的调用一方，如果传递到主程序，任然没有异常处理，程序才会被终止</p>
</blockquote>
<p><strong>基础语法</strong></p>
<pre><code class="python">try:
    被检测的代码块
except:
    try中一旦检测到异常，就会执行这个位置的逻辑</code></pre>
<h2 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h2><table>
<thead>
<tr>
<th>异常名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>BaseException</td>
<td>所有异常的基类</td>
</tr>
<tr>
<td>SystemExit</td>
<td>解释器请求退出</td>
</tr>
<tr>
<td>KeyboardInterrupt</td>
<td>用户中断执行(通常是输入^C)</td>
</tr>
<tr>
<td>Exception</td>
<td>常规错误的基类</td>
</tr>
<tr>
<td>StopIteration</td>
<td>迭代器没有更多的值</td>
</tr>
<tr>
<td>GeneratorExit</td>
<td>生成器(generator)发生异常来通知退出</td>
</tr>
<tr>
<td>StandardError</td>
<td></td>
</tr>
<tr>
<td>ArithmeticError</td>
<td>所有数值计算错误的基类</td>
</tr>
<tr>
<td>FloatingPointError</td>
<td>浮点计算错误</td>
</tr>
<tr>
<td>OverflowError</td>
<td>数值运算超出最大限制</td>
</tr>
<tr>
<td>ZeroDivisionError</td>
<td>除(或取模)零 (所有数据类型)</td>
</tr>
<tr>
<td>AssertionError</td>
<td>断言语句失败</td>
</tr>
<tr>
<td>AttributeError</td>
<td>对象没有这个属性</td>
</tr>
<tr>
<td>EOFError</td>
<td>没有内建输入,到达EOF 标记</td>
</tr>
<tr>
<td>EnvironmentError</td>
<td>操作系统错误的基类</td>
</tr>
<tr>
<td>IOError</td>
<td>输入/输出操作失败</td>
</tr>
<tr>
<td>OSError</td>
<td>操作系统错误</td>
</tr>
<tr>
<td>WindowsError</td>
<td>系统调用失败</td>
</tr>
<tr>
<td>ImportError</td>
<td>导入模块/对象失败</td>
</tr>
<tr>
<td>LookupError</td>
<td>无效数据查询的基类</td>
</tr>
<tr>
<td>IndexError</td>
<td>序列中没有此索引(index)</td>
</tr>
<tr>
<td>KeyError</td>
<td>映射中没有这个键</td>
</tr>
<tr>
<td>MemoryError</td>
<td>内存溢出错误(对于Python 解释器不是致命的)</td>
</tr>
<tr>
<td>NameError</td>
<td>未声明/初始化对象 (没有属性)</td>
</tr>
<tr>
<td>UnboundLocalError</td>
<td>访问未初始化的本地变量</td>
</tr>
<tr>
<td>ReferenceError</td>
<td>弱引用(Weak reference)试图访问已经垃圾回收了的对象</td>
</tr>
<tr>
<td>RuntimeError</td>
<td>一般的运行时错误</td>
</tr>
<tr>
<td>NotImplementedError</td>
<td>尚未实现的方法</td>
</tr>
<tr>
<td>SyntaxError</td>
<td>Python 语法错误</td>
</tr>
<tr>
<td>IndentationError</td>
<td>缩进错误</td>
</tr>
<tr>
<td>TabError</td>
<td>Tab 和空格混用</td>
</tr>
<tr>
<td>SystemError</td>
<td>一般的解释器系统错误</td>
</tr>
<tr>
<td>TypeError</td>
<td>对类型无效的操作</td>
</tr>
<tr>
<td>ValueError</td>
<td>传入无效的参数</td>
</tr>
<tr>
<td>UnicodeError</td>
<td>Unicode 相关的错误</td>
</tr>
<tr>
<td>UnicodeDecodeError</td>
<td>Unicode 解码时的错误</td>
</tr>
<tr>
<td>UnicodeEncodeError</td>
<td>Unicode 编码时错误</td>
</tr>
<tr>
<td>UnicodeTranslateError</td>
<td>Unicode 转换时错误</td>
</tr>
<tr>
<td>Warning</td>
<td>警告的基类</td>
</tr>
<tr>
<td>DeprecationWarning</td>
<td>关于被弃用的特征的警告</td>
</tr>
<tr>
<td>FutureWarning</td>
<td>关于构造将来语义会有改变的警告</td>
</tr>
<tr>
<td>OverflowWarning</td>
<td>旧的关于自动提升为长整型(long)的警告</td>
</tr>
<tr>
<td>PendingDeprecationWarning</td>
<td>关于特性将会被废弃的警告</td>
</tr>
<tr>
<td>RuntimeWarning</td>
<td>可疑的运行时行为(runtime behavior)的警告</td>
</tr>
<tr>
<td>SyntaxWarning</td>
<td>可疑的语法的警告</td>
</tr>
<tr>
<td>UserWarning</td>
<td>用户代码生成的警告</td>
</tr>
</tbody></table>
<blockquote>
<p> Tips：<code>异常类只能用来处理指定的异常情况，如果非指定异常则无法处理</code></p>
</blockquote>
<pre><code class="python">s1 = &#39;hello&#39;
try:
    int(s1)
except IndexError as e:
    print e</code></pre>
<h2 id="多分支与万能异常"><a href="#多分支与万能异常" class="headerlink" title="多分支与万能异常"></a>多分支与万能异常</h2><p><strong>多分支</strong></p>
<pre><code class="python">s1 = &#39;hello&#39;
try:
    int(s1)
except IndexError as e:
    print(e)
except KeyError as e:
    print(e)
except ValueError as e:
    print(e)</code></pre>
<p><strong>万能异常（Exception）：</strong></p>
<ul>
<li><p>捕获任意异常</p>
<pre><code class="python">try:
    被检测的代码块
except Exception as e:
    print(e)</code></pre>
</li>
</ul>
<p><strong>主动抛出异常</strong>：根据应用程序特有的业务需求主动抛出异常</p>
<ol>
<li>创建一个<code>Exception</code>的对象</li>
<li>使用<code>raise</code>关键字抛出异常对象</li>
</ol>
<p><code>raise</code>：显示引发异常，一旦执行了raise语句，raise后面的语句将不能执行</p>
<pre><code class="python">raise [Exception [, args [, traceback]]]</code></pre>
<pre><code class="python">def input_pwd():
    pwd = input(&quot;请输入密码&quot;)
    if len(pwd) &gt;= 8:
        return pwd
    print(&quot;错误&quot;)
    ex = Exception(&quot;密码长度不够8位&quot;)
    raise ex

try:
    print(input_pwd())
except Exception as result:
    print(result)</code></pre>
<p>如果你想要的效果是，对于不同的异常我们需要定制不同的处理逻辑，那就需要用到多分支</p>
<pre><code class="python]">s1 = &#39;hello&#39;
try:
    int(s1)
except IndexError as e:
    print(e)
except KeyError as e:
    print(e)
except ValueError as e:
    print(e)
except Exception as e:
    print(e)</code></pre>
<h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>无论异常是否发生，在程序结束前，finally中的语句都会被执行 finally和return相遇的时候，依然会执行 函数里做异常处理用，不管是否异常去做一些收尾工作</p>
<pre><code class="python">try:
    被检测的代码块
finally:
    print(&#39;xxxx&#39;)</code></pre>
<pre><code class="python"># -*- coding: UTF-8 -*-
def tryTest():  
    try:  
        demo = input(&quot;input a number:&quot;)  
        x = 1.0/int(demo)  
        print x  
        return 1 
    except Exception, e:  
        print e  
        return 0 
    finally:  
        print &quot;this is a finally test&quot; 

if __name__ == &#39;__main__&#39;:
    result = tryTest()  
    print result</code></pre>
<h1 id="0x08-模块"><a href="#0x08-模块" class="headerlink" title="0x08 模块"></a>0x08 模块</h1><p><code>模块</code>：一个模块就是一个包含了python定义和声明的文件，文件名就是模块名+.py的后缀</p>
<p>在模块中定义的全局变量，函数，类都是提供给外界直接使用的工具</p>
<p><code>import</code>加载的模块分为四个通用类别：</p>
<ol>
<li>使用python编写的代码（.py文件）</li>
<li>已被编译为共享库或DLL的C或C++扩展</li>
<li>包好一组模块的包</li>
<li>使用C编写并链接到python解释器的内置模块</li>
</ol>
<p>模块可以包含可执行的语句和函数定义，这些语句的目的是初始化模块 它们只在模块名第一遇到导入import语句时才执行 为了防止你重复导入</p>
<p>python的优化手段：第一次导入后就将模块加载到内存了，后续的iimport语句仅是对已加载大内存中的模块对象增加一个引用，不会重新执行模块内的语句</p>
<blockquote>
<p>Ps：从<code>sys.modules</code>中找到当前已经加载的模块，<code>sys.modules</code>是一个字典，内部包含模块名与模块对象的映射，该字典决定了导入模块时是否需要重新导入</p>
</blockquote>
<h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><p>每个模块都是一个独立的名称空间，定义在这个模块中的函数，把这个模块的名称当做全局名称空间 这样我们在编写自己的模块时，就不用担心我们定义在自己模块中全局变量会被导入时，与使用者的全局变量冲突</p>
<p><strong>原则</strong>：每一个文件都应该是可以被导入的，<code>在导入文件时，文件中所有没有任何缩进的代码，都会被执行一遍</code></p>
<p>首次导入模块时会做的三件事</p>
<ul>
<li>为源文件创建新的名称空间</li>
<li>在新建命名空间中执行模块中包含的代码</li>
<li>创建名称***来引用该命名空间</li>
</ul>
<ul>
<li><p><code>import</code>导入</p>
<pre><code class="python">import 模块1,模块2</code></pre>
<p>导入之后：通过<code>模块名.</code>使用模块提供的工具 – 全局变量，函数，类</p>
<blockquote>
<p>Ps：在导入模块时，每个导入应独占一行</p>
</blockquote>
</li>
<li><p><code>from...import...</code>导入</p>
<pre><code class="python">from 模块 import 方法

# 例子
from time import sleep</code></pre>
<p>如果希望从某一个模块中，导入部分的函数功能，就可以使用</p>
<p>直接使用模块提供的函数</p>
<blockquote>
<p>Ps：如果两个模块，存在同名的函数，那么导入模块的函数，会覆盖掉先导入的函数</p>
</blockquote>
</li>
<li><p><code>from...import *</code>（仅限了解）</p>
<pre><code class="python">from time import *</code></pre>
<p>导入所有的方法和属性</p>
<blockquote>
<p>不推荐使用，因为函数重名并有任何的提示，出现问题不好debug</p>
</blockquote>
</li>
</ul>
<h2 id="指定模块别名"><a href="#指定模块别名" class="headerlink" title="指定模块别名"></a>指定模块别名</h2><p>使用<code>as</code></p>
<p>在模块名太长的情况下，可以使用<code>as</code>指定模块的名称</p>
<pre><code class="python">import 模块 as 模块别名

#例子
import time as f</code></pre>
<blockquote>
<p>Ps：模块别名应该符合大驼峰命名规则，<code>form...import</code>导入方式同样适用</p>
</blockquote>
<h2 id="模块搜索顺序"><a href="#模块搜索顺序" class="headerlink" title="模块搜索顺序"></a>模块搜索顺序</h2><p>python的解释器在导入模块时：</p>
<ol>
<li>搜索当前目录指定模块名的文件，如果有就直接导入</li>
<li>没有，再搜索系统目录</li>
</ol>
<blockquote>
<p>在开发时，给文件起名，不要和系统的模块文件重名</p>
</blockquote>
<p><code>__file__</code>：查看模块的完整路径</p>
<pre><code class="python">import random
print(random.__file__)</code></pre>
<h2 id="在模块文件中测试"><a href="#在模块文件中测试" class="headerlink" title="在模块文件中测试"></a>在模块文件中测试</h2><p>使用<code>__name__</code>属性,记录着一个字符串</p>
<p><code>__name__</code>：在其他脚本调用（导入）的的时候<strong>name</strong>显示的是模块的名字 而在原模块调用的时候显示的是<code>__main__</code></p>
<pre><code class="python">if __name__ == &#39;__main__&#39;:
    pass</code></pre>
<p>通过上面的方式，python就可以分清楚哪些是主函数，进入函数执行，并且可以调用其他模块的各个函数等等</p>
<h1 id="0x09-包（Package）"><a href="#0x09-包（Package）" class="headerlink" title="0x09 包（Package）"></a>0x09 包（Package）</h1><p><code>包</code>：一个<strong>包含多个模块的特殊目录</strong>，目录下有一个<strong>特殊的文件</strong><code>__init__.py</code></p>
<p>包即模块 import导入文件时，产生名称空间中的名字来源于文件，import包，产生的名称空间的名字同样来源于文件，即包下的<code>__init__.py</code>，导入包本质就是在导入该文件</p>
<p>在python3中，即使包下没有<code>__init__.py</code>文件，import包任然不会报错</p>
<p>在python2中，包下一定要有该文件，否则import包会报错</p>
<blockquote>
<p>Ps：导入包遵循的原则：<code>凡是在导入时带点的，点的左边都必须是一个包，否则非法</code>，item.subitem.subsubitem 对于导入后，在使用时就没有这种限制了，点的左边可以是包，模块，函数(它们都可以用点的方式调用自己的属性)</p>
</blockquote>
<p><img src="%5Cimages%5Cpython%5C%E5%8C%85%5C%E5%8C%85.png" srcset="/img/loading.gif" alt=""></p>
<pre><code class="python">import 包名</code></pre>
<p><code>from...import...</code>导入</p>
<pre><code class="python">from glance.api import policy</code></pre>
<blockquote>
<p> Ps：from后import导入的模块，必须是明确的一个不能带点，否则会有语法错误</p>
<p> <code>_init_.py</code>文件 不管是哪种方式，只要是第一次导入包或是包的任意其他部分，都会依次执行包下的<code>__init__.py</code>这个文件可以为空，但是也可以存放一些初始化包的代码</p>
</blockquote>
<h2 id="绝对导入和相对导入"><a href="#绝对导入和相对导入" class="headerlink" title="绝对导入和相对导入"></a>绝对导入和相对导入</h2><ul>
<li><p>绝对导入</p>
<pre><code class="python">格式：from glance.api import policy

# 路径图
glance/                   
├── __init__.py      from glance import api
                     from glance import cmd
                     from glance import db

├── api                  
│   ├── __init__.py  from glance.api import policy
                     from glance.api import versions
│   ├── policy.py
│   └── versions.py

├── cmd                 from glance.cmd import manage
│   ├── __init__.py
│   └── manage.py

└── db                   from glance.db import models
    ├── __init__.py
    └── models.py</code></pre>
</li>
<li><p>相对导入</p>
<blockquote>
<p><code>.</code>或<code>..</code>的方式为起始</p>
</blockquote>
<pre><code class="python">格式：from .api import policy

# 路径图
glance/                   
├── __init__.py      from . import api  #.表示当前目录
                     from . import cmd
                     from . import db
├── api                  
│   ├── __init__.py  from . import policy
                     from . import versions
│   ├── policy.py
│   └── versions.py

├── cmd              from . import manage
│   ├── __init__.py
│   └── manage.py    from ..api import policy   
#..表示上一级目录，想再manage中使用policy中的方法就需要回到上一级glance目录往下找api包，从api导入policy
└── db               from . import models
    ├── __init__.py
    └── models.py</code></pre>
<blockquote>
<p>Ps：一定要在与glance同级的文件中测试 包里的模块如果想使用其他模块的内容只能使用相对路径，使用了相对路径就不能在包内直接执行了 可以用import导入内置或者第三方模块，但是要绝对避免使用import来导入自定义包的子模块， 应使用from…import…的绝对或者相对导入且包的相对导入只能用from的形式</p>
</blockquote>
</li>
</ul>
<h2 id="单独导入"><a href="#单独导入" class="headerlink" title="单独导入"></a>单独导入</h2><p>单独导入包名称时不会导入包中所有包含的所有子模块</p>
<p>在glance同级中的.py文件中</p>
<pre><code>import glance
glance.api.policy()

&#39;&#39;&#39;
结果：AttributeError: module &#39;glance&#39; has no attribute &#39;cmd&#39;
&#39;&#39;&#39;</code></pre><p>解决方法</p>
<pre><code class="python"># glance/__init__.py
from . import cmd

# glance/cmd/__init__.py
from . import manage</code></pre>
<p>再次执行</p>
<pre><code class="python"># 在于glance同级的.py中
import glance
glance.api.policy()</code></pre>
<h2 id="init-py文件"><a href="#init-py文件" class="headerlink" title="__init__.py文件"></a><code>__init__.py</code>文件</h2><p>要在外界使用包的模块，需要再<code>__init__.py</code>中指定<code>对外界提供的模块列表</code></p>
<p>当前目录下导入</p>
<pre><code class="python">from . import send_message</code></pre>
<p><img src="%5Cimages%5Cpython%5C%E5%8C%85%5Cinit.png" srcset="/img/loading.gif" alt=""><br><img src="%5Cimages%5Cpython%5C%E5%8C%85%5Capi.png" srcset="/img/loading.gif" alt=""><br><img src="%5Cimages%5Cpython%5C%E5%8C%85%5Cinit_import.png" srcset="/img/loading.gif" alt=""></p>
<h2 id="all"><a href="#all" class="headerlink" title="all"></a>all</h2><p><code>__all__</code>可用于模块导入时限制 此时被导入模块若定义了<code>__all__</code>属性，则只有all内指定的属性，方法，类可被导入</p>
<pre><code class="python">glance/                   
├── __init__.py     from .api import *
                    from .cmd import *
                    from .db import *    
├── api                  
│   ├── __init__.py   __all__ = [&#39;policy&#39;,&#39;versions&#39;] 
│   ├── policy.py
│   └── versions.py
├── cmd               __all__ = [&#39;manage&#39;]    
│   ├── __init__.py
│   └── manage.py    
└── db                __all__ = [&#39;models&#39;]              
    ├── __init__.py
    └── models.py

import glance
policy.get()</code></pre>
<h2 id="发布模块及安装"><a href="#发布模块及安装" class="headerlink" title="发布模块及安装"></a>发布模块及安装</h2><ul>
<li><p>创建setup.py</p>
<pre><code class="python">   from distutils.core import setup</code></pre>
<p>setup( name = “包名”,<br>​        version = “版本”,<br>​        description = “描述信息”,<br>​        long_description = “完整描述”,<br>​        author = “作者”,<br>​        url = “主页”,<br>​        py_modules = [<br>​            “包.模块”，..]<br>)</p>
<pre><code></code></pre></li>
<li><p>构建模块</p>
<pre><code class="python">python3 setup.py build</code></pre>
</li>
<li><p>生成发布压缩包</p>
<pre><code class="python">python3 setup.py sdist</code></pre>
</li>
</ul>
<h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><ol>
<li>先解压</li>
<li>进行安装</li>
</ol>
<pre><code class="python">tar -zxvf 压缩包
sudo python3 setup.py install</code></pre>
<h3 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a>卸载模块</h3><p>直接从安装目录下，把安装模块的目录删除就可以</p>
<pre><code>cd /usr/loacl/lib/python3.x/dist-packages/
sudo rm -r 模块*</code></pre><h3 id="pip-安装第三方模块"><a href="#pip-安装第三方模块" class="headerlink" title="pip 安装第三方模块"></a>pip 安装第三方模块</h3><pre><code class="python">sudo pip3 install 模块名</code></pre>
<h3 id="安装IPython"><a href="#安装IPython" class="headerlink" title="安装IPython"></a>安装IPython</h3><pre><code># MAC下
sudo pip install ipython

# Linux下
sudo apt install ipython
sudo apt install ipython3</code></pre><h1 id="0x10-文本操作"><a href="#0x10-文本操作" class="headerlink" title="0x10 文本操作"></a>0x10 文本操作</h1><p><code>文件</code>：存储在某种长期储存设备上的一段数据</p>
<p><code>文件的作用</code>：将数据长期保存下来，在需要的时候使用</p>
<p><code>文件存储方式</code>：以二进制的方式保存在磁盘上的</p>
<p><strong>文本文件</strong>：</p>
<ul>
<li>可以使用文本编辑软件查看</li>
<li>本质上还是二进制文件</li>
</ul>
<p><strong>二进制文件</strong>：</p>
<ul>
<li>保存的内容不是给人直接阅读的，而是提供给其他软件使用的</li>
<li>二进制文件不能使用文本编辑软件查看</li>
</ul>
<h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><p>基本步骤：</p>
<ul>
<li><p>打开（<code>open()</code>）</p>
</li>
<li><p>读/写</p>
<ul>
<li><p>读</p>
<pre><code class="python">readlines()    #读取所有行的内容
readline(n)    #n：代表最长字节数，视频，图片，（rb,bytes按照字节读）
read()    #读取所有行的内容</code></pre>
</li>
<li><p>写</p>
<pre><code class="python">write()</code></pre>
</li>
</ul>
</li>
<li><p>关闭(<code>close()</code>)</p>
</li>
</ul>
<h2 id="文件指针-光标"><a href="#文件指针-光标" class="headerlink" title="文件指针(光标)"></a>文件指针(光标)</h2><p>文件指针<code>标记</code>从哪个位置开始读取数据</p>
<p>第一次打开文件时，通常文件指针会指向文件的开始位置</p>
<p>当执行了<code>read</code>方法后，文件指针会移动到<strong>读取内容的末尾</strong></p>
<ul>
<li><p><code>file.sekk()</code></p>
<p>移动文件读取指针到指定位置</p>
<pre><code class="python">sekk(offset,whence=0)

&#39;&#39;&#39;
offset：开始的偏移量，也就是代表需要移动偏移的字节数
whence：给offset参数一个定义，表示要从哪个位置开始偏移，0代表从文件开头算起，1代表开始从当前位置开始算起，2代表从文件末尾开始算起，当有换行时，会被换行截断
seek()无返回值
&#39;&#39;&#39;</code></pre>
</li>
<li><p><code>tell()</code></p>
<p>tell是获取文件指针位置</p>
</li>
<li><p><code>truncate()</code></p>
<p>用于截断文件并返回截断的字节长度</p>
<pre><code class="python">fileObject.truncate([size])</code></pre>
</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><p><code>readable()</code></p>
<p>是否可读可写</p>
</li>
<li><p><code>writable()</code></p>
<p>是否可写</p>
</li>
</ul>
<h2 id="删除文件与重命名"><a href="#删除文件与重命名" class="headerlink" title="删除文件与重命名"></a>删除文件与重命名</h2><pre><code class="python">import os

# 删除文件
os.remove()
# 重命名
os.rename(&#39;xxxx.txr&#39;,&#39;rrrr&#39;)</code></pre>

            </div>
            <hr>
            <div>
              <p>
                
                  <span>
                <i class="iconfont icon-inbox"></i>
                    
                      <a class="hover-with-bg" href="/categories/Python/">Python</a>
                      &nbsp;
                    
                  </span>&nbsp;&nbsp;
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/tags/Python/">Python</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-12 col-md-6">
                    
                      <a href="/2019/08/19/Python/zip%E5%AF%86%E7%A0%81%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/">
                        <i class="fa fa-chevron-left"></i>
                        <span>zip密码暴力破解-python</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-12 col-md-6">
                    
                      <a href="/2019/08/19/Python/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/">
                        <span>Python基础</span>
                        <i class="fa fa-chevron-right"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">
  <div class="text-center py-3">
    <div>
      <a rel="nofollow noopener"><b>2018</b></a>
      <i class="fab fa-angular"></i>
      <a rel="nofollow noopener"> <b>只因不值得</b></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/js/main.js" ></script>


  <script  src="/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;
      var tocLimMax = 2 * boardTop + boardCtn.height();

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = boardCtn.css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>










<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  ');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "Python基础之面向对象&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>












</body>
</html>
